{"ast":null,"code":"import CategoryAxis from './category-axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\nimport { CENTER, DATE, DEFAULT_PRECISION, MAX_VALUE, OBJECT, X, Y } from '../common/constants';\nimport { deepExtend, defined, inArray, last, limitValue, round, setDefaultOptions, sparseArrayLimits } from '../common';\nimport { MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS, TIME_PER_MINUTE, TIME_PER_HOUR, TIME_PER_DAY, TIME_PER_WEEK, TIME_PER_MONTH, TIME_PER_YEAR, TIME_PER_UNIT } from '../date-utils/constants';\nimport { dateComparer, toDate, addTicks, addDuration, dateDiff, absoluteDateDiff, dateIndex, dateEquals, toTime, parseDate, parseDates, firstDay } from '../date-utils';\nimport { DateLabelFormats } from './constants';\nconst AUTO = \"auto\";\nconst BASE_UNITS = [MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS];\nconst FIT = \"fit\";\nfunction categoryRange(categories, clearCache) {\n  if (clearCache) {\n    categories._range = undefined;\n  }\n  let range = categories._range;\n  if (!range) {\n    range = categories._range = sparseArrayLimits(categories);\n    range.min = toDate(range.min);\n    range.max = toDate(range.max);\n  }\n  return range;\n}\nclass EmptyDateRange {\n  constructor(options) {\n    this.options = options;\n  }\n  displayIndices() {\n    return {\n      min: 0,\n      max: 1\n    };\n  }\n  displayRange() {\n    return {};\n  }\n  total() {\n    return {};\n  }\n  valueRange() {\n    return {};\n  }\n  valueIndex() {\n    return -1;\n  }\n  values() {\n    return [];\n  }\n  totalIndex() {\n    return -1;\n  }\n  valuesCount() {\n    return 0;\n  }\n  totalCount() {\n    return 0;\n  }\n  dateAt() {\n    return null;\n  }\n}\nclass DateRange {\n  constructor(start, end, options) {\n    this.options = options;\n    options.baseUnitStep = options.baseUnitStep || 1;\n    const {\n      roundToBaseUnit,\n      justified\n    } = options;\n    this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);\n    const lowerEnd = this.roundToTotalStep(end);\n    const expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;\n    this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);\n    const min = options.min || start;\n    this.valueStart = this.roundToTotalStep(min);\n    this.displayStart = roundToBaseUnit ? this.valueStart : min;\n    const max = options.max;\n    if (!max) {\n      this.valueEnd = lowerEnd;\n      this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;\n    } else {\n      const next = !justified && dateEquals(max, this.roundToTotalStep(max)) ? -1 : 0;\n      this.valueEnd = this.roundToTotalStep(max, false, next);\n      this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max, !justified) : options.max;\n    }\n    if (this.valueEnd < this.valueStart) {\n      this.valueEnd = this.valueStart;\n    }\n    if (this.displayEnd <= this.displayStart) {\n      this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);\n    }\n  }\n  displayRange() {\n    return {\n      min: this.displayStart,\n      max: this.displayEnd\n    };\n  }\n  displayIndices() {\n    if (!this._indices) {\n      const options = this.options;\n      const {\n        baseUnit,\n        baseUnitStep\n      } = options;\n      const minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);\n      const maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);\n      this._indices = {\n        min: minIdx,\n        max: maxIdx\n      };\n    }\n    return this._indices;\n  }\n  total() {\n    return {\n      min: this.start,\n      max: this.end\n    };\n  }\n  totalCount() {\n    const last = this.totalIndex(this.end);\n    return last + (this.options.justified ? 1 : 0);\n  }\n  valueRange() {\n    return {\n      min: this.valueStart,\n      max: this.valueEnd\n    };\n  }\n  valueIndex(value) {\n    const options = this.options;\n    return Math.floor(dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep));\n  }\n  totalIndex(value) {\n    const options = this.options;\n    return Math.floor(dateIndex(value, this.start, options.baseUnit, options.baseUnitStep));\n  }\n  dateIndex(value) {\n    const options = this.options;\n    return dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep);\n  }\n  valuesCount() {\n    const maxIdx = this.valueIndex(this.valueEnd);\n    return maxIdx + 1;\n  }\n  values() {\n    let values = this._values;\n    if (!values) {\n      const options = this.options;\n      const range = this.valueRange();\n      this._values = values = [];\n      for (let date = range.min; date <= range.max;) {\n        values.push(date);\n        date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);\n      }\n    }\n    return values;\n  }\n  dateAt(index, total) {\n    const options = this.options;\n    return addDuration(total ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);\n  }\n  roundToTotalStep(value, upper, next) {\n    const {\n      baseUnit,\n      baseUnitStep,\n      weekStartDay\n    } = this.options;\n    const start = this.start;\n    const step = dateIndex(value, start, baseUnit, baseUnitStep);\n    let roundedStep = upper ? Math.ceil(step) : Math.floor(step);\n    if (next) {\n      roundedStep += next;\n    }\n    return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);\n  }\n}\nfunction autoBaseUnit(options, startUnit, startStep) {\n  const categoryLimits = categoryRange(options.categories);\n  const span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);\n  const {\n    autoBaseUnitSteps,\n    maxDateGroups\n  } = options;\n  const autoUnit = options.baseUnit === FIT;\n  let autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;\n  let baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;\n  let units = span / TIME_PER_UNIT[baseUnit];\n  let totalUnits = units;\n  let unitSteps, step, nextStep;\n  while (!step || units >= maxDateGroups) {\n    unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);\n    do {\n      nextStep = unitSteps.shift();\n    } while (nextStep && startUnit === baseUnit && nextStep < startStep);\n    if (nextStep) {\n      step = nextStep;\n      units = totalUnits / step;\n    } else if (baseUnit === last(BASE_UNITS)) {\n      step = Math.ceil(totalUnits / maxDateGroups);\n      break;\n    } else if (autoUnit) {\n      baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);\n      totalUnits = span / TIME_PER_UNIT[baseUnit];\n      unitSteps = null;\n    } else {\n      if (units > maxDateGroups) {\n        step = Math.ceil(totalUnits / maxDateGroups);\n      }\n      break;\n    }\n  }\n  options.baseUnitStep = step;\n  options.baseUnit = baseUnit;\n}\nfunction defaultBaseUnit(options) {\n  const categories = options.categories;\n  const count = defined(categories) ? categories.length : 0;\n  let minDiff = MAX_VALUE;\n  let lastCategory, unit;\n  for (let categoryIx = 0; categoryIx < count; categoryIx++) {\n    const category = categories[categoryIx];\n    if (category && lastCategory) {\n      const diff = absoluteDateDiff(category, lastCategory);\n      if (diff > 0) {\n        minDiff = Math.min(minDiff, diff);\n        if (minDiff >= TIME_PER_YEAR) {\n          unit = YEARS;\n        } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {\n          unit = MONTHS;\n        } else if (minDiff >= TIME_PER_WEEK) {\n          unit = WEEKS;\n        } else if (minDiff >= TIME_PER_DAY) {\n          unit = DAYS;\n        } else if (minDiff >= TIME_PER_HOUR) {\n          unit = HOURS;\n        } else if (minDiff >= TIME_PER_MINUTE) {\n          unit = MINUTES;\n        } else {\n          unit = SECONDS;\n        }\n      }\n    }\n    lastCategory = category;\n  }\n  options.baseUnit = unit || DAYS;\n}\nfunction initUnit(options) {\n  const baseUnit = (options.baseUnit || \"\").toLowerCase();\n  const useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);\n  if (useDefault) {\n    defaultBaseUnit(options);\n  }\n  if (baseUnit === FIT || options.baseUnitStep === AUTO) {\n    autoBaseUnit(options);\n  }\n  return options;\n}\nclass DateCategoryAxis extends CategoryAxis {\n  clone() {\n    const copy = new DateCategoryAxis(Object.assign({}, this.options), this.chartService);\n    copy.createLabels();\n    return copy;\n  }\n  categoriesHash() {\n    const start = this.dataRange.total().min;\n    return this.options.baseUnit + this.options.baseUnitStep + start;\n  }\n  initUserOptions(options) {\n    return options;\n  }\n  initFields() {\n    super.initFields();\n    const chartService = this.chartService;\n    const intlService = chartService.intl;\n    let options = this.options;\n    let categories = options.categories || [];\n    if (!categories._parsed) {\n      categories = parseDates(intlService, categories);\n      categories._parsed = true;\n    }\n    options = deepExtend({\n      roundToBaseUnit: true\n    }, options, {\n      categories: categories,\n      min: parseDate(intlService, options.min),\n      max: parseDate(intlService, options.max),\n      weekStartDay: firstDay(options, intlService)\n    });\n    if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {\n      options.roundToBaseUnit = false;\n    }\n    options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;\n    options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;\n    this.options = options;\n    options.srcCategories = categories;\n    if (categories.length > 0) {\n      const range = categoryRange(categories, true);\n      const maxDivisions = options.maxDivisions;\n      const safeOptions = initUnit(options);\n      const forecast = options._forecast;\n      if (forecast) {\n        if (forecast.before > 0) {\n          range.min = addDuration(range.min, -forecast.before, safeOptions.baseUnit, safeOptions.weekStartDay);\n        }\n        if (forecast.after > 0) {\n          range.max = addDuration(range.max, forecast.after, safeOptions.baseUnit, safeOptions.weekStartDay);\n        }\n      }\n      this.dataRange = new DateRange(range.min, range.max, safeOptions);\n      if (maxDivisions) {\n        const dataRange = this.dataRange.displayRange();\n        const divisionOptions = Object.assign({}, options, {\n          justified: true,\n          roundToBaseUnit: false,\n          baseUnit: 'fit',\n          min: dataRange.min,\n          max: dataRange.max,\n          maxDateGroups: maxDivisions\n        });\n        const dataRangeOptions = this.dataRange.options;\n        autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);\n        this.divisionRange = new DateRange(range.min, range.max, divisionOptions);\n      } else {\n        this.divisionRange = this.dataRange;\n      }\n    } else {\n      options.baseUnit = options.baseUnit || DAYS;\n      this.dataRange = this.divisionRange = new EmptyDateRange(options);\n    }\n    this.rangeLabels = [];\n  }\n  tickIndices(stepSize) {\n    const {\n      dataRange,\n      divisionRange\n    } = this;\n    const valuesCount = divisionRange.valuesCount();\n    if (!this.options.maxDivisions || !valuesCount) {\n      return super.tickIndices(stepSize);\n    }\n    const indices = [];\n    let values = divisionRange.values();\n    let offset = 0;\n    if (!this.options.justified) {\n      values = values.concat(divisionRange.dateAt(valuesCount));\n      offset = 0.5; //align ticks to the center of not justified categories\n    }\n\n    for (let idx = 0; idx < values.length; idx++) {\n      indices.push(dataRange.dateIndex(values[idx]) + offset);\n      if (stepSize !== 1 && idx >= 1) {\n        const last = indices.length - 1;\n        indices.splice(idx, 0, indices[last - 1] + (indices[last] - indices[last - 1]) * stepSize);\n      }\n    }\n    return indices;\n  }\n  shouldRenderNote(value) {\n    const range = this.range();\n    const categories = this.options.categories || [];\n    return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0 && categories.length;\n  }\n  parseNoteValue(value) {\n    return parseDate(this.chartService.intl, value);\n  }\n  noteSlot(value) {\n    return this.getSlot(value);\n  }\n  translateRange(delta) {\n    const options = this.options;\n    const {\n      baseUnit,\n      weekStartDay,\n      vertical\n    } = options;\n    const lineBox = this.lineBox();\n    const size = vertical ? lineBox.height() : lineBox.width();\n    let range = this.range();\n    const scale = size / (range.max - range.min);\n    const offset = round(delta / scale, DEFAULT_PRECISION);\n    if (range.min && range.max) {\n      const from = addTicks(options.min || range.min, offset);\n      const to = addTicks(options.max || range.max, offset);\n      range = {\n        min: addDuration(from, 0, baseUnit, weekStartDay),\n        max: addDuration(to, 0, baseUnit, weekStartDay)\n      };\n    }\n    return range;\n  }\n  labelsRange() {\n    return {\n      min: this.options.labels.skip,\n      max: this.divisionRange.valuesCount()\n    };\n  }\n  pan(delta) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    const options = this.options;\n    const lineBox = this.lineBox();\n    const size = options.vertical ? lineBox.height() : lineBox.width();\n    const {\n      min,\n      max\n    } = this.dataRange.displayRange();\n    const totalLimits = this.dataRange.total();\n    const scale = size / (max - min);\n    const offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);\n    const from = addTicks(min, offset);\n    const to = addTicks(max, offset);\n    const panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);\n    if (panRange) {\n      panRange.min = toDate(panRange.min);\n      panRange.max = toDate(panRange.max);\n      panRange.baseUnit = options.baseUnit;\n      panRange.baseUnitStep = options.baseUnitStep || 1;\n      panRange.userSetBaseUnit = options.userSetBaseUnit;\n      panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;\n      return panRange;\n    }\n  }\n  pointsRange(start, end) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    const pointsRange = super.pointsRange(start, end);\n    const datesRange = this.dataRange.displayRange();\n    const indicesRange = this.dataRange.displayIndices();\n    const scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);\n    const options = this.options;\n    const min = addTicks(datesRange.min, pointsRange.min * scale);\n    const max = addTicks(datesRange.min, pointsRange.max * scale);\n    return {\n      min: min,\n      max: max,\n      baseUnit: options.userSetBaseUnit || options.baseUnit,\n      baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n    };\n  }\n  scaleRange(scale, cursor) {\n    if (this.isEmpty()) {\n      return {};\n    }\n    const options = this.options;\n    const fit = options.userSetBaseUnit === FIT;\n    const totalLimits = this.dataRange.total();\n    const {\n      min: rangeMin,\n      max: rangeMax\n    } = this.dataRange.displayRange();\n    const position = Math.abs(this.pointOffset(cursor));\n    const range = rangeMax - rangeMin;\n    const delta = this.scaleToDelta(scale, range);\n    const minDelta = Math.round(position * delta);\n    const maxDelta = Math.round((1 - position) * delta);\n    let {\n      baseUnit\n    } = this.dataRange.options;\n    let min = new Date(rangeMin.getTime() + minDelta);\n    let max = new Date(rangeMax.getTime() - maxDelta);\n    if (fit) {\n      const {\n        autoBaseUnitSteps,\n        maxDateGroups\n      } = options;\n      const maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];\n      const rangeDiff = dateDiff(rangeMax, rangeMin);\n      const diff = dateDiff(max, min);\n      let baseUnitIndex = BASE_UNITS.indexOf(baseUnit);\n      let autoBaseUnitStep, ticks;\n      if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {\n        baseUnit = BASE_UNITS[baseUnitIndex - 1];\n        autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);\n        ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;\n        min = addTicks(rangeMin, ticks);\n        max = addTicks(rangeMax, -ticks);\n      } else if (diff > maxDiff && baseUnit !== YEARS) {\n        let stepIndex = 0;\n        do {\n          baseUnitIndex++;\n          baseUnit = BASE_UNITS[baseUnitIndex];\n          stepIndex = 0;\n          ticks = 2 * TIME_PER_UNIT[baseUnit];\n          do {\n            autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];\n            stepIndex++;\n          } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);\n        } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);\n        ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;\n        if (ticks > 0) {\n          min = addTicks(rangeMin, -ticks);\n          max = addTicks(rangeMax, ticks);\n          min = addTicks(min, limitValue(max, totalLimits.min, totalLimits.max) - max);\n          max = addTicks(max, limitValue(min, totalLimits.min, totalLimits.max) - min);\n        }\n      }\n    }\n    if (min && max && dateDiff(max, min) > 0) {\n      return {\n        min: min,\n        max: max,\n        baseUnit: options.userSetBaseUnit || options.baseUnit,\n        baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n      };\n    }\n  }\n  zoomRange(scale, cursor) {\n    const totalLimits = this.dataRange.total();\n    const range = this.scaleRange(scale, cursor);\n    if (range) {\n      if (range.min < totalLimits.min) {\n        range.min = totalLimits.min;\n      }\n      if (range.max > totalLimits.max) {\n        range.max = totalLimits.max;\n      }\n    }\n    return range;\n  }\n  range() {\n    return this.dataRange.displayRange();\n  }\n  createLabels() {\n    super.createLabels();\n    this.createRangeLabels();\n  }\n  clearLabels() {\n    super.clearLabels();\n    this.rangeLabels = [];\n  }\n  arrangeLabels() {\n    this.arrangeRangeLabels();\n    super.arrangeLabels();\n  }\n  arrangeRangeLabels() {\n    const {\n      options,\n      rangeLabels\n    } = this;\n    if (rangeLabels.length === 0) {\n      return;\n    }\n    const lineBox = this.lineBox();\n    const vertical = options.vertical;\n    const mirror = options.rangeLabels.mirror || options.labels.mirror;\n    const firstLabel = rangeLabels[0];\n    if (firstLabel) {\n      const position = vertical ? lineBox.y1 - firstLabel.box.height() / 2 : lineBox.x1;\n      this.positionLabel(firstLabel, mirror, position);\n    }\n    const lastLabel = rangeLabels[1];\n    if (lastLabel) {\n      const position = vertical ? lineBox.y2 - lastLabel.box.height() / 2 : lineBox.x2;\n      this.positionLabel(lastLabel, mirror, position);\n    }\n  }\n  autoRotateLabels() {\n    super.autoRotateLabels();\n    this.autoRotateRangeLabels();\n  }\n  hideOutOfRangeLabels() {\n    super.hideOutOfRangeLabels();\n    this.hideOverlappingLabels();\n  }\n  hideOverlappingLabels() {\n    const {\n      rangeLabels,\n      labels\n    } = this;\n    if (rangeLabels.length === 0) {\n      return;\n    }\n    function clip(rangeLabel, label) {\n      if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {\n        label.options.visible = false;\n        return true;\n      }\n      return false;\n    }\n    const firstRangeLabel = rangeLabels[0];\n    if (firstRangeLabel && firstRangeLabel.options.visible) {\n      for (let i = 0; i < labels.length; i++) {\n        const overlaps = clip(firstRangeLabel, labels[i]);\n        if (!overlaps) {\n          break;\n        }\n      }\n    }\n    const lastRangeLabel = rangeLabels[1];\n    if (lastRangeLabel && lastRangeLabel.options.visible) {\n      for (let i = labels.length - 1; i > 0; --i) {\n        const overlaps = clip(lastRangeLabel, labels[i]);\n        if (!overlaps) {\n          break;\n        }\n      }\n    }\n  }\n  contentBox() {\n    const box = super.contentBox();\n    const rangeLabels = this.rangeLabels;\n    for (let i = 0; i < rangeLabels.length; i++) {\n      const label = rangeLabels[i];\n      if (label.options.visible) {\n        box.wrap(label.box);\n      }\n    }\n    return box;\n  }\n  createAxisLabel(index, labelOptions, labelContext = {}) {\n    const options = this.options;\n    const dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;\n    const date = this.divisionRange.dateAt(index);\n    const unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n    labelOptions.format = labelOptions.format || unitFormat;\n    labelContext.dataItem = dataItem;\n    const text = this.axisLabelText(date, labelOptions, labelContext);\n    if (text) {\n      return new AxisLabel(date, text, index, dataItem, labelOptions);\n    }\n  }\n  createRangeLabels() {\n    const {\n      displayStart,\n      displayEnd\n    } = this.divisionRange;\n    const options = this.options;\n    const labelOptions = Object.assign({}, options.labels, options.rangeLabels, {\n      align: CENTER,\n      zIndex: options.zIndex\n    });\n    if (labelOptions.visible !== true) {\n      return;\n    }\n    this.normalizeLabelRotation(labelOptions);\n    labelOptions.alignRotation = CENTER;\n    if (labelOptions.rotation === \"auto\") {\n      labelOptions.rotation = 0;\n      options.autoRotateRangeLabels = true;\n    }\n    const unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n    labelOptions.format = labelOptions.format || unitFormat;\n    const createLabel = (index, date, text) => {\n      if (text) {\n        const label = new AxisLabel(date, text, index, null, labelOptions);\n        this.append(label);\n        this.rangeLabels.push(label);\n      }\n    };\n    const startText = this.axisLabelText(displayStart, labelOptions, {\n      index: 0,\n      count: 2\n    });\n    createLabel(0, displayStart, startText);\n    const endText = this.axisLabelText(displayEnd, labelOptions, {\n      index: 1,\n      count: 2\n    });\n    createLabel(1, displayEnd, endText);\n  }\n  autoRotateRangeLabels() {\n    const labels = this.rangeLabels;\n    if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {\n      return;\n    }\n    const rotateLabel = (label, tickPositions, index) => {\n      const width = Math.abs(tickPositions[index + 1] - tickPositions[index]) * 2;\n      const angle = this.autoRotateLabelAngle(label.box, width);\n      if (angle !== 0) {\n        label.options.rotation = angle;\n        label.reflow(new Box());\n      }\n    };\n    const tickPositions = this.getMajorTickPositions();\n    rotateLabel(labels[0], tickPositions, 0);\n    rotateLabel(labels[1], tickPositions, tickPositions.length - 2);\n  }\n  categoryIndex(value) {\n    return this.dataRange.valueIndex(value);\n  }\n  slot(from, to, limit) {\n    const dateRange = this.dataRange;\n    let start = from;\n    let end = to;\n    if (start instanceof Date) {\n      start = dateRange.dateIndex(start);\n    }\n    if (end instanceof Date) {\n      end = dateRange.dateIndex(end);\n    }\n    const slot = this.getSlot(start, end, limit);\n    if (slot) {\n      return slot.toRect();\n    }\n  }\n  getSlot(a, b, limit) {\n    let start = a;\n    let end = b;\n    if (typeof start === OBJECT) {\n      start = this.categoryIndex(start);\n    }\n    if (typeof end === OBJECT) {\n      end = this.categoryIndex(end);\n    }\n    return super.getSlot(start, end, limit);\n  }\n  valueRange() {\n    const options = this.options;\n    const range = categoryRange(options.srcCategories);\n    return {\n      min: toDate(range.min),\n      max: toDate(range.max)\n    };\n  }\n  categoryAt(index, total) {\n    return this.dataRange.dateAt(index, total);\n  }\n  categoriesCount() {\n    return this.dataRange.valuesCount();\n  }\n  rangeIndices() {\n    return this.dataRange.displayIndices();\n  }\n  labelsBetweenTicks() {\n    return !this.divisionRange.options.justified;\n  }\n  prepareUserOptions() {\n    if (this.isEmpty()) {\n      return;\n    }\n    this.options.categories = this.dataRange.values();\n  }\n  getCategory(point) {\n    const index = this.pointCategoryIndex(point);\n    if (index === null) {\n      return null;\n    }\n    return this.dataRange.dateAt(index);\n  }\n  totalIndex(value) {\n    return this.dataRange.totalIndex(value);\n  }\n  currentRangeIndices() {\n    const range = this.dataRange.valueRange();\n    return {\n      min: this.dataRange.totalIndex(range.min),\n      max: this.dataRange.totalIndex(range.max)\n    };\n  }\n  totalRange() {\n    return this.dataRange.total();\n  }\n  totalRangeIndices() {\n    const range = this.dataRange.total();\n    return {\n      min: this.dataRange.totalIndex(range.min),\n      max: this.dataRange.totalIndex(range.max)\n    };\n  }\n  totalCount() {\n    return this.dataRange.totalCount();\n  }\n  isEmpty() {\n    return !this.options.srcCategories.length;\n  }\n  roundedRange() {\n    if (this.options.roundToBaseUnit !== false || this.isEmpty()) {\n      return this.range();\n    }\n    const options = this.options;\n    const datesRange = categoryRange(options.srcCategories);\n    const dateRange = new DateRange(datesRange.min, datesRange.max, Object.assign({}, options, {\n      justified: false,\n      roundToBaseUnit: true,\n      justifyEnd: false\n    }));\n    return dateRange.displayRange();\n  }\n}\nsetDefaultOptions(DateCategoryAxis, {\n  type: DATE,\n  labels: {\n    dateFormats: DateLabelFormats\n  },\n  rangeLabels: {\n    visible: false\n  },\n  autoBaseUnitSteps: {\n    milliseconds: [1, 10, 100],\n    seconds: [1, 2, 5, 15, 30],\n    minutes: [1, 2, 5, 15, 30],\n    hours: [1, 2, 3],\n    days: [1, 2, 3],\n    weeks: [1, 2],\n    months: [1, 2, 3, 6],\n    years: [1, 2, 3, 5, 10, 25, 50]\n  },\n  maxDateGroups: 10\n});\nexport default DateCategoryAxis;","map":{"version":3,"names":["CategoryAxis","AxisLabel","Box","CENTER","DATE","DEFAULT_PRECISION","MAX_VALUE","OBJECT","X","Y","deepExtend","defined","inArray","last","limitValue","round","setDefaultOptions","sparseArrayLimits","MILLISECONDS","SECONDS","MINUTES","HOURS","DAYS","WEEKS","MONTHS","YEARS","TIME_PER_MINUTE","TIME_PER_HOUR","TIME_PER_DAY","TIME_PER_WEEK","TIME_PER_MONTH","TIME_PER_YEAR","TIME_PER_UNIT","dateComparer","toDate","addTicks","addDuration","dateDiff","absoluteDateDiff","dateIndex","dateEquals","toTime","parseDate","parseDates","firstDay","DateLabelFormats","AUTO","BASE_UNITS","FIT","categoryRange","categories","clearCache","_range","undefined","range","min","max","EmptyDateRange","constructor","options","displayIndices","displayRange","total","valueRange","valueIndex","values","totalIndex","valuesCount","totalCount","dateAt","DateRange","start","end","baseUnitStep","roundToBaseUnit","justified","baseUnit","weekStartDay","lowerEnd","roundToTotalStep","expandEnd","justifyEnd","valueStart","displayStart","valueEnd","displayEnd","next","_indices","minIdx","maxIdx","value","Math","floor","_values","date","push","index","upper","step","roundedStep","ceil","autoBaseUnit","startUnit","startStep","categoryLimits","span","autoBaseUnitSteps","maxDateGroups","autoUnit","autoUnitIx","indexOf","units","totalUnits","unitSteps","nextStep","slice","shift","defaultBaseUnit","count","length","minDiff","lastCategory","unit","categoryIx","category","diff","initUnit","toLowerCase","useDefault","DateCategoryAxis","clone","copy","Object","assign","chartService","createLabels","categoriesHash","dataRange","initUserOptions","initFields","intlService","intl","_parsed","panning","isPannable","vertical","userSetBaseUnit","userSetBaseUnitStep","srcCategories","maxDivisions","safeOptions","forecast","_forecast","before","after","divisionOptions","dataRangeOptions","divisionRange","rangeLabels","tickIndices","stepSize","indices","offset","concat","idx","splice","shouldRenderNote","parseNoteValue","noteSlot","getSlot","translateRange","delta","lineBox","size","height","width","scale","from","to","labelsRange","labels","skip","pan","isEmpty","totalLimits","reverse","panRange","limitRange","pointsRange","datesRange","indicesRange","scaleRange","cursor","fit","rangeMin","rangeMax","position","abs","pointOffset","scaleToDelta","minDelta","maxDelta","Date","getTime","maxDiff","rangeDiff","baseUnitIndex","autoBaseUnitStep","ticks","stepIndex","zoomRange","createRangeLabels","clearLabels","arrangeLabels","arrangeRangeLabels","mirror","firstLabel","y1","box","x1","positionLabel","lastLabel","y2","x2","autoRotateLabels","autoRotateRangeLabels","hideOutOfRangeLabels","hideOverlappingLabels","clip","rangeLabel","label","visible","overlaps","firstRangeLabel","i","lastRangeLabel","contentBox","wrap","createAxisLabel","labelOptions","labelContext","dataItem","dataItems","unitFormat","dateFormats","format","text","axisLabelText","align","zIndex","normalizeLabelRotation","alignRotation","rotation","createLabel","append","startText","endText","rotateLabel","tickPositions","angle","autoRotateLabelAngle","reflow","getMajorTickPositions","categoryIndex","slot","limit","dateRange","toRect","a","b","categoryAt","categoriesCount","rangeIndices","labelsBetweenTicks","prepareUserOptions","getCategory","point","pointCategoryIndex","currentRangeIndices","totalRange","totalRangeIndices","roundedRange","type","milliseconds","seconds","minutes","hours","days","weeks","months","years"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/core/date-category-axis.js"],"sourcesContent":["import CategoryAxis from './category-axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\n\nimport { CENTER, DATE, DEFAULT_PRECISION, MAX_VALUE, OBJECT, X, Y } from '../common/constants';\nimport { deepExtend, defined, inArray, last, limitValue, round, setDefaultOptions, sparseArrayLimits } from '../common';\n\nimport { MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS,\n    TIME_PER_MINUTE, TIME_PER_HOUR, TIME_PER_DAY, TIME_PER_WEEK,\n    TIME_PER_MONTH, TIME_PER_YEAR, TIME_PER_UNIT } from '../date-utils/constants';\nimport { dateComparer, toDate, addTicks, addDuration, dateDiff, absoluteDateDiff,\n    dateIndex, dateEquals, toTime, parseDate, parseDates, firstDay } from '../date-utils';\n\nimport { DateLabelFormats } from './constants';\n\nconst AUTO = \"auto\";\nconst BASE_UNITS = [\n    MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS\n];\nconst FIT = \"fit\";\n\n\nfunction categoryRange(categories, clearCache) {\n    if (clearCache) {\n        categories._range = undefined;\n    }\n\n    let range = categories._range;\n    if (!range) {\n        range = categories._range = sparseArrayLimits(categories);\n        range.min = toDate(range.min);\n        range.max = toDate(range.max);\n    }\n\n    return range;\n}\n\nclass EmptyDateRange {\n    constructor(options) {\n        this.options = options;\n    }\n\n    displayIndices() {\n        return {\n            min: 0,\n            max: 1\n        };\n    }\n\n    displayRange() {\n        return {};\n    }\n\n    total() {\n        return {};\n    }\n\n    valueRange() {\n        return {};\n    }\n\n    valueIndex() {\n        return -1;\n    }\n\n    values() {\n        return [];\n    }\n\n    totalIndex() {\n        return -1;\n    }\n\n    valuesCount() {\n        return 0;\n    }\n\n    totalCount() {\n        return 0;\n    }\n\n    dateAt() {\n        return null;\n    }\n}\n\nclass DateRange {\n    constructor(start, end, options) {\n        this.options = options;\n        options.baseUnitStep = options.baseUnitStep || 1;\n\n        const { roundToBaseUnit, justified } = options;\n\n        this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);\n        const lowerEnd = this.roundToTotalStep(end);\n        const expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;\n\n        this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);\n\n        const min = options.min || start;\n        this.valueStart = this.roundToTotalStep(min);\n        this.displayStart = roundToBaseUnit ? this.valueStart : min;\n\n        const max = options.max;\n        if (!max) {\n            this.valueEnd = lowerEnd;\n            this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;\n        } else {\n            const next = !justified && dateEquals(max, this.roundToTotalStep(max)) ? -1 : 0;\n            this.valueEnd = this.roundToTotalStep(max, false, next);\n            this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max, !justified) : options.max;\n        }\n\n        if (this.valueEnd < this.valueStart) {\n            this.valueEnd = this.valueStart;\n        }\n        if (this.displayEnd <= this.displayStart) {\n            this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);\n        }\n    }\n\n    displayRange() {\n        return {\n            min: this.displayStart,\n            max: this.displayEnd\n        };\n    }\n\n    displayIndices() {\n        if (!this._indices) {\n            const options = this.options;\n\n            const { baseUnit, baseUnitStep } = options;\n\n            const minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);\n            const maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);\n\n            this._indices = { min: minIdx, max: maxIdx };\n        }\n\n        return this._indices;\n    }\n\n    total() {\n        return {\n            min: this.start,\n            max: this.end\n        };\n    }\n\n    totalCount() {\n        const last = this.totalIndex(this.end);\n\n        return last + (this.options.justified ? 1 : 0);\n    }\n\n    valueRange() {\n        return {\n            min: this.valueStart,\n            max: this.valueEnd\n        };\n    }\n\n    valueIndex(value) {\n        const options = this.options;\n        return Math.floor(dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep));\n    }\n\n    totalIndex(value) {\n        const options = this.options;\n        return Math.floor(dateIndex(value, this.start, options.baseUnit, options.baseUnitStep));\n    }\n\n    dateIndex(value) {\n        const options = this.options;\n        return dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep);\n    }\n\n    valuesCount() {\n        const maxIdx = this.valueIndex(this.valueEnd);\n\n        return maxIdx + 1;\n    }\n\n    values() {\n        let values = this._values;\n        if (!values) {\n            const options = this.options;\n            const range = this.valueRange();\n            this._values = values = [];\n\n            for (let date = range.min; date <= range.max;) {\n                values.push(date);\n                date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);\n            }\n        }\n\n        return values;\n    }\n\n    dateAt(index, total) {\n        const options = this.options;\n\n        return addDuration(total ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);\n    }\n\n    roundToTotalStep(value, upper, next) {\n        const { baseUnit, baseUnitStep, weekStartDay } = this.options;\n        const start = this.start;\n\n        const step = dateIndex(value, start, baseUnit, baseUnitStep);\n        let roundedStep = upper ? Math.ceil(step) : Math.floor(step);\n\n        if (next) {\n            roundedStep += next;\n        }\n\n        return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);\n    }\n\n}\n\nfunction autoBaseUnit(options, startUnit, startStep) {\n    const categoryLimits = categoryRange(options.categories);\n    const span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);\n    const { autoBaseUnitSteps, maxDateGroups } = options;\n    const autoUnit = options.baseUnit === FIT;\n    let autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;\n    let baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;\n    let units = span / TIME_PER_UNIT[baseUnit];\n    let totalUnits = units;\n    let unitSteps, step, nextStep;\n\n    while (!step || units >= maxDateGroups) {\n        unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);\n\n        do {\n            nextStep = unitSteps.shift();\n        } while (nextStep && startUnit === baseUnit && nextStep < startStep);\n\n        if (nextStep) {\n            step = nextStep;\n            units = totalUnits / step;\n        } else if (baseUnit === last(BASE_UNITS)) {\n            step = Math.ceil(totalUnits / maxDateGroups);\n            break;\n        } else if (autoUnit) {\n            baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);\n            totalUnits = span / TIME_PER_UNIT[baseUnit];\n            unitSteps = null;\n        } else {\n            if (units > maxDateGroups) {\n                step = Math.ceil(totalUnits / maxDateGroups);\n            }\n            break;\n        }\n    }\n\n    options.baseUnitStep = step;\n    options.baseUnit = baseUnit;\n}\n\nfunction defaultBaseUnit(options) {\n    const categories = options.categories;\n    const count = defined(categories) ? categories.length : 0;\n    let minDiff = MAX_VALUE;\n    let lastCategory, unit;\n\n    for (let categoryIx = 0; categoryIx < count; categoryIx++) {\n        const category = categories[categoryIx];\n\n        if (category && lastCategory) {\n            const diff = absoluteDateDiff(category, lastCategory);\n            if (diff > 0) {\n                minDiff = Math.min(minDiff, diff);\n\n                if (minDiff >= TIME_PER_YEAR) {\n                    unit = YEARS;\n                } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {\n                    unit = MONTHS;\n                } else if (minDiff >= TIME_PER_WEEK) {\n                    unit = WEEKS;\n                } else if (minDiff >= TIME_PER_DAY) {\n                    unit = DAYS;\n                } else if (minDiff >= TIME_PER_HOUR) {\n                    unit = HOURS;\n                } else if (minDiff >= TIME_PER_MINUTE) {\n                    unit = MINUTES;\n                } else {\n                    unit = SECONDS;\n                }\n            }\n        }\n\n        lastCategory = category;\n    }\n\n    options.baseUnit = unit || DAYS;\n}\n\nfunction initUnit(options) {\n    const baseUnit = (options.baseUnit || \"\").toLowerCase();\n    const useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);\n\n    if (useDefault) {\n        defaultBaseUnit(options);\n    }\n\n    if (baseUnit === FIT || options.baseUnitStep === AUTO) {\n        autoBaseUnit(options);\n    }\n\n    return options;\n}\n\nclass DateCategoryAxis extends CategoryAxis {\n\n    clone() {\n        const copy = new DateCategoryAxis(Object.assign({}, this.options), this.chartService);\n        copy.createLabels();\n\n        return copy;\n    }\n\n    categoriesHash() {\n        const start = this.dataRange.total().min;\n        return this.options.baseUnit + this.options.baseUnitStep + start;\n    }\n\n    initUserOptions(options) {\n        return options;\n    }\n\n    initFields() {\n        super.initFields();\n\n        const chartService = this.chartService;\n        const intlService = chartService.intl;\n        let options = this.options;\n\n        let categories = options.categories || [];\n        if (!categories._parsed) {\n            categories = parseDates(intlService, categories);\n            categories._parsed = true;\n        }\n\n        options = deepExtend({\n            roundToBaseUnit: true\n        }, options, {\n            categories: categories,\n            min: parseDate(intlService, options.min),\n            max: parseDate(intlService, options.max),\n            weekStartDay: firstDay(options, intlService)\n        });\n\n        if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {\n            options.roundToBaseUnit = false;\n        }\n\n        options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;\n        options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;\n\n        this.options = options;\n        options.srcCategories = categories;\n\n        if (categories.length > 0) {\n            const range = categoryRange(categories, true);\n            const maxDivisions = options.maxDivisions;\n            const safeOptions = initUnit(options);\n\n            const forecast = options._forecast;\n            if (forecast) {\n                if (forecast.before > 0) {\n                    range.min = addDuration(range.min, -forecast.before, safeOptions.baseUnit, safeOptions.weekStartDay);\n                }\n\n                if (forecast.after > 0) {\n                    range.max = addDuration(range.max, forecast.after, safeOptions.baseUnit, safeOptions.weekStartDay);\n                }\n            }\n\n            this.dataRange = new DateRange(range.min, range.max, safeOptions);\n\n            if (maxDivisions) {\n                const dataRange = this.dataRange.displayRange();\n\n                const divisionOptions = Object.assign({}, options, {\n                    justified: true,\n                    roundToBaseUnit: false,\n                    baseUnit: 'fit',\n                    min: dataRange.min,\n                    max: dataRange.max,\n                    maxDateGroups: maxDivisions\n                });\n\n                const dataRangeOptions = this.dataRange.options;\n\n                autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);\n\n                this.divisionRange = new DateRange(range.min, range.max, divisionOptions);\n            } else {\n                this.divisionRange = this.dataRange;\n            }\n\n        } else {\n            options.baseUnit = options.baseUnit || DAYS;\n            this.dataRange = this.divisionRange = new EmptyDateRange(options);\n        }\n\n        this.rangeLabels = [];\n    }\n\n    tickIndices(stepSize) {\n        const { dataRange, divisionRange } = this;\n        const valuesCount = divisionRange.valuesCount();\n\n        if (!this.options.maxDivisions || !valuesCount) {\n            return super.tickIndices(stepSize);\n        }\n\n        const indices = [];\n        let values = divisionRange.values();\n        let offset = 0;\n\n        if (!this.options.justified) {\n            values = values.concat(divisionRange.dateAt(valuesCount));\n            offset = 0.5;//align ticks to the center of not justified categories\n        }\n\n        for (let idx = 0; idx < values.length; idx++) {\n            indices.push(dataRange.dateIndex(values[idx]) + offset);\n            if (stepSize !== 1 && idx >= 1) {\n                const last = indices.length - 1;\n                indices.splice(idx, 0, indices[last - 1] + (indices[last] - indices[last - 1]) * stepSize);\n            }\n        }\n\n        return indices;\n    }\n\n    shouldRenderNote(value) {\n        const range = this.range();\n        const categories = this.options.categories || [];\n\n        return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0 && categories.length;\n    }\n\n    parseNoteValue(value) {\n        return parseDate(this.chartService.intl, value);\n    }\n\n    noteSlot(value) {\n        return this.getSlot(value);\n    }\n\n    translateRange(delta) {\n        const options = this.options;\n        const { baseUnit, weekStartDay, vertical } = options;\n        const lineBox = this.lineBox();\n        const size = vertical ? lineBox.height() : lineBox.width();\n        let range = this.range();\n        const scale = size / (range.max - range.min);\n        const offset = round(delta / scale, DEFAULT_PRECISION);\n\n        if (range.min && range.max) {\n            const from = addTicks(options.min || range.min, offset);\n            const to = addTicks(options.max || range.max, offset);\n\n            range = {\n                min: addDuration(from, 0, baseUnit, weekStartDay),\n                max: addDuration(to, 0, baseUnit, weekStartDay)\n            };\n        }\n\n        return range;\n    }\n\n    labelsRange() {\n        return {\n            min: this.options.labels.skip,\n            max: this.divisionRange.valuesCount()\n        };\n    }\n\n    pan(delta) {\n        if (this.isEmpty()) {\n            return null;\n        }\n\n        const options = this.options;\n        const lineBox = this.lineBox();\n        const size = options.vertical ? lineBox.height() : lineBox.width();\n        const { min, max } = this.dataRange.displayRange();\n        const totalLimits = this.dataRange.total();\n        const scale = size / (max - min);\n        const offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);\n        const from = addTicks(min, offset);\n        const to = addTicks(max, offset);\n\n        const panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);\n\n        if (panRange) {\n            panRange.min = toDate(panRange.min);\n            panRange.max = toDate(panRange.max);\n            panRange.baseUnit = options.baseUnit;\n            panRange.baseUnitStep = options.baseUnitStep || 1;\n            panRange.userSetBaseUnit = options.userSetBaseUnit;\n            panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;\n\n            return panRange;\n        }\n    }\n\n    pointsRange(start, end) {\n        if (this.isEmpty()) {\n            return null;\n        }\n\n        const pointsRange = super.pointsRange(start, end);\n        const datesRange = this.dataRange.displayRange();\n        const indicesRange = this.dataRange.displayIndices();\n        const scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);\n        const options = this.options;\n\n        const min = addTicks(datesRange.min, pointsRange.min * scale);\n        const max = addTicks(datesRange.min, pointsRange.max * scale);\n\n        return {\n            min: min,\n            max: max,\n            baseUnit: options.userSetBaseUnit || options.baseUnit,\n            baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n        };\n    }\n\n    scaleRange(scale, cursor) {\n        if (this.isEmpty()) {\n            return {};\n        }\n\n        const options = this.options;\n        const fit = options.userSetBaseUnit === FIT;\n        const totalLimits = this.dataRange.total();\n        const { min: rangeMin, max: rangeMax } = this.dataRange.displayRange();\n\n        const position = Math.abs(this.pointOffset(cursor));\n        const range = rangeMax - rangeMin;\n        const delta = this.scaleToDelta(scale, range);\n        const minDelta = Math.round(position * delta);\n        const maxDelta = Math.round((1 - position) * delta);\n\n        let { baseUnit } = this.dataRange.options;\n        let min = new Date(rangeMin.getTime() + minDelta);\n        let max = new Date(rangeMax.getTime() - maxDelta);\n\n        if (fit) {\n            const { autoBaseUnitSteps, maxDateGroups } = options;\n\n            const maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];\n            const rangeDiff = dateDiff(rangeMax, rangeMin);\n            const diff = dateDiff(max, min);\n            let baseUnitIndex = BASE_UNITS.indexOf(baseUnit);\n            let autoBaseUnitStep, ticks;\n\n            if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {\n                baseUnit = BASE_UNITS[baseUnitIndex - 1];\n                autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);\n                ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;\n                min = addTicks(rangeMin, ticks);\n                max = addTicks(rangeMax, -ticks);\n\n            } else if (diff > maxDiff && baseUnit !== YEARS) {\n                let stepIndex = 0;\n\n                do {\n                    baseUnitIndex++;\n                    baseUnit = BASE_UNITS[baseUnitIndex];\n                    stepIndex = 0;\n                    ticks = 2 * TIME_PER_UNIT[baseUnit];\n                    do {\n                        autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];\n                        stepIndex++;\n                    } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);\n                } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);\n\n                ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;\n                if (ticks > 0) {\n                    min = addTicks(rangeMin, -ticks);\n                    max = addTicks(rangeMax, ticks);\n                    min = addTicks(min, limitValue(max, totalLimits.min, totalLimits.max) - max);\n                    max = addTicks(max, limitValue(min, totalLimits.min, totalLimits.max) - min);\n                }\n            }\n        }\n\n        if (min && max && dateDiff(max, min) > 0) {\n            return {\n                min: min,\n                max: max,\n                baseUnit: options.userSetBaseUnit || options.baseUnit,\n                baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n            };\n        }\n    }\n\n    zoomRange(scale, cursor) {\n        const totalLimits = this.dataRange.total();\n        const range = this.scaleRange(scale, cursor);\n\n        if (range) {\n            if (range.min < totalLimits.min) {\n                range.min = totalLimits.min;\n            }\n            if (range.max > totalLimits.max) {\n                range.max = totalLimits.max;\n            }\n        }\n\n        return range;\n    }\n\n    range() {\n        return this.dataRange.displayRange();\n    }\n\n    createLabels() {\n        super.createLabels();\n        this.createRangeLabels();\n    }\n\n    clearLabels() {\n        super.clearLabels();\n        this.rangeLabels = [];\n    }\n\n    arrangeLabels() {\n        this.arrangeRangeLabels();\n        super.arrangeLabels();\n    }\n\n    arrangeRangeLabels() {\n        const { options, rangeLabels } = this;\n        if (rangeLabels.length === 0) {\n            return;\n        }\n\n        const lineBox = this.lineBox();\n        const vertical = options.vertical;\n        const mirror = options.rangeLabels.mirror || options.labels.mirror;\n\n        const firstLabel = rangeLabels[0];\n        if (firstLabel) {\n            const position = vertical ? lineBox.y1 - (firstLabel.box.height() / 2) : lineBox.x1;\n            this.positionLabel(firstLabel, mirror, position);\n        }\n\n        const lastLabel = rangeLabels[1];\n        if (lastLabel) {\n            const position = vertical ? lineBox.y2 - (lastLabel.box.height() / 2) : lineBox.x2;\n            this.positionLabel(lastLabel, mirror, position);\n        }\n    }\n\n    autoRotateLabels() {\n        super.autoRotateLabels();\n        this.autoRotateRangeLabels();\n    }\n\n    hideOutOfRangeLabels() {\n        super.hideOutOfRangeLabels();\n        this.hideOverlappingLabels();\n    }\n\n    hideOverlappingLabels() {\n        const { rangeLabels, labels } = this;\n        if (rangeLabels.length === 0) {\n            return;\n        }\n\n        function clip(rangeLabel, label) {\n            if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {\n                label.options.visible = false;\n                return true;\n            }\n\n            return false;\n        }\n\n        const firstRangeLabel = rangeLabels[0];\n        if (firstRangeLabel && firstRangeLabel.options.visible) {\n            for (let i = 0; i < labels.length; i++) {\n                const overlaps = clip(firstRangeLabel, labels[i]);\n                if (!overlaps) {\n                    break;\n                }\n            }\n        }\n\n        const lastRangeLabel = rangeLabels[1];\n        if (lastRangeLabel && lastRangeLabel.options.visible) {\n            for (let i = labels.length - 1; i > 0; --i) {\n                const overlaps = clip(lastRangeLabel, labels[i]);\n                if (!overlaps) {\n                    break;\n                }\n            }\n        }\n    }\n\n    contentBox() {\n        const box = super.contentBox();\n        const rangeLabels = this.rangeLabels;\n\n        for (let i = 0; i < rangeLabels.length; i++) {\n            const label = rangeLabels[i];\n            if (label.options.visible) {\n                box.wrap(label.box);\n            }\n        }\n\n        return box;\n    }\n\n    createAxisLabel(index, labelOptions, labelContext = {}) {\n        const options = this.options;\n        const dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;\n        const date = this.divisionRange.dateAt(index);\n        const unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n\n        labelOptions.format = labelOptions.format || unitFormat;\n        labelContext.dataItem = dataItem;\n\n        const text = this.axisLabelText(date, labelOptions, labelContext);\n        if (text) {\n            return new AxisLabel(date, text, index, dataItem, labelOptions);\n        }\n    }\n\n    createRangeLabels() {\n        const { displayStart, displayEnd } = this.divisionRange;\n        const options = this.options;\n        const labelOptions = Object.assign({}, options.labels, options.rangeLabels, {\n            align: CENTER,\n            zIndex: options.zIndex\n        });\n\n        if (labelOptions.visible !== true) {\n            return;\n        }\n\n        this.normalizeLabelRotation(labelOptions);\n        labelOptions.alignRotation = CENTER;\n\n        if (labelOptions.rotation === \"auto\") {\n            labelOptions.rotation = 0;\n            options.autoRotateRangeLabels = true;\n        }\n\n        const unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n        labelOptions.format = labelOptions.format || unitFormat;\n\n        const createLabel = (index, date, text) => {\n            if (text) {\n                const label = new AxisLabel(date, text, index, null, labelOptions);\n                this.append(label);\n                this.rangeLabels.push(label);\n            }\n        };\n\n        const startText = this.axisLabelText(displayStart, labelOptions, { index: 0, count: 2 });\n        createLabel(0, displayStart, startText);\n\n        const endText = this.axisLabelText(displayEnd, labelOptions, { index: 1, count: 2 });\n        createLabel(1, displayEnd, endText);\n    }\n\n    autoRotateRangeLabels() {\n        const labels = this.rangeLabels;\n        if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {\n            return;\n        }\n\n        const rotateLabel = (label, tickPositions, index) => {\n            const width = Math.abs(tickPositions[index + 1] - tickPositions[index]) * 2;\n            const angle = this.autoRotateLabelAngle(label.box, width);\n            if (angle !== 0) {\n                label.options.rotation = angle;\n                label.reflow(new Box());\n            }\n        };\n\n        const tickPositions = this.getMajorTickPositions();\n        rotateLabel(labels[0], tickPositions, 0);\n        rotateLabel(labels[1], tickPositions, tickPositions.length - 2);\n    }\n\n    categoryIndex(value) {\n        return this.dataRange.valueIndex(value);\n    }\n\n    slot(from, to, limit) {\n        const dateRange = this.dataRange;\n        let start = from;\n        let end = to;\n\n        if (start instanceof Date) {\n            start = dateRange.dateIndex(start);\n        }\n\n        if (end instanceof Date) {\n            end = dateRange.dateIndex(end);\n        }\n\n        const slot = this.getSlot(start, end, limit);\n        if (slot) {\n            return slot.toRect();\n        }\n    }\n\n    getSlot(a, b, limit) {\n        let start = a;\n        let end = b;\n\n        if (typeof start === OBJECT) {\n            start = this.categoryIndex(start);\n        }\n\n        if (typeof end === OBJECT) {\n            end = this.categoryIndex(end);\n        }\n\n        return super.getSlot(start, end, limit);\n    }\n\n    valueRange() {\n        const options = this.options;\n        const range = categoryRange(options.srcCategories);\n\n        return {\n            min: toDate(range.min),\n            max: toDate(range.max)\n        };\n    }\n\n    categoryAt(index, total) {\n        return this.dataRange.dateAt(index, total);\n    }\n\n    categoriesCount() {\n        return this.dataRange.valuesCount();\n    }\n\n    rangeIndices() {\n        return this.dataRange.displayIndices();\n    }\n\n    labelsBetweenTicks() {\n        return !this.divisionRange.options.justified;\n    }\n\n    prepareUserOptions() {\n        if (this.isEmpty()) {\n            return;\n        }\n\n        this.options.categories = this.dataRange.values();\n    }\n\n    getCategory(point) {\n        const index = this.pointCategoryIndex(point);\n\n        if (index === null) {\n            return null;\n        }\n\n        return this.dataRange.dateAt(index);\n    }\n\n    totalIndex(value) {\n        return this.dataRange.totalIndex(value);\n    }\n\n    currentRangeIndices() {\n        const range = this.dataRange.valueRange();\n        return {\n            min: this.dataRange.totalIndex(range.min),\n            max: this.dataRange.totalIndex(range.max)\n        };\n    }\n\n    totalRange() {\n        return this.dataRange.total();\n    }\n\n    totalRangeIndices() {\n        const range = this.dataRange.total();\n        return {\n            min: this.dataRange.totalIndex(range.min),\n            max: this.dataRange.totalIndex(range.max)\n        };\n    }\n\n    totalCount() {\n        return this.dataRange.totalCount();\n    }\n\n    isEmpty() {\n        return !this.options.srcCategories.length;\n    }\n\n    roundedRange() {\n        if (this.options.roundToBaseUnit !== false || this.isEmpty()) {\n            return this.range();\n        }\n\n        const options = this.options;\n        const datesRange = categoryRange(options.srcCategories);\n\n        const dateRange = new DateRange(datesRange.min, datesRange.max, Object.assign({}, options, {\n            justified: false,\n            roundToBaseUnit: true,\n            justifyEnd: false\n        }));\n\n        return dateRange.displayRange();\n    }\n}\n\nsetDefaultOptions(DateCategoryAxis, {\n    type: DATE,\n    labels: {\n        dateFormats: DateLabelFormats\n    },\n    rangeLabels: {\n        visible: false\n    },\n    autoBaseUnitSteps: {\n        milliseconds: [ 1, 10, 100 ],\n        seconds: [ 1, 2, 5, 15, 30 ],\n        minutes: [ 1, 2, 5, 15, 30 ],\n        hours: [ 1, 2, 3 ],\n        days: [ 1, 2, 3 ],\n        weeks: [ 1, 2 ],\n        months: [ 1, 2, 3, 6 ],\n        years: [ 1, 2, 3, 5, 10, 25, 50 ]\n    },\n    maxDateGroups: 10\n});\n\nexport default DateCategoryAxis;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}