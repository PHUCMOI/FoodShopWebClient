{"ast":null,"code":"import LineChart from '../line-chart/line-chart';\nimport LinePoint from '../line-chart/line-point';\nimport AreaSegment from './area-segment';\nimport StepAreaSegment from './step-area-segment';\nimport SplineAreaSegment from './spline-area-segment';\nimport { STEP, SMOOTH, ZERO } from '../constants';\nclass AreaChart extends LineChart {\n  createSegment(linePoints, currentSeries, seriesIx, prevSegment) {\n    const isStacked = this.options.isStacked;\n    const style = (currentSeries.line || {}).style;\n    let previousSegment;\n    let stackPoints;\n    if (isStacked && seriesIx > 0 && prevSegment) {\n      const missingValues = this.seriesMissingValues(currentSeries);\n      if (missingValues !== \"gap\") {\n        stackPoints = prevSegment.linePoints;\n        previousSegment = prevSegment;\n      } else {\n        stackPoints = this._gapStackPoints(linePoints, seriesIx, style);\n      }\n    }\n    let pointType;\n    if (style === STEP) {\n      pointType = StepAreaSegment;\n    } else if (style === SMOOTH) {\n      pointType = SplineAreaSegment;\n    } else {\n      pointType = AreaSegment;\n    }\n    return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n  }\n  reflow(targetBox) {\n    super.reflow(targetBox);\n    const stackPoints = this._stackPoints;\n    if (stackPoints) {\n      for (let idx = 0; idx < stackPoints.length; idx++) {\n        const stackPoint = stackPoints[idx];\n        const pointSlot = this.categoryAxis.getSlot(stackPoint.categoryIx);\n        stackPoint.reflow(pointSlot);\n      }\n    }\n  }\n  _gapStackPoints(linePoints, seriesIx, style) {\n    const seriesPoints = this.seriesPoints;\n    let startIdx = linePoints[0].categoryIx;\n    let length = linePoints.length;\n    if (startIdx < 0) {\n      startIdx = 0;\n      length--;\n    }\n    const endIdx = startIdx + length;\n    const pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;\n    const stackPoints = [];\n    this._stackPoints = this._stackPoints || [];\n    for (let categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {\n      const pointIx = categoryIx + pointOffset;\n      let currentSeriesIx = seriesIx;\n      let point;\n      do {\n        currentSeriesIx--;\n        point = seriesPoints[currentSeriesIx][pointIx];\n      } while (currentSeriesIx > 0 && !point);\n      if (point) {\n        if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {\n          stackPoints.push(this._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));\n        }\n        stackPoints.push(point);\n        if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {\n          stackPoints.push(this._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));\n        }\n      } else {\n        const gapStackPoint = this._createGapStackPoint(categoryIx);\n        this._stackPoints.push(gapStackPoint);\n        stackPoints.push(gapStackPoint);\n      }\n    }\n    return stackPoints;\n  }\n  _previousSegmentPoint(categoryIx, pointIx, segmentIx, seriesIdx) {\n    const seriesPoints = this.seriesPoints;\n    let index = seriesIdx;\n    let point;\n    while (index > 0 && !point) {\n      index--;\n      point = seriesPoints[index][segmentIx];\n    }\n    if (!point) {\n      point = this._createGapStackPoint(categoryIx);\n      this._stackPoints.push(point);\n    } else {\n      point = seriesPoints[index][pointIx];\n    }\n    return point;\n  }\n  _createGapStackPoint(categoryIx) {\n    const options = this.pointOptions({}, 0);\n    const point = new LinePoint(0, options);\n    point.categoryIx = categoryIx;\n    point.series = {};\n    return point;\n  }\n  seriesMissingValues(series) {\n    return series.missingValues || ZERO;\n  }\n  supportsPointInactiveOpacity() {\n    return false;\n  }\n}\nexport default AreaChart;","map":{"version":3,"names":["LineChart","LinePoint","AreaSegment","StepAreaSegment","SplineAreaSegment","STEP","SMOOTH","ZERO","AreaChart","createSegment","linePoints","currentSeries","seriesIx","prevSegment","isStacked","options","style","line","previousSegment","stackPoints","missingValues","seriesMissingValues","_gapStackPoints","pointType","reflow","targetBox","_stackPoints","idx","length","stackPoint","pointSlot","categoryAxis","getSlot","categoryIx","seriesPoints","startIdx","endIdx","pointOffset","seriesOptions","_outOfRangeMinPoint","pointIx","currentSeriesIx","point","push","_previousSegmentPoint","gapStackPoint","_createGapStackPoint","segmentIx","seriesIdx","index","pointOptions","series","supportsPointInactiveOpacity"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/area-chart/area-chart.js"],"sourcesContent":["import LineChart from '../line-chart/line-chart';\nimport LinePoint from '../line-chart/line-point';\n\nimport AreaSegment from './area-segment';\nimport StepAreaSegment from './step-area-segment';\nimport SplineAreaSegment from './spline-area-segment';\n\nimport { STEP, SMOOTH, ZERO } from '../constants';\n\nclass AreaChart extends LineChart {\n    createSegment(linePoints, currentSeries, seriesIx, prevSegment) {\n        const isStacked = this.options.isStacked;\n        const style = (currentSeries.line || {}).style;\n        let previousSegment;\n\n        let stackPoints;\n        if (isStacked && seriesIx > 0 && prevSegment) {\n            const missingValues = this.seriesMissingValues(currentSeries);\n            if (missingValues !== \"gap\") {\n                stackPoints = prevSegment.linePoints;\n                previousSegment = prevSegment;\n            } else {\n                stackPoints = this._gapStackPoints(linePoints, seriesIx, style);\n            }\n        }\n\n        let pointType;\n        if (style === STEP) {\n            pointType = StepAreaSegment;\n        } else if (style === SMOOTH) {\n            pointType = SplineAreaSegment;\n        } else {\n            pointType = AreaSegment;\n        }\n\n        return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);\n    }\n\n    reflow(targetBox) {\n        super.reflow(targetBox);\n\n        const stackPoints = this._stackPoints;\n        if (stackPoints) {\n            for (let idx = 0; idx < stackPoints.length; idx++) {\n                const stackPoint = stackPoints[idx];\n                const pointSlot = this.categoryAxis.getSlot(stackPoint.categoryIx);\n                stackPoint.reflow(pointSlot);\n            }\n        }\n    }\n\n    _gapStackPoints(linePoints, seriesIx, style) {\n        const seriesPoints = this.seriesPoints;\n        let startIdx = linePoints[0].categoryIx;\n        let length = linePoints.length;\n        if (startIdx < 0) {\n            startIdx = 0;\n            length--;\n        }\n\n        const endIdx = startIdx + length;\n        const pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;\n        const stackPoints = [];\n\n        this._stackPoints = this._stackPoints || [];\n        for (let categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {\n            const pointIx = categoryIx + pointOffset;\n            let currentSeriesIx = seriesIx;\n            let point;\n\n            do {\n                currentSeriesIx--;\n                point = seriesPoints[currentSeriesIx][pointIx];\n            } while (currentSeriesIx > 0 && !point);\n\n            if (point) {\n                if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {\n                    stackPoints.push(this._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));\n                }\n\n                stackPoints.push(point);\n\n                if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {\n                    stackPoints.push(this._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));\n                }\n            } else {\n                const gapStackPoint = this._createGapStackPoint(categoryIx);\n                this._stackPoints.push(gapStackPoint);\n                stackPoints.push(gapStackPoint);\n            }\n        }\n\n        return stackPoints;\n    }\n\n    _previousSegmentPoint(categoryIx, pointIx, segmentIx, seriesIdx) {\n        const seriesPoints = this.seriesPoints;\n        let index = seriesIdx;\n        let point;\n\n        while (index > 0 && !point) {\n            index--;\n            point = seriesPoints[index][segmentIx];\n        }\n\n        if (!point) {\n            point = this._createGapStackPoint(categoryIx);\n            this._stackPoints.push(point);\n        } else {\n            point = seriesPoints[index][pointIx];\n        }\n\n        return point;\n    }\n\n    _createGapStackPoint(categoryIx) {\n        const options = this.pointOptions({}, 0);\n        const point = new LinePoint(0, options);\n        point.categoryIx = categoryIx;\n        point.series = {};\n\n        return point;\n    }\n\n    seriesMissingValues(series) {\n        return series.missingValues || ZERO;\n    }\n\n    supportsPointInactiveOpacity() {\n        return false;\n    }\n}\n\nexport default AreaChart;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}