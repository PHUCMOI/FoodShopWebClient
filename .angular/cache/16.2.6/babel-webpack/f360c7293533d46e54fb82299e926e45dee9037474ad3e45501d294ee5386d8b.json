{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport { ChartElement } from '../../core';\nimport { defined, isFunction, setDefaultOptions } from '../../common';\nclass LineSegment extends ChartElement {\n  constructor(linePoints, series, seriesIx) {\n    super();\n    this.linePoints = linePoints;\n    this.series = series;\n    this.seriesIx = seriesIx;\n  }\n  points() {\n    return this.toGeometryPoints(this.linePoints);\n  }\n  toGeometryPoints(points) {\n    const result = [];\n    for (let i = 0, length = points.length; i < length; i++) {\n      if (points[i] && points[i].visible !== false) {\n        result.push(points[i]._childBox.toRect().center());\n      }\n    }\n    return result;\n  }\n  createVisual() {\n    const customVisual = this.series.visual;\n    if (customVisual) {\n      this.visual = customVisual({\n        points: this.toGeometryPoints(this.linePoints),\n        series: this.series,\n        sender: this.getSender(),\n        createVisual: () => {\n          this.segmentVisual();\n          return this.visual;\n        }\n      });\n      if (this.visual && !defined(this.visual.options.zIndex)) {\n        this.visual.options.zIndex = this.series.zIndex;\n      }\n    } else {\n      this.segmentVisual();\n    }\n  }\n  segmentVisual() {\n    const {\n      options,\n      series\n    } = this;\n    let {\n      color,\n      _defaults: defaults\n    } = series;\n    if (isFunction(color) && defaults) {\n      color = defaults.color;\n    }\n    const line = draw.Path.fromPoints(this.points(), {\n      stroke: {\n        color: color,\n        width: series.width,\n        opacity: series.opacity,\n        dashType: series.dashType\n      },\n      zIndex: series.zIndex\n    });\n    if (options.closed) {\n      line.close();\n    }\n    this.visual = line;\n  }\n  aliasFor(e, coords) {\n    return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);\n  }\n}\nsetDefaultOptions(LineSegment, {\n  closed: false\n});\nexport default LineSegment;","map":{"version":3,"names":["drawing","draw","ChartElement","defined","isFunction","setDefaultOptions","LineSegment","constructor","linePoints","series","seriesIx","points","toGeometryPoints","result","i","length","visible","push","_childBox","toRect","center","createVisual","customVisual","visual","sender","getSender","segmentVisual","options","zIndex","color","_defaults","defaults","line","Path","fromPoints","stroke","width","opacity","dashType","closed","close","aliasFor","e","coords","parent","getNearestPoint","x","y"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/line-chart/line-segment.js"],"sourcesContent":["import { drawing as draw } from '@progress/kendo-drawing';\n\nimport { ChartElement } from '../../core';\n\nimport { defined, isFunction, setDefaultOptions } from '../../common';\n\nclass LineSegment extends ChartElement {\n    constructor(linePoints, series, seriesIx) {\n        super();\n\n        this.linePoints = linePoints;\n        this.series = series;\n        this.seriesIx = seriesIx;\n    }\n\n    points() {\n        return this.toGeometryPoints(this.linePoints);\n    }\n\n    toGeometryPoints(points) {\n        const result = [];\n        for (let i = 0, length = points.length; i < length; i++) {\n            if (points[i] && points[i].visible !== false) {\n                result.push(points[i]._childBox.toRect().center());\n            }\n        }\n\n        return result;\n    }\n\n    createVisual() {\n        const customVisual = this.series.visual;\n        if (customVisual) {\n            this.visual = customVisual({\n                points: this.toGeometryPoints(this.linePoints),\n                series: this.series,\n                sender: this.getSender(),\n                createVisual: () => {\n                    this.segmentVisual();\n\n                    return this.visual;\n                }\n            });\n            if (this.visual && !defined(this.visual.options.zIndex)) {\n                this.visual.options.zIndex = this.series.zIndex;\n            }\n        } else {\n            this.segmentVisual();\n        }\n    }\n\n    segmentVisual() {\n        const { options, series } = this;\n        let { color, _defaults: defaults } = series;\n\n        if (isFunction(color) && defaults) {\n            color = defaults.color;\n        }\n\n        const line = draw.Path.fromPoints(this.points(), {\n            stroke: {\n                color: color,\n                width: series.width,\n                opacity: series.opacity,\n                dashType: series.dashType\n            },\n            zIndex: series.zIndex\n        });\n\n        if (options.closed) {\n            line.close();\n        }\n\n        this.visual = line;\n    }\n\n    aliasFor(e, coords) {\n        return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);\n    }\n}\n\nsetDefaultOptions(LineSegment, {\n    closed: false\n});\n\nexport default LineSegment;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}