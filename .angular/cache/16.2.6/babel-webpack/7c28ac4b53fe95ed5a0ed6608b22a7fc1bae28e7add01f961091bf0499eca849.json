{"ast":null,"code":"import withAccessors from '../mixins/with-accessors';\nimport Point from './point';\nimport Rect from './rect';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport HasObservers from '../core/has-observers';\nimport { rad } from '../util';\nconst PI_DIV_2 = Math.PI / 2;\nclass Circle extends withAccessors(HasObservers, [\"radius\"]) {\n  constructor(center = new Point(), radius = 0) {\n    super();\n    this.setCenter(center);\n    this.setRadius(radius);\n  }\n  setCenter(value) {\n    this._observerField(\"center\", Point.create(value));\n    this.geometryChange();\n    return this;\n  }\n  getCenter() {\n    return this.center;\n  }\n  equals(other) {\n    return other && other.center.equals(this.center) && other.radius === this.radius;\n  }\n  clone() {\n    return new Circle(this.center.clone(), this.radius);\n  }\n  pointAt(angle) {\n    return this._pointAt(rad(angle));\n  }\n  bbox(matrix) {\n    const extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);\n    let minPoint = Point.maxPoint();\n    let maxPoint = Point.minPoint();\n    for (let i = 0; i < 4; i++) {\n      let currentPointX = this._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);\n      let currentPointY = this._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);\n      let currentPoint = new Point(currentPointX.x, currentPointY.y);\n      minPoint = Point.min(minPoint, currentPoint);\n      maxPoint = Point.max(maxPoint, currentPoint);\n    }\n    return Rect.fromPoints(minPoint, maxPoint);\n  }\n  _pointAt(angle) {\n    const {\n      center,\n      radius\n    } = this;\n    return new Point(center.x + radius * Math.cos(angle), center.y + radius * Math.sin(angle));\n  }\n  containsPoint(point) {\n    const {\n      center,\n      radius\n    } = this;\n    const inCircle = Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius, 2);\n    return inCircle;\n  }\n  _isOnPath(point, width) {\n    const {\n      center,\n      radius\n    } = this;\n    const pointDistance = center.distanceTo(point);\n    return radius - width <= pointDistance && pointDistance <= radius + width;\n  }\n}\nexport default Circle;","map":{"version":3,"names":["withAccessors","Point","Rect","ellipseExtremeAngles","HasObservers","rad","PI_DIV_2","Math","PI","Circle","constructor","center","radius","setCenter","setRadius","value","_observerField","create","geometryChange","getCenter","equals","other","clone","pointAt","angle","_pointAt","bbox","matrix","extremeAngles","minPoint","maxPoint","i","currentPointX","x","transformCopy","currentPointY","y","currentPoint","min","max","fromPoints","cos","sin","containsPoint","point","inCircle","pow","_isOnPath","width","pointDistance","distanceTo"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-drawing/dist/es2015/geometry/circle.js"],"sourcesContent":["import withAccessors from '../mixins/with-accessors';\nimport Point from './point';\nimport Rect from './rect';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport HasObservers from '../core/has-observers';\nimport { rad } from '../util';\n\n\nconst PI_DIV_2 = Math.PI / 2;\n\nclass Circle extends withAccessors(HasObservers, [ \"radius\" ]) {\n    constructor(center = new Point(), radius = 0) {\n        super();\n\n        this.setCenter(center);\n        this.setRadius(radius);\n    }\n\n    setCenter(value) {\n        this._observerField(\"center\", Point.create(value));\n        this.geometryChange();\n        return this;\n    }\n\n    getCenter() {\n        return this.center;\n    }\n\n    equals(other) {\n        return other &&\n               other.center.equals(this.center) &&\n               other.radius === this.radius;\n    }\n\n    clone() {\n        return new Circle(this.center.clone(), this.radius);\n    }\n\n    pointAt(angle) {\n        return this._pointAt(rad(angle));\n    }\n\n    bbox(matrix) {\n        const extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);\n        let minPoint = Point.maxPoint();\n        let maxPoint = Point.minPoint();\n\n        for (let i = 0; i < 4; i++) {\n            let currentPointX = this._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);\n            let currentPointY = this._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);\n            let currentPoint = new Point(currentPointX.x, currentPointY.y);\n\n            minPoint = Point.min(minPoint, currentPoint);\n            maxPoint = Point.max(maxPoint, currentPoint);\n        }\n\n        return Rect.fromPoints(minPoint, maxPoint);\n    }\n\n    _pointAt(angle) {\n        const { center, radius } = this;\n\n        return new Point(\n            center.x + radius * Math.cos(angle),\n            center.y + radius * Math.sin(angle)\n        );\n    }\n\n    containsPoint(point) {\n        const { center, radius } = this;\n        const inCircle = Math.pow(point.x - center.x, 2) +\n            Math.pow(point.y - center.y, 2) <= Math.pow(radius, 2);\n        return inCircle;\n    }\n\n    _isOnPath(point, width) {\n        const { center, radius } = this;\n        const pointDistance = center.distanceTo(point);\n\n        return radius - width <= pointDistance && pointDistance <= radius + width;\n    }\n}\n\nexport default Circle;\n"],"mappings":"AAAA,OAAOA,aAAa,MAAM,0BAA0B;AACpD,OAAOC,KAAK,MAAM,SAAS;AAC3B,OAAOC,IAAI,MAAM,QAAQ;AACzB,OAAOC,oBAAoB,MAAM,+BAA+B;AAChE,OAAOC,YAAY,MAAM,uBAAuB;AAChD,SAASC,GAAG,QAAQ,SAAS;AAG7B,MAAMC,QAAQ,GAAGC,IAAI,CAACC,EAAE,GAAG,CAAC;AAE5B,MAAMC,MAAM,SAAST,aAAa,CAACI,YAAY,EAAE,CAAE,QAAQ,CAAE,CAAC,CAAC;EAC3DM,WAAWA,CAACC,MAAM,GAAG,IAAIV,KAAK,CAAC,CAAC,EAAEW,MAAM,GAAG,CAAC,EAAE;IAC1C,KAAK,CAAC,CAAC;IAEP,IAAI,CAACC,SAAS,CAACF,MAAM,CAAC;IACtB,IAAI,CAACG,SAAS,CAACF,MAAM,CAAC;EAC1B;EAEAC,SAASA,CAACE,KAAK,EAAE;IACb,IAAI,CAACC,cAAc,CAAC,QAAQ,EAAEf,KAAK,CAACgB,MAAM,CAACF,KAAK,CAAC,CAAC;IAClD,IAAI,CAACG,cAAc,CAAC,CAAC;IACrB,OAAO,IAAI;EACf;EAEAC,SAASA,CAAA,EAAG;IACR,OAAO,IAAI,CAACR,MAAM;EACtB;EAEAS,MAAMA,CAACC,KAAK,EAAE;IACV,OAAOA,KAAK,IACLA,KAAK,CAACV,MAAM,CAACS,MAAM,CAAC,IAAI,CAACT,MAAM,CAAC,IAChCU,KAAK,CAACT,MAAM,KAAK,IAAI,CAACA,MAAM;EACvC;EAEAU,KAAKA,CAAA,EAAG;IACJ,OAAO,IAAIb,MAAM,CAAC,IAAI,CAACE,MAAM,CAACW,KAAK,CAAC,CAAC,EAAE,IAAI,CAACV,MAAM,CAAC;EACvD;EAEAW,OAAOA,CAACC,KAAK,EAAE;IACX,OAAO,IAAI,CAACC,QAAQ,CAACpB,GAAG,CAACmB,KAAK,CAAC,CAAC;EACpC;EAEAE,IAAIA,CAACC,MAAM,EAAE;IACT,MAAMC,aAAa,GAAGzB,oBAAoB,CAAC,IAAI,CAACQ,MAAM,EAAE,IAAI,CAACC,MAAM,EAAE,IAAI,CAACA,MAAM,EAAEe,MAAM,CAAC;IACzF,IAAIE,QAAQ,GAAG5B,KAAK,CAAC6B,QAAQ,CAAC,CAAC;IAC/B,IAAIA,QAAQ,GAAG7B,KAAK,CAAC4B,QAAQ,CAAC,CAAC;IAE/B,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC,EAAEA,CAAC,EAAE,EAAE;MACxB,IAAIC,aAAa,GAAG,IAAI,CAACP,QAAQ,CAACG,aAAa,CAACK,CAAC,GAAGF,CAAC,GAAGzB,QAAQ,CAAC,CAAC4B,aAAa,CAACP,MAAM,CAAC;MACvF,IAAIQ,aAAa,GAAG,IAAI,CAACV,QAAQ,CAACG,aAAa,CAACQ,CAAC,GAAGL,CAAC,GAAGzB,QAAQ,CAAC,CAAC4B,aAAa,CAACP,MAAM,CAAC;MACvF,IAAIU,YAAY,GAAG,IAAIpC,KAAK,CAAC+B,aAAa,CAACC,CAAC,EAAEE,aAAa,CAACC,CAAC,CAAC;MAE9DP,QAAQ,GAAG5B,KAAK,CAACqC,GAAG,CAACT,QAAQ,EAAEQ,YAAY,CAAC;MAC5CP,QAAQ,GAAG7B,KAAK,CAACsC,GAAG,CAACT,QAAQ,EAAEO,YAAY,CAAC;IAChD;IAEA,OAAOnC,IAAI,CAACsC,UAAU,CAACX,QAAQ,EAAEC,QAAQ,CAAC;EAC9C;EAEAL,QAAQA,CAACD,KAAK,EAAE;IACZ,MAAM;MAAEb,MAAM;MAAEC;IAAO,CAAC,GAAG,IAAI;IAE/B,OAAO,IAAIX,KAAK,CACZU,MAAM,CAACsB,CAAC,GAAGrB,MAAM,GAAGL,IAAI,CAACkC,GAAG,CAACjB,KAAK,CAAC,EACnCb,MAAM,CAACyB,CAAC,GAAGxB,MAAM,GAAGL,IAAI,CAACmC,GAAG,CAAClB,KAAK,CACtC,CAAC;EACL;EAEAmB,aAAaA,CAACC,KAAK,EAAE;IACjB,MAAM;MAAEjC,MAAM;MAAEC;IAAO,CAAC,GAAG,IAAI;IAC/B,MAAMiC,QAAQ,GAAGtC,IAAI,CAACuC,GAAG,CAACF,KAAK,CAACX,CAAC,GAAGtB,MAAM,CAACsB,CAAC,EAAE,CAAC,CAAC,GAC5C1B,IAAI,CAACuC,GAAG,CAACF,KAAK,CAACR,CAAC,GAAGzB,MAAM,CAACyB,CAAC,EAAE,CAAC,CAAC,IAAI7B,IAAI,CAACuC,GAAG,CAAClC,MAAM,EAAE,CAAC,CAAC;IAC1D,OAAOiC,QAAQ;EACnB;EAEAE,SAASA,CAACH,KAAK,EAAEI,KAAK,EAAE;IACpB,MAAM;MAAErC,MAAM;MAAEC;IAAO,CAAC,GAAG,IAAI;IAC/B,MAAMqC,aAAa,GAAGtC,MAAM,CAACuC,UAAU,CAACN,KAAK,CAAC;IAE9C,OAAOhC,MAAM,GAAGoC,KAAK,IAAIC,aAAa,IAAIA,aAAa,IAAIrC,MAAM,GAAGoC,KAAK;EAC7E;AACJ;AAEA,eAAevC,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}