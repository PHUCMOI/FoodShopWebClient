{"ast":null,"code":"import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { setDefaultOptions, deepExtend, defined, round, getSpacing } from '../../common';\nimport { BLACK, COORD_PRECISION } from '../../common/constants';\nimport { autoMajorUnit, Box, NumericAxis } from '../../core';\nimport { buildLabelElement, getRange } from '../utils';\nimport { DEGREE, DEFAULT_LINE_WIDTH, INSIDE, OUTSIDE } from '../constants';\nconst GEO_ARC_ADJUST_ANGLE = 180;\nconst {\n  Arc,\n  Path,\n  Group\n} = drawing;\nfunction drawTicks(arc, tickAngles, unit, tickOptions) {\n  const ticks = new Group();\n  const center = arc.center;\n  const radius = arc.getRadiusX();\n  if (tickOptions.visible) {\n    for (let i = 0; i < tickAngles.length; i++) {\n      const tickStart = arc.pointAt(tickAngles[i]);\n      const tickEnd = new geo.Point(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);\n      ticks.append(new Path({\n        stroke: {\n          color: tickOptions.color,\n          width: tickOptions.width\n        }\n      }).moveTo(tickStart).lineTo(tickEnd));\n    }\n  }\n  return ticks;\n}\nfunction rangeSegment(from, to, color, opacity) {\n  return {\n    from: from,\n    to: to,\n    color: color,\n    opacity: opacity\n  };\n}\nclass RadialScale extends NumericAxis {\n  constructor(options, service) {\n    super(0, 1, options, service);\n  }\n  initUserOptions(options) {\n    const scaleOptions = deepExtend({}, this.options, options);\n    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);\n    scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;\n    return scaleOptions;\n  }\n  initFields() {}\n  render(center, radius) {\n    const arc = this.renderArc(center, radius);\n    this.bbox = arc.bbox();\n    this.labelElements = this.renderLabels();\n    this.ticks = this.renderTicks();\n    this.ranges = this.renderRanges();\n  }\n  reflow(bbox) {\n    const center = bbox.center();\n    const radius = Math.min(bbox.height(), bbox.width()) / 2;\n    if (defined(this.bbox)) {\n      this.bbox = this.arc.bbox();\n      this.radius(this.arc.getRadiusX());\n      this.repositionRanges();\n      this.renderLabels();\n    } else {\n      return this.render(center, radius);\n    }\n  }\n  slotAngle(value) {\n    const {\n      min,\n      max,\n      reverse,\n      startAngle,\n      endAngle\n    } = this.options;\n    const angle = endAngle - startAngle;\n    let result;\n    if (reverse) {\n      result = endAngle - (value - min) / (max - min) * angle;\n    } else {\n      result = (value - min) / (max - min) * angle + startAngle;\n    }\n    return result + GEO_ARC_ADJUST_ANGLE;\n  }\n  hasRanges() {\n    const ranges = this.options.ranges;\n    return ranges && ranges.length;\n  }\n  ticksSize() {\n    const {\n      majorTicks,\n      minorTicks\n    } = this.options;\n    let size = 0;\n    if (majorTicks.visible) {\n      size = majorTicks.size;\n    }\n    if (minorTicks.visible) {\n      size = Math.max(minorTicks.size, size);\n    }\n    return size;\n  }\n  labelsCount() {\n    let count = super.labelsCount();\n    const options = this.options;\n    const angle = options.endAngle - options.startAngle;\n    if (angle >= 360 && options.max % options.majorUnit === 0) {\n      count -= 1;\n    }\n    return count;\n  }\n  renderLabels() {\n    const options = this.options;\n    const arc = this.arc.clone();\n    let radius = arc.getRadiusX();\n    const tickAngles = this.tickAngles(arc, options.majorUnit);\n    const rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;\n    const labelsGroup = new Group();\n    let rangeDistance = radius * 0.05;\n    if (defined(options.rangeDistance)) {\n      rangeDistance = options.rangeDistance;\n    } else {\n      options.rangeDistance = rangeDistance;\n    }\n    const labelsOptions = options.labels;\n    const isInside = labelsOptions.position === INSIDE;\n    const hasLabelElements = defined(this.labelElements);\n    if (isInside) {\n      radius -= this.ticksSize();\n      if (this.hasRanges() && !hasLabelElements) {\n        radius -= rangeSize + rangeDistance;\n      }\n      arc.setRadiusX(radius).setRadiusY(radius);\n    }\n    const labels = this.labels;\n    const count = labels.length;\n    const padding = getSpacing(labelsOptions.padding);\n    const paddingWidth = (padding.left + padding.right) / 2;\n    const paddingHeight = (padding.top + padding.bottom) / 2;\n    for (let i = 0; i < count; i++) {\n      const label = labels[i];\n      const halfWidth = label.box.width() / 2;\n      const halfHeight = label.box.height() / 2;\n      const angle = tickAngles[i];\n      const labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;\n      const lp = arc.pointAt(angle);\n      const cx = lp.x + Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1);\n      const cy = lp.y + Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1);\n      label.reflow(new Box(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));\n      const labelPos = new geo.Point(label.box.x1, label.box.y1);\n      let labelElement;\n      if (!hasLabelElements) {\n        labelElement = buildLabelElement(label, options.labels);\n        labelsGroup.append(labelElement);\n      } else {\n        labelElement = this.labelElements.children[i];\n        const prevLabelPos = labelElement.bbox().origin;\n        const labelTransform = labelElement.transform() || geo.transform();\n        labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);\n        labelElement.transform(labelTransform);\n      }\n      this.bbox = geo.Rect.union(this.bbox, labelElement.bbox());\n    }\n    return labelsGroup;\n  }\n  repositionRanges() {\n    const ranges = this.ranges.children;\n    if (ranges.length > 0) {\n      const {\n        rangeDistance,\n        rangeSize\n      } = this.options;\n      let rangeRadius = this.getRangeRadius();\n      if (this.options.labels.position === INSIDE) {\n        rangeRadius += rangeSize + rangeDistance;\n      }\n      const newRadius = rangeRadius + rangeSize / 2;\n      for (let i = 0; i < ranges.length; i++) {\n        ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);\n      }\n      this.bbox = geo.Rect.union(this.bbox, this.ranges.bbox());\n    }\n  }\n  renderRanges() {\n    const segments = this.rangeSegments();\n    const segmentsCount = segments.length;\n    const result = new Group();\n    if (segmentsCount) {\n      const {\n        rangeSize,\n        reverse,\n        rangeDistance\n      } = this.options;\n      const rangeRadius = this.getRangeRadius();\n\n      // move the ticks with a range distance and a range size\n      this.radius(this.radius() - rangeSize - rangeDistance);\n      for (let i = 0; i < segmentsCount; i++) {\n        const segment = segments[i];\n        const from = this.slotAngle(segment[reverse ? \"to\" : \"from\"]);\n        const to = this.slotAngle(segment[!reverse ? \"to\" : \"from\"]);\n        if (to - from !== 0) {\n          result.append(this.createRange(from, to, rangeRadius, segment));\n        }\n      }\n    }\n    return result;\n  }\n  createRange(startAngle, endAngle, rangeRadius, options) {\n    const rangeSize = this.options.rangeSize;\n    const rangeGeom = new geo.Arc(this.arc.center, {\n      radiusX: rangeRadius + rangeSize / 2,\n      radiusY: rangeRadius + rangeSize / 2,\n      startAngle: startAngle,\n      endAngle: endAngle\n    });\n    return new Arc(rangeGeom, {\n      stroke: {\n        width: rangeSize,\n        color: options.color,\n        opacity: options.opacity,\n        lineCap: options.lineCap\n      }\n    });\n  }\n  rangeSegments() {\n    const options = this.options;\n    const ranges = options.ranges || [];\n    const count = ranges.length;\n    const segments = [];\n    if (count) {\n      const {\n        min,\n        max,\n        rangePlaceholderColor: defaultColor\n      } = options;\n      segments.push(rangeSegment(min, max, defaultColor));\n      for (let i = 0; i < count; i++) {\n        const range = getRange(ranges[i], min, max);\n        const segmentsCount = segments.length;\n        for (let j = 0; j < segmentsCount; j++) {\n          const segment = segments[j];\n          if (segment.from <= range.from && range.from <= segment.to) {\n            segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));\n            if (segment.from <= range.to && range.to <= segment.to) {\n              segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));\n            }\n            segment.to = range.from;\n            break;\n          }\n        }\n      }\n    }\n    return segments;\n  }\n  getRangeRadius() {\n    const {\n      arc,\n      options\n    } = this;\n    const {\n      rangeSize,\n      rangeDistance,\n      majorTicks: {\n        size: majorTickSize\n      }\n    } = options;\n    let radius;\n    if (options.labels.position === OUTSIDE) {\n      radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;\n    } else {\n      radius = arc.getRadiusX() - rangeSize;\n    }\n    return radius;\n  }\n  renderArc(center, radius) {\n    const options = this.options;\n    const arc = this.arc = new geo.Arc(center, {\n      radiusX: radius,\n      radiusY: radius,\n      startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,\n      endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE\n    });\n    return arc;\n  }\n  renderTicks() {\n    const {\n      arc,\n      options\n    } = this;\n    const tickArc = arc.clone();\n    this.majorTickAngles = this.tickAngles(arc, options.majorUnit);\n    this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);\n    const allTicks = new Group();\n    allTicks.append(this.majorTicks);\n    const majorTickSize = options.majorTicks.size;\n    const minorTickSize = options.minorTicks.size;\n    this._tickDifference = majorTickSize - minorTickSize;\n    if (options.labels.position === OUTSIDE) {\n      const radius = tickArc.getRadiusX();\n      tickArc.setRadiusX(radius - majorTickSize + minorTickSize).setRadiusY(radius - majorTickSize + minorTickSize);\n    }\n    this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));\n    this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);\n    allTicks.append(this.minorTicks);\n    return allTicks;\n  }\n  normalizeTickAngles(angles) {\n    const options = this.options;\n    const skip = options.majorUnit / options.minorUnit;\n    for (let i = angles.length - 1; i >= 0; i--) {\n      if (i % skip === 0) {\n        angles.splice(i, 1);\n      }\n    }\n    return angles;\n  }\n  tickAngles(ring, stepValue) {\n    const options = this.options;\n    const reverse = options.reverse;\n    const range = options.max - options.min;\n    const angle = ring.endAngle - ring.startAngle;\n    let tickCount = range / stepValue;\n    let pos = ring.startAngle;\n    let step = angle / tickCount;\n    if (reverse) {\n      pos += angle;\n      step = -step;\n    }\n    if (angle >= 360 && options.max % stepValue === 0) {\n      tickCount -= 1;\n    }\n    const positions = [];\n    for (let i = 0; i < tickCount; i++) {\n      positions.push(round(pos, COORD_PRECISION));\n      pos += step;\n    }\n    if (round(pos) <= ring.endAngle) {\n      positions.push(pos);\n    }\n    return positions;\n  }\n  radius(value) {\n    if (value) {\n      this.arc.setRadiusX(value).setRadiusY(value);\n      this.repositionTicks(this.majorTicks.children, this.majorTickAngles);\n      this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);\n    } else {\n      return this.arc.getRadiusX();\n    }\n  }\n  repositionTicks(ticks, tickAngles, minor) {\n    const diff = minor ? this._tickDifference || 0 : 0;\n    let tickArc = this.arc;\n    const radius = tickArc.getRadiusX();\n    if (minor && this.options.labels.position === OUTSIDE && diff !== 0) {\n      tickArc = this.arc.clone();\n      tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);\n    }\n    for (let i = 0; i < ticks.length; i++) {\n      const newPoint = tickArc.pointAt(tickAngles[i]);\n      const segments = ticks[i].segments;\n      const xDiff = newPoint.x - segments[0].anchor().x;\n      const yDiff = newPoint.y - segments[0].anchor().y;\n      ticks[i].transform(new geo.transform().translate(xDiff, yDiff));\n    }\n  }\n}\nsetDefaultOptions(RadialScale, {\n  min: 0,\n  max: 100,\n  majorTicks: {\n    size: 15,\n    align: INSIDE,\n    color: BLACK,\n    width: DEFAULT_LINE_WIDTH,\n    visible: true\n  },\n  minorTicks: {\n    size: 10,\n    align: INSIDE,\n    color: BLACK,\n    width: DEFAULT_LINE_WIDTH,\n    visible: true\n  },\n  startAngle: -30,\n  endAngle: 210,\n  labels: {\n    position: INSIDE,\n    padding: 2\n  }\n});\nexport default RadialScale;","map":{"version":3,"names":["geometry","geo","drawing","setDefaultOptions","deepExtend","defined","round","getSpacing","BLACK","COORD_PRECISION","autoMajorUnit","Box","NumericAxis","buildLabelElement","getRange","DEGREE","DEFAULT_LINE_WIDTH","INSIDE","OUTSIDE","GEO_ARC_ADJUST_ANGLE","Arc","Path","Group","drawTicks","arc","tickAngles","unit","tickOptions","ticks","center","radius","getRadiusX","visible","i","length","tickStart","pointAt","tickEnd","Point","x","size","y","rotate","append","stroke","color","width","moveTo","lineTo","rangeSegment","from","to","opacity","RadialScale","constructor","options","service","initUserOptions","scaleOptions","majorUnit","min","max","minorUnit","initFields","render","renderArc","bbox","labelElements","renderLabels","renderTicks","ranges","renderRanges","reflow","Math","height","repositionRanges","slotAngle","value","reverse","startAngle","endAngle","angle","result","hasRanges","ticksSize","majorTicks","minorTicks","labelsCount","count","clone","rangeSize","labelsGroup","rangeDistance","labelsOptions","labels","isInside","position","hasLabelElements","setRadiusX","setRadiusY","padding","paddingWidth","left","right","paddingHeight","top","bottom","label","halfWidth","box","halfHeight","labelAngle","lp","cx","cos","cy","sin","labelPos","x1","y1","labelElement","children","prevLabelPos","origin","labelTransform","transform","translate","Rect","union","rangeRadius","getRangeRadius","newRadius","_geometry","segments","rangeSegments","segmentsCount","segment","createRange","rangeGeom","radiusX","radiusY","lineCap","rangePlaceholderColor","defaultColor","push","range","j","majorTickSize","tickArc","majorTickAngles","allTicks","minorTickSize","_tickDifference","minorTickAngles","normalizeTickAngles","angles","skip","splice","ring","stepValue","tickCount","pos","step","positions","repositionTicks","minor","diff","newPoint","xDiff","anchor","yDiff","align"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/gauges/radial/radial-scale.js"],"sourcesContent":["import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { setDefaultOptions, deepExtend, defined, round, getSpacing } from '../../common';\nimport { BLACK, COORD_PRECISION } from '../../common/constants';\nimport { autoMajorUnit, Box, NumericAxis } from '../../core';\nimport { buildLabelElement, getRange } from '../utils';\n\nimport { DEGREE, DEFAULT_LINE_WIDTH, INSIDE, OUTSIDE } from '../constants';\n\nconst GEO_ARC_ADJUST_ANGLE = 180;\n\nconst { Arc, Path, Group } = drawing;\n\nfunction drawTicks(arc, tickAngles, unit, tickOptions) {\n    const ticks = new Group();\n    const center = arc.center;\n    const radius = arc.getRadiusX();\n\n    if (tickOptions.visible) {\n        for (let i = 0; i < tickAngles.length; i++) {\n            const tickStart = arc.pointAt(tickAngles[i]);\n            const tickEnd = new geo.Point(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);\n\n            ticks.append(new Path({\n                stroke: {\n                    color: tickOptions.color,\n                    width: tickOptions.width\n                }\n            }).moveTo(tickStart).lineTo(tickEnd));\n        }\n    }\n\n    return ticks;\n}\n\nfunction rangeSegment(from, to, color, opacity) {\n    return { from: from, to: to, color: color, opacity: opacity };\n}\n\nclass RadialScale extends NumericAxis {\n    constructor(options, service) {\n        super(0, 1, options, service);\n    }\n\n    initUserOptions(options) {\n        const scaleOptions = deepExtend({}, this.options, options);\n        scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);\n        scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;\n\n        return scaleOptions;\n    }\n\n    initFields() {\n    }\n\n    render(center, radius) {\n        const arc = this.renderArc(center, radius);\n\n        this.bbox = arc.bbox();\n        this.labelElements = this.renderLabels();\n        this.ticks = this.renderTicks();\n        this.ranges = this.renderRanges();\n    }\n\n    reflow(bbox) {\n        const center = bbox.center();\n        const radius = Math.min(bbox.height(), bbox.width()) / 2;\n\n        if (defined(this.bbox)) {\n            this.bbox = this.arc.bbox();\n            this.radius(this.arc.getRadiusX());\n            this.repositionRanges();\n            this.renderLabels();\n        } else {\n            return this.render(center, radius);\n        }\n    }\n\n    slotAngle(value) {\n        const { min, max, reverse, startAngle, endAngle } = this.options;\n        const angle = endAngle - startAngle;\n        let result;\n\n        if (reverse) {\n            result = endAngle - (value - min) / (max - min) * angle;\n        } else {\n            result = ((value - min) / (max - min) * angle) + startAngle;\n        }\n\n        return result + GEO_ARC_ADJUST_ANGLE;\n    }\n\n    hasRanges() {\n        const ranges = this.options.ranges;\n\n        return ranges && ranges.length;\n    }\n\n    ticksSize() {\n        const { majorTicks, minorTicks } = this.options;\n        let size = 0;\n        if (majorTicks.visible) {\n            size = majorTicks.size;\n        }\n\n        if (minorTicks.visible) {\n            size = Math.max(minorTicks.size, size);\n        }\n\n        return size;\n    }\n\n    labelsCount() {\n        let count = super.labelsCount();\n        const options = this.options;\n        const angle = options.endAngle - options.startAngle;\n\n        if (angle >= 360 && (options.max % options.majorUnit === 0)) {\n            count -= 1;\n        }\n\n        return count;\n    }\n\n    renderLabels() {\n        const options = this.options;\n        const arc = this.arc.clone();\n        let radius = arc.getRadiusX();\n        const tickAngles = this.tickAngles(arc, options.majorUnit);\n        const rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;\n        const labelsGroup = new Group();\n\n        let rangeDistance = radius * 0.05;\n        if (defined(options.rangeDistance)) {\n            rangeDistance = options.rangeDistance;\n        } else {\n            options.rangeDistance = rangeDistance;\n        }\n\n        const labelsOptions = options.labels;\n        const isInside = labelsOptions.position === INSIDE;\n        const hasLabelElements = defined(this.labelElements);\n\n        if (isInside) {\n            radius -= this.ticksSize();\n\n            if (this.hasRanges() && !hasLabelElements) {\n                radius -= rangeSize + rangeDistance;\n            }\n            arc.setRadiusX(radius).setRadiusY(radius);\n        }\n\n        const labels = this.labels;\n        const count = labels.length;\n        const padding = getSpacing(labelsOptions.padding);\n        const paddingWidth = (padding.left + padding.right) / 2;\n        const paddingHeight = (padding.top + padding.bottom) / 2;\n\n        for (let i = 0; i < count; i++) {\n            const label = labels[i];\n            const halfWidth = label.box.width() / 2;\n            const halfHeight = label.box.height() / 2;\n            const angle = tickAngles[i];\n            const labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;\n\n            const lp = arc.pointAt(angle);\n            const cx = lp.x + (Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1));\n            const cy = lp.y + (Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1));\n\n            label.reflow(new Box(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));\n            const labelPos = new geo.Point(label.box.x1, label.box.y1);\n\n            let labelElement;\n            if (!hasLabelElements) {\n                labelElement = buildLabelElement(label, options.labels);\n                labelsGroup.append(labelElement);\n            } else {\n                labelElement = this.labelElements.children[i];\n                const prevLabelPos = labelElement.bbox().origin;\n\n                const labelTransform = labelElement.transform() || geo.transform();\n                labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);\n                labelElement.transform(labelTransform);\n            }\n\n            this.bbox = geo.Rect.union(this.bbox, labelElement.bbox());\n        }\n\n        return labelsGroup;\n    }\n\n    repositionRanges() {\n        const ranges = this.ranges.children;\n\n        if (ranges.length > 0) {\n            const { rangeDistance, rangeSize } = this.options;\n            let rangeRadius = this.getRangeRadius();\n\n            if (this.options.labels.position === INSIDE) {\n                rangeRadius += rangeSize + rangeDistance;\n            }\n\n            const newRadius = rangeRadius + (rangeSize / 2);\n\n            for (let i = 0; i < ranges.length; i++) {\n                ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);\n            }\n\n            this.bbox = geo.Rect.union(this.bbox, this.ranges.bbox());\n        }\n    }\n\n    renderRanges() {\n        const segments = this.rangeSegments();\n        const segmentsCount = segments.length;\n        const result = new Group();\n\n        if (segmentsCount) {\n            const { rangeSize, reverse, rangeDistance } = this.options;\n            const rangeRadius = this.getRangeRadius();\n\n            // move the ticks with a range distance and a range size\n            this.radius(this.radius() - rangeSize - rangeDistance);\n\n            for (let i = 0; i < segmentsCount; i++) {\n                const segment = segments[i];\n                const from = this.slotAngle(segment[reverse ? \"to\" : \"from\"]);\n                const to = this.slotAngle(segment[!reverse ? \"to\" : \"from\"]);\n\n                if (to - from !== 0) {\n                    result.append(this.createRange(from, to, rangeRadius, segment));\n                }\n            }\n        }\n\n        return result;\n    }\n\n    createRange(startAngle, endAngle, rangeRadius, options) {\n        const rangeSize = this.options.rangeSize;\n        const rangeGeom = new geo.Arc(this.arc.center, {\n            radiusX: rangeRadius + (rangeSize / 2),\n            radiusY: rangeRadius + (rangeSize / 2),\n            startAngle: startAngle,\n            endAngle: endAngle\n        });\n\n        return new Arc(rangeGeom, {\n            stroke: {\n                width: rangeSize,\n                color: options.color,\n                opacity: options.opacity,\n                lineCap: options.lineCap\n            }\n        });\n    }\n\n    rangeSegments() {\n        const options = this.options;\n        const ranges = options.ranges || [];\n        const count = ranges.length;\n        const segments = [];\n\n        if (count) {\n            const { min, max, rangePlaceholderColor: defaultColor } = options;\n            segments.push(rangeSegment(min, max, defaultColor));\n\n            for (let i = 0; i < count; i++) {\n                const range = getRange(ranges[i], min, max);\n                const segmentsCount = segments.length;\n\n                for (let j = 0; j < segmentsCount; j++) {\n                    const segment = segments[j];\n\n                    if (segment.from <= range.from && range.from <= segment.to) {\n                        segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));\n\n                        if (segment.from <= range.to && range.to <= segment.to) {\n                            segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));\n                        }\n\n                        segment.to = range.from;\n\n                        break;\n                    }\n                }\n            }\n        }\n\n        return segments;\n    }\n\n    getRangeRadius() {\n        const { arc, options } = this;\n        const { rangeSize, rangeDistance, majorTicks: { size: majorTickSize } } = options;\n        let radius;\n\n        if (options.labels.position === OUTSIDE) {\n            radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;\n        } else {\n            radius = arc.getRadiusX() - rangeSize;\n        }\n\n        return radius;\n    }\n\n    renderArc(center, radius) {\n        const options = this.options;\n\n        const arc = this.arc = new geo.Arc(center, {\n            radiusX: radius,\n            radiusY: radius,\n            startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,\n            endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE\n        });\n\n        return arc;\n    }\n\n    renderTicks() {\n        const { arc, options } = this;\n        const tickArc = arc.clone();\n\n        this.majorTickAngles = this.tickAngles(arc, options.majorUnit);\n        this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);\n\n        const allTicks = new Group();\n        allTicks.append(this.majorTicks);\n\n        const majorTickSize = options.majorTicks.size;\n        const minorTickSize = options.minorTicks.size;\n\n        this._tickDifference = majorTickSize - minorTickSize;\n\n        if (options.labels.position === OUTSIDE) {\n            const radius = tickArc.getRadiusX();\n            tickArc.setRadiusX(radius - majorTickSize + minorTickSize)\n                   .setRadiusY(radius - majorTickSize + minorTickSize);\n        }\n\n        this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));\n        this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);\n        allTicks.append(this.minorTicks);\n\n        return allTicks;\n    }\n\n    normalizeTickAngles(angles) {\n        const options = this.options;\n        const skip = options.majorUnit / options.minorUnit;\n\n        for (let i = angles.length - 1; i >= 0; i--) {\n            if (i % skip === 0) {\n                angles.splice(i, 1);\n            }\n        }\n\n        return angles;\n    }\n\n    tickAngles(ring, stepValue) {\n        const options = this.options;\n        const reverse = options.reverse;\n        const range = options.max - options.min;\n        const angle = ring.endAngle - ring.startAngle;\n        let tickCount = range / stepValue;\n        let pos = ring.startAngle;\n        let step = angle / tickCount;\n\n        if (reverse) {\n            pos += angle;\n            step = -step;\n        }\n\n        if (angle >= 360 && (options.max % stepValue === 0)) {\n            tickCount -= 1;\n        }\n\n        const positions = [];\n        for (let i = 0; i < tickCount; i++) {\n            positions.push(round(pos, COORD_PRECISION));\n            pos += step;\n        }\n\n        if (round(pos) <= ring.endAngle) {\n            positions.push(pos);\n        }\n\n        return positions;\n    }\n\n    radius(value) {\n        if (value) {\n            this.arc.setRadiusX(value).setRadiusY(value);\n            this.repositionTicks(this.majorTicks.children, this.majorTickAngles);\n            this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);\n        } else {\n            return this.arc.getRadiusX();\n        }\n    }\n\n    repositionTicks(ticks, tickAngles, minor) {\n        const diff = minor ? (this._tickDifference || 0) : 0;\n        let tickArc = this.arc;\n        const radius = tickArc.getRadiusX();\n\n        if (minor && this.options.labels.position === OUTSIDE && diff !== 0) {\n            tickArc = this.arc.clone();\n            tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);\n        }\n\n        for (let i = 0; i < ticks.length; i++) {\n            const newPoint = tickArc.pointAt(tickAngles[i]);\n            const segments = ticks[i].segments;\n            const xDiff = newPoint.x - segments[0].anchor().x;\n            const yDiff = newPoint.y - segments[0].anchor().y;\n\n            ticks[i].transform(new geo.transform().translate(xDiff, yDiff));\n        }\n    }\n}\n\nsetDefaultOptions(RadialScale, {\n    min: 0,\n    max: 100,\n\n    majorTicks: {\n        size: 15,\n        align: INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    minorTicks: {\n        size: 10,\n        align: INSIDE,\n        color: BLACK,\n        width: DEFAULT_LINE_WIDTH,\n        visible: true\n    },\n\n    startAngle: -30,\n    endAngle: 210,\n\n    labels: {\n        position: INSIDE,\n        padding: 2\n    }\n});\n\nexport default RadialScale;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}