{"ast":null,"code":"import ScatterChart from '../scatter-charts/scatter-chart';\nimport Bubble from './bubble';\nimport { INITIAL_ANIMATION_DURATION, BUBBLE } from '../constants';\nimport { MIN_VALUE, CIRCLE } from '../../common/constants';\nimport { deepExtend, isFunction, setDefaultOptions, valueOrDefault } from '../../common';\nclass BubbleChart extends ScatterChart {\n  _initFields() {\n    this._maxSize = MIN_VALUE;\n    super._initFields();\n  }\n  addValue(value, fields) {\n    if (value.size !== null && (value.size > 0 || value.size < 0 && fields.series.negativeValues.visible)) {\n      this._maxSize = Math.max(this._maxSize, Math.abs(value.size));\n      super.addValue(value, fields);\n    } else {\n      this.points.push(null);\n      this.seriesPoints[fields.seriesIx].push(null);\n    }\n  }\n  reflow(box) {\n    this.updateBubblesSize(box);\n    super.reflow(box);\n  }\n  pointType() {\n    return Bubble;\n  }\n  createPoint(value, fields) {\n    const series = fields.series;\n    const pointsCount = series.data.length;\n    const delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);\n    const animationOptions = {\n      delay: delay,\n      duration: INITIAL_ANIMATION_DURATION - delay,\n      type: BUBBLE\n    };\n    let color = fields.color || series.color;\n    if (value.size < 0 && series.negativeValues.visible) {\n      color = valueOrDefault(series.negativeValues.color, color);\n    }\n    let pointOptions = deepExtend({\n      labels: {\n        animation: {\n          delay: delay,\n          duration: INITIAL_ANIMATION_DURATION - delay\n        }\n      }\n    }, this.pointOptions(series, fields.seriesIx), {\n      markers: {\n        type: CIRCLE,\n        border: series.border,\n        opacity: series.opacity,\n        animation: animationOptions\n      }\n    });\n    pointOptions = this.evalPointOptions(pointOptions, value, fields);\n    if (isFunction(series.color)) {\n      color = pointOptions.color;\n    }\n    pointOptions.markers.background = color;\n    const point = new Bubble(value, pointOptions);\n    point.color = color;\n    this.append(point);\n    return point;\n  }\n  updateBubblesSize(box) {\n    const {\n      options: {\n        series\n      }\n    } = this;\n    const boxSize = Math.min(box.width(), box.height());\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      const seriesPoints = this.seriesPoints[seriesIx];\n      const minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);\n      const maxSize = currentSeries.maxSize || boxSize * 0.2;\n      const minR = minSize / 2;\n      const maxR = maxSize / 2;\n      const minArea = Math.PI * minR * minR;\n      const maxArea = Math.PI * maxR * maxR;\n      const areaRange = maxArea - minArea;\n      const areaRatio = areaRange / this._maxSize;\n      for (let pointIx = 0; pointIx < seriesPoints.length; pointIx++) {\n        const point = seriesPoints[pointIx];\n        if (point) {\n          const area = Math.abs(point.value.size) * areaRatio;\n          const radius = Math.sqrt((minArea + area) / Math.PI);\n          const baseZIndex = valueOrDefault(point.options.zIndex, 0);\n          const zIndex = baseZIndex + (1 - radius / maxR);\n          deepExtend(point.options, {\n            zIndex: zIndex,\n            markers: {\n              size: radius * 2,\n              zIndex: zIndex\n            },\n            labels: {\n              zIndex: zIndex + 1\n            }\n          });\n        }\n      }\n    }\n  }\n  formatPointValue(point, format) {\n    const value = point.value;\n    return this.chartService.format.auto(format, value.x, value.y, value.size, point.category);\n  }\n  createAnimation() {}\n  createVisual() {}\n}\nsetDefaultOptions(BubbleChart, {\n  tooltip: {\n    format: \"{3}\"\n  },\n  labels: {\n    format: \"{3}\"\n  }\n});\nexport default BubbleChart;","map":{"version":3,"names":["ScatterChart","Bubble","INITIAL_ANIMATION_DURATION","BUBBLE","MIN_VALUE","CIRCLE","deepExtend","isFunction","setDefaultOptions","valueOrDefault","BubbleChart","_initFields","_maxSize","addValue","value","fields","size","series","negativeValues","visible","Math","max","abs","points","push","seriesPoints","seriesIx","reflow","box","updateBubblesSize","pointType","createPoint","pointsCount","data","length","delay","pointIx","animationOptions","duration","type","color","pointOptions","labels","animation","markers","border","opacity","evalPointOptions","background","point","append","options","boxSize","min","width","height","currentSeries","minSize","maxSize","minR","maxR","minArea","PI","maxArea","areaRange","areaRatio","area","radius","sqrt","baseZIndex","zIndex","formatPointValue","format","chartService","auto","x","y","category","createAnimation","createVisual","tooltip"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/bubble-chart/bubble-chart.js"],"sourcesContent":["import ScatterChart from '../scatter-charts/scatter-chart';\nimport Bubble from './bubble';\n\nimport { INITIAL_ANIMATION_DURATION, BUBBLE } from '../constants';\n\nimport { MIN_VALUE, CIRCLE } from '../../common/constants';\nimport { deepExtend, isFunction, setDefaultOptions, valueOrDefault } from '../../common';\n\nclass BubbleChart extends ScatterChart {\n    _initFields() {\n        this._maxSize = MIN_VALUE;\n        super._initFields();\n    }\n\n    addValue(value, fields) {\n        if (value.size !== null && (value.size > 0 || (value.size < 0 && fields.series.negativeValues.visible))) {\n            this._maxSize = Math.max(this._maxSize, Math.abs(value.size));\n            super.addValue(value, fields);\n        } else {\n            this.points.push(null);\n            this.seriesPoints[fields.seriesIx].push(null);\n        }\n    }\n\n    reflow(box) {\n        this.updateBubblesSize(box);\n        super.reflow(box);\n    }\n\n    pointType() {\n        return Bubble;\n    }\n\n    createPoint(value, fields) {\n        const series = fields.series;\n        const pointsCount = series.data.length;\n        const delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);\n        const animationOptions = {\n            delay: delay,\n            duration: INITIAL_ANIMATION_DURATION - delay,\n            type: BUBBLE\n        };\n\n        let color = fields.color || series.color;\n        if (value.size < 0 && series.negativeValues.visible) {\n            color = valueOrDefault(\n                series.negativeValues.color, color\n            );\n        }\n\n        let pointOptions = deepExtend({\n            labels: {\n                animation: {\n                    delay: delay,\n                    duration: INITIAL_ANIMATION_DURATION - delay\n                }\n            }\n        }, this.pointOptions(series, fields.seriesIx), {\n            markers: {\n                type: CIRCLE,\n                border: series.border,\n                opacity: series.opacity,\n                animation: animationOptions\n            }\n        });\n\n        pointOptions = this.evalPointOptions(pointOptions, value, fields);\n        if (isFunction(series.color)) {\n            color = pointOptions.color;\n        }\n\n        pointOptions.markers.background = color;\n\n        const point = new Bubble(value, pointOptions);\n        point.color = color;\n\n        this.append(point);\n\n        return point;\n    }\n\n    updateBubblesSize(box) {\n        const { options: { series } } = this;\n        const boxSize = Math.min(box.width(), box.height());\n\n        for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            const currentSeries = series[seriesIx];\n            const seriesPoints = this.seriesPoints[seriesIx];\n            const minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);\n            const maxSize = currentSeries.maxSize || boxSize * 0.2;\n            const minR = minSize / 2;\n            const maxR = maxSize / 2;\n            const minArea = Math.PI * minR * minR;\n            const maxArea = Math.PI * maxR * maxR;\n            const areaRange = maxArea - minArea;\n            const areaRatio = areaRange / this._maxSize;\n\n            for (let pointIx = 0; pointIx < seriesPoints.length; pointIx++) {\n                const point = seriesPoints[pointIx];\n                if (point) {\n                    const area = Math.abs(point.value.size) * areaRatio;\n                    const radius = Math.sqrt((minArea + area) / Math.PI);\n                    const baseZIndex = valueOrDefault(point.options.zIndex, 0);\n                    const zIndex = baseZIndex + (1 - radius / maxR);\n\n                    deepExtend(point.options, {\n                        zIndex: zIndex,\n                        markers: {\n                            size: radius * 2,\n                            zIndex: zIndex\n                        },\n                        labels: {\n                            zIndex: zIndex + 1\n                        }\n                    });\n                }\n            }\n        }\n    }\n\n    formatPointValue(point, format) {\n        const value = point.value;\n        return this.chartService.format.auto(format, value.x, value.y, value.size, point.category);\n    }\n\n    createAnimation() {}\n    createVisual() {}\n}\n\nsetDefaultOptions(BubbleChart, {\n    tooltip: {\n        format: \"{3}\"\n    },\n    labels: {\n        format: \"{3}\"\n    }\n});\n\nexport default BubbleChart;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}