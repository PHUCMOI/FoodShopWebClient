{"ast":null,"code":"import GeometryElementsArray from './geometry-elements-array';\nimport Element from './element';\nimport { pointsToCurve } from './utils/points-to-curve';\nimport paintable from '../mixins/paintable';\nimport measurable from '../mixins/measurable';\nimport Arc from '../geometry/arc';\nimport Rect from '../geometry/rect';\nimport Segment from '../geometry/segment';\nimport Point from '../geometry/point';\nimport Size from '../geometry/size';\nimport lineIntersectionsCount from '../geometry/math/line-intersections-count';\nimport { defined, last, rad } from '../util';\nimport parsePath from '../parsing/parse-path';\nimport elementsBoundingBox from './utils/elements-bounding-box';\nimport elementsClippedBoundingBox from './utils/elements-clippend-bounding-box';\nimport limitValue from '../util/limit-value';\nconst SPACE = ' ';\nconst printPoints = precision => (...points) => points.map(p => p.toString(precision)).join(SPACE);\nconst segmentType = (segmentStart, segmentEnd) => segmentStart.controlOut() && segmentEnd.controlIn() ? 'C' : 'L';\nexport class Path extends paintable(measurable(Element)) {\n  get nodeType() {\n    return 'Path';\n  }\n  constructor(options) {\n    super(options);\n    this.segments = new GeometryElementsArray();\n    this.segments.addObserver(this);\n    if (!defined(this.options.stroke)) {\n      this.stroke('#000');\n      if (!defined(this.options.stroke.lineJoin)) {\n        this.options.set('stroke.lineJoin', 'miter');\n      }\n    }\n  }\n  moveTo(x, y) {\n    this.suspend();\n    this.segments.elements([]);\n    this.resume();\n    this.lineTo(x, y);\n    return this;\n  }\n  lineTo(x, y) {\n    const point = defined(y) ? new Point(x, y) : x;\n    const segment = new Segment(point);\n    this.segments.push(segment);\n    return this;\n  }\n  curveTo(controlOut, controlIn, point) {\n    if (this.segments.length > 0) {\n      const lastSegment = last(this.segments);\n      const segment = new Segment(point, controlIn);\n      this.suspend();\n      lastSegment.controlOut(controlOut);\n      this.resume();\n      this.segments.push(segment);\n    }\n    return this;\n  }\n  arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n    if (this.segments.length > 0) {\n      const lastSegment = last(this.segments);\n      const anchor = lastSegment.anchor();\n      const start = rad(startAngle);\n      const center = new Point(anchor.x - radiusX * Math.cos(start), anchor.y - radiusY * Math.sin(start));\n      const arc = new Arc(center, {\n        startAngle: startAngle,\n        endAngle: endAngle,\n        radiusX: radiusX,\n        radiusY: radiusY,\n        anticlockwise: anticlockwise\n      });\n      this._addArcSegments(arc);\n    }\n    return this;\n  }\n  arcTo(end, rx, ry, largeArc, swipe, rotation) {\n    if (this.segments.length > 0) {\n      const lastSegment = last(this.segments);\n      const anchor = lastSegment.anchor();\n      const arc = Arc.fromPoints(anchor, Point.create(end), rx, ry, largeArc, swipe, rotation);\n      this._addArcSegments(arc);\n    }\n    return this;\n  }\n  _addArcSegments(arc) {\n    this.suspend();\n    const curvePoints = arc.curvePoints();\n    for (let i = 1; i < curvePoints.length; i += 3) {\n      this.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n    }\n    this.resume();\n    this.geometryChange();\n  }\n  close() {\n    this.options.closed = true;\n    this.geometryChange();\n    return this;\n  }\n  rawBBox() {\n    return this._bbox();\n  }\n  toString(digits) {\n    let output = '';\n    const segments = this.segments;\n    const length = segments.length;\n    if (length > 0) {\n      const parts = [];\n      const print = printPoints(digits);\n      let currentType;\n      for (let i = 1; i < length; i++) {\n        let type = segmentType(segments[i - 1], segments[i]);\n        if (type !== currentType) {\n          currentType = type;\n          parts.push(type);\n        }\n        if (type === 'L') {\n          parts.push(print(segments[i].anchor()));\n        } else {\n          parts.push(print(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));\n        }\n      }\n      output = 'M' + print(segments[0].anchor()) + SPACE + parts.join(SPACE);\n      if (this.options.closed) {\n        output += 'Z';\n      }\n    }\n    return output;\n  }\n  _containsPoint(point) {\n    const segments = this.segments;\n    const length = segments.length;\n    let intersectionsCount = 0;\n    let previous, current;\n    for (let idx = 1; idx < length; idx++) {\n      previous = segments[idx - 1];\n      current = segments[idx];\n      intersectionsCount += previous._intersectionsTo(current, point);\n    }\n    if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n      intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\n    }\n    return intersectionsCount % 2 !== 0;\n  }\n  _isOnPath(point, width) {\n    const segments = this.segments;\n    const length = segments.length;\n    const pathWidth = width || this.options.stroke.width;\n    if (length > 1) {\n      if (segments[0]._isOnPathTo(segments[1], point, pathWidth, 'start')) {\n        return true;\n      }\n      for (let idx = 2; idx <= length - 2; idx++) {\n        if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n          return true;\n        }\n      }\n      if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, 'end')) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _bbox(matrix) {\n    const segments = this.segments;\n    const length = segments.length;\n    let boundingBox;\n    if (length === 1) {\n      let anchor = segments[0].anchor().transformCopy(matrix);\n      boundingBox = new Rect(anchor, Size.ZERO);\n    } else if (length > 0) {\n      for (let i = 1; i < length; i++) {\n        let segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n        if (boundingBox) {\n          boundingBox = Rect.union(boundingBox, segmentBox);\n        } else {\n          boundingBox = segmentBox;\n        }\n      }\n    }\n    return boundingBox;\n  }\n  static parse(str, options) {\n    return MultiPath.parse(str, options);\n  }\n  static fromRect(rect, options) {\n    const path = new Path(options);\n    let [rx, ry] = rect.cornerRadius;\n    if (rx === 0 && ry === 0) {\n      path.moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();\n    } else {\n      const origin = rect.origin;\n      const {\n        x,\n        y\n      } = origin;\n      const width = rect.width();\n      const height = rect.height();\n      rx = limitValue(rx, 0, width / 2);\n      ry = limitValue(ry, 0, height / 2);\n      path.moveTo(x + rx, y).lineTo(x + width - rx, y).arcTo([x + width, y + ry], rx, ry, false).lineTo(x + width, y + height - ry).arcTo([x + width - rx, y + height], rx, ry, false).lineTo(x + rx, y + height).arcTo([x, y + height - ry], rx, ry, false).lineTo(x, y + ry).arcTo([x + rx, y], rx, ry, false);\n    }\n    return path;\n  }\n  static fromPoints(points, options) {\n    if (points) {\n      const path = new Path(options);\n      for (let i = 0; i < points.length; i++) {\n        let point = Point.create(points[i]);\n        if (point) {\n          if (i === 0) {\n            path.moveTo(point);\n          } else {\n            path.lineTo(point);\n          }\n        }\n      }\n      return path;\n    }\n  }\n  static curveFromPoints(points, options) {\n    if (points) {\n      const segments = pointsToCurve(points);\n      const path = new Path(options);\n      path.segments.push.apply(path.segments, segments);\n      return path;\n    }\n  }\n  static fromArc(arc, options) {\n    const path = new Path(options);\n    const startAngle = arc.startAngle;\n    const start = arc.pointAt(startAngle);\n    path.moveTo(start.x, start.y);\n    path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n    return path;\n  }\n}\nexport class MultiPath extends paintable(measurable(Element)) {\n  static parse(str, options) {\n    const instance = new MultiPath(options);\n    return parsePath(instance, str);\n  }\n  toString(digits) {\n    const paths = this.paths;\n    let output = '';\n    if (paths.length > 0) {\n      const result = [];\n      for (let i = 0; i < paths.length; i++) {\n        result.push(paths[i].toString(digits));\n      }\n      output = result.join(SPACE);\n    }\n    return output;\n  }\n  get nodeType() {\n    return 'MultiPath';\n  }\n  constructor(options) {\n    super(options);\n    this.paths = new GeometryElementsArray();\n    this.paths.addObserver(this);\n    if (!defined(this.options.stroke)) {\n      this.stroke('#000');\n    }\n  }\n  moveTo(x, y) {\n    const path = new Path();\n    path.moveTo(x, y);\n    this.paths.push(path);\n    return this;\n  }\n  lineTo(x, y) {\n    if (this.paths.length > 0) {\n      last(this.paths).lineTo(x, y);\n    }\n    return this;\n  }\n  curveTo(controlOut, controlIn, point) {\n    if (this.paths.length > 0) {\n      last(this.paths).curveTo(controlOut, controlIn, point);\n    }\n    return this;\n  }\n  arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n    if (this.paths.length > 0) {\n      last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);\n    }\n    return this;\n  }\n  arcTo(end, rx, ry, largeArc, swipe, rotation) {\n    if (this.paths.length > 0) {\n      last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);\n    }\n    return this;\n  }\n  close() {\n    if (this.paths.length > 0) {\n      last(this.paths).close();\n    }\n    return this;\n  }\n  _bbox(matrix) {\n    return elementsBoundingBox(this.paths, true, matrix);\n  }\n  rawBBox() {\n    return elementsBoundingBox(this.paths, false);\n  }\n  _containsPoint(point) {\n    const paths = this.paths;\n    for (let idx = 0; idx < paths.length; idx++) {\n      if (paths[idx]._containsPoint(point)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _isOnPath(point) {\n    const paths = this.paths;\n    const width = this.options.stroke.width;\n    for (let idx = 0; idx < paths.length; idx++) {\n      if (paths[idx]._isOnPath(point, width)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _clippedBBox(transformation) {\n    return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));\n  }\n}","map":{"version":3,"names":["GeometryElementsArray","Element","pointsToCurve","paintable","measurable","Arc","Rect","Segment","Point","Size","lineIntersectionsCount","defined","last","rad","parsePath","elementsBoundingBox","elementsClippedBoundingBox","limitValue","SPACE","printPoints","precision","points","map","p","toString","join","segmentType","segmentStart","segmentEnd","controlOut","controlIn","Path","nodeType","constructor","options","segments","addObserver","stroke","lineJoin","set","moveTo","x","y","suspend","elements","resume","lineTo","point","segment","push","curveTo","length","lastSegment","arc","startAngle","endAngle","radiusX","radiusY","anticlockwise","anchor","start","center","Math","cos","sin","_addArcSegments","arcTo","end","rx","ry","largeArc","swipe","rotation","fromPoints","create","curvePoints","i","geometryChange","close","closed","rawBBox","_bbox","digits","output","parts","print","currentType","type","_containsPoint","intersectionsCount","previous","current","idx","_intersectionsTo","equals","_isOnPath","width","pathWidth","_isOnPathTo","matrix","boundingBox","transformCopy","ZERO","segmentBox","bboxTo","union","parse","str","MultiPath","fromRect","rect","path","cornerRadius","topLeft","topRight","bottomRight","bottomLeft","origin","height","curveFromPoints","apply","fromArc","pointAt","instance","paths","result","_clippedBBox","transformation","currentTransform"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-drawing/dist/es2015/shapes/path.js"],"sourcesContent":["import GeometryElementsArray from './geometry-elements-array';\nimport Element from './element';\nimport { pointsToCurve } from './utils/points-to-curve';\nimport paintable from '../mixins/paintable';\nimport measurable from '../mixins/measurable';\nimport Arc from '../geometry/arc';\nimport Rect from '../geometry/rect';\nimport Segment from '../geometry/segment';\nimport Point from '../geometry/point';\nimport Size from '../geometry/size';\nimport lineIntersectionsCount from '../geometry/math/line-intersections-count';\nimport { defined, last, rad } from '../util';\nimport parsePath from '../parsing/parse-path';\nimport elementsBoundingBox from './utils/elements-bounding-box';\nimport elementsClippedBoundingBox from './utils/elements-clippend-bounding-box';\nimport limitValue from '../util/limit-value';\n\nconst SPACE = ' ';\nconst printPoints = (precision) => (...points) => points.map(p => p.toString(precision)).join(SPACE);\nconst segmentType = (segmentStart, segmentEnd) => segmentStart.controlOut() && segmentEnd.controlIn() ? 'C' : 'L';\n\nexport class Path extends paintable(measurable(Element)) {\n    get nodeType() {\n        return 'Path';\n    }\n\n    constructor(options) {\n        super(options);\n        this.segments = new GeometryElementsArray();\n        this.segments.addObserver(this);\n\n        if (!defined(this.options.stroke)) {\n            this.stroke('#000');\n\n            if (!defined(this.options.stroke.lineJoin)) {\n                this.options.set('stroke.lineJoin', 'miter');\n            }\n        }\n    }\n\n    moveTo(x, y) {\n        this.suspend();\n        this.segments.elements([]);\n        this.resume();\n\n        this.lineTo(x, y);\n\n        return this;\n    }\n\n    lineTo(x, y) {\n        const point = defined(y) ? new Point(x, y) : x;\n        const segment = new Segment(point);\n\n        this.segments.push(segment);\n\n        return this;\n    }\n\n    curveTo(controlOut, controlIn, point) {\n        if (this.segments.length > 0) {\n            const lastSegment = last(this.segments);\n            const segment = new Segment(point, controlIn);\n            this.suspend();\n            lastSegment.controlOut(controlOut);\n            this.resume();\n\n            this.segments.push(segment);\n        }\n\n        return this;\n    }\n\n    arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n        if (this.segments.length > 0) {\n            const lastSegment = last(this.segments);\n            const anchor = lastSegment.anchor();\n            const start = rad(startAngle);\n            const center = new Point(anchor.x - radiusX * Math.cos(start),\n                anchor.y - radiusY * Math.sin(start));\n            const arc = new Arc(center, {\n                startAngle: startAngle,\n                endAngle: endAngle,\n                radiusX: radiusX,\n                radiusY: radiusY,\n                anticlockwise: anticlockwise\n            });\n\n            this._addArcSegments(arc);\n        }\n\n        return this;\n    }\n\n    arcTo(end, rx, ry, largeArc, swipe, rotation) {\n        if (this.segments.length > 0) {\n            const lastSegment = last(this.segments);\n            const anchor = lastSegment.anchor();\n            const arc = Arc.fromPoints(anchor, Point.create(end), rx, ry, largeArc, swipe, rotation);\n\n            this._addArcSegments(arc);\n        }\n        return this;\n    }\n\n    _addArcSegments(arc) {\n        this.suspend();\n\n        const curvePoints = arc.curvePoints();\n\n        for (let i = 1; i < curvePoints.length; i += 3) {\n            this.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n        }\n\n        this.resume();\n        this.geometryChange();\n    }\n\n    close() {\n        this.options.closed = true;\n        this.geometryChange();\n\n        return this;\n    }\n\n    rawBBox() {\n        return this._bbox();\n    }\n\n    toString(digits) {\n        let output = '';\n\n        const segments = this.segments;\n        const length = segments.length;\n        if (length > 0) {\n            const parts = [];\n            const print = printPoints(digits);\n            let currentType;\n\n            for (let i = 1; i < length; i++) {\n                let type = segmentType(segments[i - 1], segments[i]);\n                if (type !== currentType) {\n                    currentType = type;\n                    parts.push(type);\n                }\n\n                if (type === 'L') {\n                    parts.push(print(segments[i].anchor()));\n                } else {\n                    parts.push(print(\n                        segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()\n                    ));\n                }\n            }\n\n            output = 'M' + print(segments[0].anchor()) + SPACE + parts.join(SPACE);\n            if (this.options.closed) {\n                output += 'Z';\n            }\n        }\n\n        return output;\n    }\n\n    _containsPoint(point) {\n        const segments = this.segments;\n        const length = segments.length;\n        let intersectionsCount = 0;\n        let previous, current;\n\n        for (let idx = 1; idx < length; idx++) {\n            previous = segments[idx - 1];\n            current = segments[idx];\n            intersectionsCount += previous._intersectionsTo(current, point);\n        }\n\n        if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n            intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\n        }\n\n        return intersectionsCount % 2 !== 0;\n    }\n\n    _isOnPath(point, width) {\n        const segments = this.segments;\n        const length = segments.length;\n        const pathWidth = width || this.options.stroke.width;\n\n        if (length > 1) {\n            if (segments[0]._isOnPathTo(segments[1], point, pathWidth, 'start')) {\n                return true;\n            }\n\n            for (let idx = 2; idx <= length - 2; idx++) {\n                if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n                    return true;\n                }\n            }\n\n            if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, 'end')) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _bbox(matrix) {\n        const segments = this.segments;\n        const length = segments.length;\n        let boundingBox;\n\n        if (length === 1) {\n            let anchor = segments[0].anchor().transformCopy(matrix);\n            boundingBox = new Rect(anchor, Size.ZERO);\n        } else if (length > 0) {\n            for (let i = 1; i < length; i++) {\n                let segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n                if (boundingBox) {\n                    boundingBox = Rect.union(boundingBox, segmentBox);\n                } else {\n                    boundingBox = segmentBox;\n                }\n            }\n        }\n\n        return boundingBox;\n    }\n\n    static parse(str, options) {\n        return MultiPath.parse(str, options);\n    }\n\n    static fromRect(rect, options) {\n        const path = new Path(options);\n        let [ rx, ry ] = rect.cornerRadius;\n\n        if (rx === 0 && ry === 0) {\n            path.moveTo(rect.topLeft())\n                .lineTo(rect.topRight())\n                .lineTo(rect.bottomRight())\n                .lineTo(rect.bottomLeft())\n                .close();\n        } else {\n            const origin = rect.origin;\n            const { x, y } = origin;\n            const width = rect.width();\n            const height = rect.height();\n            rx = limitValue(rx, 0, width / 2);\n            ry = limitValue(ry, 0, height / 2);\n\n            path.moveTo(x + rx, y)\n                .lineTo(x + width - rx, y)\n                .arcTo([ x + width, y + ry ], rx, ry, false)\n                .lineTo(x + width, y + height - ry)\n                .arcTo([ x + width - rx, y + height ], rx, ry, false)\n                .lineTo(x + rx, y + height)\n                .arcTo([ x, y + height - ry ], rx, ry, false)\n                .lineTo(x, y + ry)\n                .arcTo([ x + rx, y ], rx, ry, false);\n        }\n\n        return path;\n    }\n\n    static fromPoints(points, options) {\n        if (points) {\n            const path = new Path(options);\n\n            for (let i = 0; i < points.length; i++) {\n                let point = Point.create(points[i]);\n                if (point) {\n                    if (i === 0) {\n                        path.moveTo(point);\n                    } else {\n                        path.lineTo(point);\n                    }\n                }\n            }\n\n            return path;\n        }\n    }\n\n    static curveFromPoints(points, options) {\n        if (points) {\n            const segments = pointsToCurve(points);\n            const path = new Path(options);\n            path.segments.push.apply(path.segments, segments);\n\n            return path;\n        }\n    }\n\n    static fromArc(arc, options) {\n        const path = new Path(options);\n        const startAngle = arc.startAngle;\n        const start = arc.pointAt(startAngle);\n        path.moveTo(start.x, start.y);\n        path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n        return path;\n    }\n}\n\nexport class MultiPath extends paintable(measurable(Element)) {\n    static parse(str, options) {\n        const instance = new MultiPath(options);\n        return parsePath(instance, str);\n    }\n\n    toString(digits) {\n        const paths = this.paths;\n        let output = '';\n\n        if (paths.length > 0) {\n            const result = [];\n\n            for (let i = 0; i < paths.length; i++) {\n                result.push(paths[i].toString(digits));\n            }\n\n            output = result.join(SPACE);\n        }\n\n        return output;\n    }\n\n    get nodeType() {\n        return 'MultiPath';\n    }\n\n    constructor(options) {\n        super(options);\n        this.paths = new GeometryElementsArray();\n        this.paths.addObserver(this);\n\n        if (!defined(this.options.stroke)) {\n            this.stroke('#000');\n        }\n    }\n\n    moveTo(x, y) {\n        const path = new Path();\n        path.moveTo(x, y);\n\n        this.paths.push(path);\n\n        return this;\n    }\n\n    lineTo(x, y) {\n        if (this.paths.length > 0) {\n            last(this.paths).lineTo(x, y);\n        }\n\n        return this;\n    }\n\n    curveTo(controlOut, controlIn, point) {\n        if (this.paths.length > 0) {\n            last(this.paths).curveTo(controlOut, controlIn, point);\n        }\n\n        return this;\n    }\n\n    arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n        if (this.paths.length > 0) {\n            last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);\n        }\n\n        return this;\n    }\n\n    arcTo(end, rx, ry, largeArc, swipe, rotation) {\n        if (this.paths.length > 0) {\n            last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);\n        }\n\n        return this;\n    }\n\n    close() {\n        if (this.paths.length > 0) {\n            last(this.paths).close();\n        }\n\n        return this;\n    }\n\n    _bbox(matrix) {\n        return elementsBoundingBox(this.paths, true, matrix);\n    }\n\n    rawBBox() {\n        return elementsBoundingBox(this.paths, false);\n    }\n\n    _containsPoint(point) {\n        const paths = this.paths;\n\n        for (let idx = 0; idx < paths.length; idx++) {\n            if (paths[idx]._containsPoint(point)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _isOnPath(point) {\n        const paths = this.paths;\n        const width = this.options.stroke.width;\n\n        for (let idx = 0; idx < paths.length; idx++) {\n            if (paths[idx]._isOnPath(point, width)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _clippedBBox(transformation) {\n        return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}