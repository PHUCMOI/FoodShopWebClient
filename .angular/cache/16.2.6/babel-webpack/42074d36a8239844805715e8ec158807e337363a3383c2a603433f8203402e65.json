{"ast":null,"code":"import Axis from './axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport limitCoordinate from './utils/limit-coordinate';\nimport { DEFAULT_PRECISION, BLACK } from '../common/constants';\nimport { deepExtend, defined, inArray, limitValue, round, setDefaultOptions, valueOrDefault } from '../common';\nconst DEFAULT_MAJOR_UNIT = 10;\nconst MIN_VALUE_RANGE = 1e-6;\nclass LogarithmicAxis extends Axis {\n  constructor(seriesMin, seriesMax, options, chartService) {\n    const axisOptions = deepExtend({\n      majorUnit: DEFAULT_MAJOR_UNIT,\n      min: seriesMin,\n      max: seriesMax\n    }, options);\n    const base = axisOptions.majorUnit;\n    const autoMax = autoAxisMax(seriesMax, base);\n    const autoMin = autoAxisMin(seriesMin, seriesMax, axisOptions);\n    const range = initRange(autoMin, autoMax, axisOptions, options);\n    axisOptions.max = range.max;\n    axisOptions.min = range.min;\n    axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n    super(axisOptions, chartService);\n    this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n    this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n    this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n    this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n    this.seriesMin = seriesMin;\n    this.seriesMax = seriesMax;\n    this.createLabels();\n  }\n  clone() {\n    return new LogarithmicAxis(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);\n  }\n  startValue() {\n    return this.options.min;\n  }\n  getSlot(a, b, limit) {\n    const {\n      options,\n      logMin,\n      logMax\n    } = this;\n    const {\n      majorUnit: base,\n      min,\n      max\n    } = options;\n    const {\n      axis,\n      axisDir,\n      lineBox,\n      lineSize,\n      lineStart\n    } = this.lineInfo();\n    const step = axisDir * (lineSize / (logMax - logMin));\n    let start = valueOrDefault(a, b || 1);\n    let end = valueOrDefault(b, a || 1);\n    if (start <= 0 || end <= 0) {\n      return null;\n    }\n    if (limit) {\n      start = limitValue(start, min, max);\n      end = limitValue(end, min, max);\n    }\n    start = log(start, base);\n    end = log(end, base);\n    const p1 = Math.min(start, end) - logMin;\n    const p2 = Math.max(start, end) - logMin;\n    const slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n    return slotBox;\n  }\n  getValue(point) {\n    const {\n      options,\n      logMin,\n      logMax\n    } = this;\n    const {\n      majorUnit: base\n    } = options;\n    const {\n      axis,\n      axisDir,\n      lineStart,\n      lineSize\n    } = this.lineInfo();\n    const step = (logMax - logMin) / lineSize;\n    const offset = axisDir * (point[axis] - lineStart);\n    const valueOffset = offset * step;\n    if (offset < 0 || offset > lineSize) {\n      return null;\n    }\n    const value = logMin + valueOffset;\n    return round(Math.pow(base, value), DEFAULT_PRECISION);\n  }\n  range() {\n    const options = this.options;\n    return {\n      min: options.min,\n      max: options.max\n    };\n  }\n  translateRange(delta) {\n    const {\n      options,\n      logMin,\n      logMax\n    } = this;\n    const {\n      reverse,\n      vertical,\n      majorUnit: base\n    } = options;\n    const lineBox = this.lineBox();\n    const size = vertical ? lineBox.height() : lineBox.width();\n    const scale = size / (logMax - logMin);\n    let offset = round(delta / scale, DEFAULT_PRECISION);\n    if ((vertical || reverse) && !(vertical && reverse)) {\n      offset = -offset;\n    }\n    return {\n      min: Math.pow(base, logMin + offset),\n      max: Math.pow(base, logMax + offset),\n      offset: offset\n    };\n  }\n  labelsCount() {\n    const floorMax = Math.floor(this.logMax);\n    const count = Math.floor(floorMax - this.logMin) + 1;\n    return count;\n  }\n  getMajorTickPositions() {\n    const ticks = [];\n    this.traverseMajorTicksPositions(position => {\n      ticks.push(position);\n    }, {\n      step: 1,\n      skip: 0\n    });\n    return ticks;\n  }\n  createTicks(lineGroup) {\n    const options = this.options;\n    const {\n      majorTicks,\n      minorTicks,\n      vertical\n    } = options;\n    const mirror = options.labels.mirror;\n    const lineBox = this.lineBox();\n    const ticks = [];\n    const tickLineOptions = {\n      // TODO\n      // _alignLines: options._alignLines,\n      vertical: vertical\n    };\n    function render(tickPosition, tickOptions) {\n      tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n      tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n      tickLineOptions.position = tickPosition;\n      lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n    }\n    if (majorTicks.visible) {\n      this.traverseMajorTicksPositions(render, majorTicks);\n    }\n    if (minorTicks.visible) {\n      this.traverseMinorTicksPositions(render, minorTicks);\n    }\n    return ticks;\n  }\n  createGridLines(altAxis) {\n    const options = this.options;\n    const {\n      minorGridLines,\n      majorGridLines,\n      vertical\n    } = options;\n    const lineBox = altAxis.lineBox();\n    const lineOptions = {\n      lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n      lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n      vertical: vertical\n    };\n    const majorTicks = [];\n    const container = this.gridLinesVisual();\n    function render(tickPosition, gridLine) {\n      if (!inArray(tickPosition, majorTicks)) {\n        lineOptions.position = tickPosition;\n        container.append(createAxisGridLine(lineOptions, gridLine));\n        majorTicks.push(tickPosition);\n      }\n    }\n    if (majorGridLines.visible) {\n      this.traverseMajorTicksPositions(render, majorGridLines);\n    }\n    if (minorGridLines.visible) {\n      this.traverseMinorTicksPositions(render, minorGridLines);\n    }\n    return container.children;\n  }\n  traverseMajorTicksPositions(callback, tickOptions) {\n    const {\n      lineStart,\n      step\n    } = this.lineInfo();\n    const {\n      logMin,\n      logMax\n    } = this;\n    for (let power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n      let position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n      callback(position, tickOptions);\n    }\n  }\n  traverseMinorTicksPositions(callback, tickOptions) {\n    const {\n      min,\n      max,\n      minorUnit,\n      majorUnit: base\n    } = this.options;\n    const {\n      lineStart,\n      step\n    } = this.lineInfo();\n    const {\n      logMin,\n      logMax\n    } = this;\n    const start = Math.floor(logMin);\n    for (let power = start; power < logMax; power++) {\n      const minorOptions = this._minorIntervalOptions(power);\n      for (let idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n        const value = minorOptions.value + idx * minorOptions.minorStep;\n        if (value > max) {\n          break;\n        }\n        if (value >= min) {\n          const position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n          callback(position, tickOptions);\n        }\n      }\n    }\n  }\n  createAxisLabel(index, labelOptions, labelContext) {\n    const power = Math.ceil(this.logMin + index);\n    const value = Math.pow(this.options.majorUnit, power);\n    const text = this.axisLabelText(value, labelOptions, labelContext);\n    return new AxisLabel(value, text, index, null, labelOptions);\n  }\n  shouldRenderNote(value) {\n    const range = this.range();\n    return range.min <= value && value <= range.max;\n  }\n  pan(delta) {\n    const range = this.translateRange(delta);\n    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n  }\n  pointsRange(start, end) {\n    const startValue = this.getValue(start);\n    const endValue = this.getValue(end);\n    const min = Math.min(startValue, endValue);\n    const max = Math.max(startValue, endValue);\n    return {\n      min: min,\n      max: max\n    };\n  }\n  scaleRange(scale, cursor) {\n    const {\n      majorUnit: base\n    } = this.options;\n    const logMin = log(this.options.min, base);\n    const logMax = log(this.options.max, base);\n    const position = Math.abs(this.pointOffset(cursor));\n    const range = logMax - logMin;\n    const delta = this.scaleToDelta(scale, range);\n    const min = Math.pow(base, logMin + position * delta);\n    let max = Math.pow(base, logMax - (1 - position) * delta);\n    if (max - min < MIN_VALUE_RANGE) {\n      max = min + MIN_VALUE_RANGE;\n    }\n    return {\n      min: min,\n      max: max\n    };\n  }\n  zoomRange(scale, cursor) {\n    const range = this.scaleRange(scale, cursor);\n    const {\n      totalMin,\n      totalMax\n    } = this;\n    return {\n      min: limitValue(range.min, totalMin, totalMax),\n      max: limitValue(range.max, totalMin, totalMax)\n    };\n  }\n  _minorIntervalOptions(power) {\n    const {\n      minorUnit,\n      majorUnit: base\n    } = this.options;\n    const value = Math.pow(base, power);\n    const nextValue = Math.pow(base, power + 1);\n    const difference = nextValue - value;\n    const minorStep = difference / minorUnit;\n    return {\n      value: value,\n      minorStep: minorStep\n    };\n  }\n  lineInfo() {\n    const info = super.lineInfo();\n    info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));\n    return info;\n  }\n}\nfunction initRange(autoMin, autoMax, axisOptions, options) {\n  let {\n    min,\n    max\n  } = axisOptions;\n  if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n    throwNegativeValuesError();\n  }\n  if (!defined(options.max)) {\n    max = autoMax;\n  } else if (options.max <= 0) {\n    throwNegativeValuesError();\n  }\n  if (!defined(options.min)) {\n    min = autoMin;\n  } else if (options.min <= 0) {\n    throwNegativeValuesError();\n  }\n  return {\n    min: min,\n    max: max\n  };\n}\nfunction autoAxisMin(min, max, options) {\n  const base = options.majorUnit;\n  let autoMin = min;\n  if (min <= 0) {\n    autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n  } else if (!options.narrowRange) {\n    autoMin = Math.pow(base, Math.floor(log(min, base)));\n  }\n  return autoMin;\n}\nfunction autoAxisMax(max, base) {\n  const logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n  let autoMax;\n  if (max <= 0) {\n    autoMax = base;\n  } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n    autoMax = Math.pow(base, log(max, base) + 0.2);\n  } else {\n    autoMax = Math.pow(base, Math.ceil(log(max, base)));\n  }\n  return autoMax;\n}\nfunction throwNegativeValuesError() {\n  throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n}\nfunction log(x, base) {\n  return Math.log(x) / Math.log(base);\n}\nsetDefaultOptions(LogarithmicAxis, {\n  type: \"log\",\n  majorUnit: DEFAULT_MAJOR_UNIT,\n  minorUnit: 1,\n  axisCrossingValue: 1,\n  vertical: true,\n  majorGridLines: {\n    visible: true,\n    width: 1,\n    color: BLACK\n  },\n  zIndex: 1,\n  _deferLabels: true\n});\nexport default LogarithmicAxis;","map":{"version":3,"names":["Axis","AxisLabel","Box","createAxisTick","createAxisGridLine","limitCoordinate","DEFAULT_PRECISION","BLACK","deepExtend","defined","inArray","limitValue","round","setDefaultOptions","valueOrDefault","DEFAULT_MAJOR_UNIT","MIN_VALUE_RANGE","LogarithmicAxis","constructor","seriesMin","seriesMax","options","chartService","axisOptions","majorUnit","min","max","base","autoMax","autoAxisMax","autoMin","autoAxisMin","range","initRange","minorUnit","totalMin","Math","totalMax","logMin","log","logMax","createLabels","clone","Object","assign","startValue","getSlot","a","b","limit","axis","axisDir","lineBox","lineSize","lineStart","lineInfo","step","start","end","p1","p2","slotBox","x1","y1","getValue","point","offset","valueOffset","value","pow","translateRange","delta","reverse","vertical","size","height","width","scale","labelsCount","floorMax","floor","count","getMajorTickPositions","ticks","traverseMajorTicksPositions","position","push","skip","createTicks","lineGroup","majorTicks","minorTicks","mirror","labels","tickLineOptions","render","tickPosition","tickOptions","tickX","x2","tickY","append","visible","traverseMinorTicksPositions","createGridLines","altAxis","minorGridLines","majorGridLines","lineOptions","lineEnd","container","gridLinesVisual","gridLine","children","callback","power","ceil","minorOptions","_minorIntervalOptions","idx","minorStep","createAxisLabel","index","labelOptions","labelContext","text","axisLabelText","shouldRenderNote","pan","limitRange","pointsRange","endValue","scaleRange","cursor","abs","pointOffset","scaleToDelta","zoomRange","nextValue","difference","info","axisCrossingValue","throwNegativeValuesError","narrowRange","logMaxRemainder","Error","x","type","color","zIndex","_deferLabels"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/core/logarithmic-axis.js"],"sourcesContent":["\nimport Axis from './axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\n\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport limitCoordinate from './utils/limit-coordinate';\n\nimport { DEFAULT_PRECISION, BLACK } from '../common/constants';\nimport { deepExtend, defined, inArray, limitValue, round, setDefaultOptions, valueOrDefault } from '../common';\n\nconst DEFAULT_MAJOR_UNIT = 10;\nconst MIN_VALUE_RANGE = 1e-6;\n\nclass LogarithmicAxis extends Axis {\n    constructor(seriesMin, seriesMax, options, chartService) {\n\n        const axisOptions = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options);\n        const base = axisOptions.majorUnit;\n        const autoMax = autoAxisMax(seriesMax, base);\n        const autoMin = autoAxisMin(seriesMin, seriesMax, axisOptions);\n        const range = initRange(autoMin, autoMax, axisOptions, options);\n\n        axisOptions.max = range.max;\n        axisOptions.min = range.min;\n        axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n\n        super(axisOptions, chartService);\n\n        this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n        this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n        this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n        this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n        this.seriesMin = seriesMin;\n        this.seriesMax = seriesMax;\n\n        this.createLabels();\n    }\n\n    clone() {\n        return new LogarithmicAxis(\n            this.seriesMin,\n            this.seriesMax,\n            Object.assign({}, this.options),\n            this.chartService\n        );\n    }\n\n    startValue() {\n        return this.options.min;\n    }\n\n    getSlot(a, b, limit) {\n        const { options, logMin, logMax } = this;\n        const { majorUnit: base, min, max } = options;\n        const { axis, axisDir, lineBox, lineSize, lineStart } = this.lineInfo();\n        const step = axisDir * (lineSize / (logMax - logMin));\n        let start = valueOrDefault(a, b || 1);\n        let end = valueOrDefault(b, a || 1);\n\n        if (start <= 0 || end <= 0) {\n            return null;\n        }\n\n        if (limit) {\n            start = limitValue(start, min, max);\n            end = limitValue(end, min, max);\n        }\n\n        start = log(start, base);\n        end = log(end, base);\n\n        const p1 = Math.min(start, end) - logMin;\n        const p2 = Math.max(start, end) - logMin;\n\n        const slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n        slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n        slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n\n        return slotBox;\n    }\n\n    getValue(point) {\n        const { options, logMin, logMax } = this;\n        const { majorUnit: base } = options;\n        const { axis, axisDir, lineStart, lineSize } = this.lineInfo();\n        const step = ((logMax - logMin) / lineSize);\n        const offset = axisDir * (point[axis] - lineStart);\n        const valueOffset = offset * step;\n\n        if (offset < 0 || offset > lineSize) {\n            return null;\n        }\n\n        const value = logMin + valueOffset;\n\n        return round(Math.pow(base, value), DEFAULT_PRECISION);\n    }\n\n    range() {\n        const options = this.options;\n        return { min: options.min, max: options.max };\n    }\n\n    translateRange(delta) {\n        const { options, logMin, logMax } = this;\n        const { reverse, vertical, majorUnit: base } = options;\n        const lineBox = this.lineBox();\n        const size = vertical ? lineBox.height() : lineBox.width();\n        const scale = size / (logMax - logMin);\n        let offset = round(delta / scale, DEFAULT_PRECISION);\n\n        if ((vertical || reverse) && !(vertical && reverse )) {\n            offset = -offset;\n        }\n\n        return {\n            min: Math.pow(base, logMin + offset),\n            max: Math.pow(base, logMax + offset),\n            offset: offset\n        };\n    }\n\n    labelsCount() {\n        const floorMax = Math.floor(this.logMax);\n        const count = Math.floor(floorMax - this.logMin) + 1;\n\n        return count;\n    }\n\n    getMajorTickPositions() {\n        const ticks = [];\n\n        this.traverseMajorTicksPositions((position) => {\n            ticks.push(position);\n        }, { step: 1, skip: 0 });\n\n        return ticks;\n    }\n\n    createTicks(lineGroup) {\n        const options = this.options;\n        const { majorTicks, minorTicks, vertical } = options;\n        const mirror = options.labels.mirror;\n        const lineBox = this.lineBox();\n        const ticks = [];\n        const tickLineOptions = {\n            // TODO\n            // _alignLines: options._alignLines,\n            vertical: vertical\n        };\n\n        function render(tickPosition, tickOptions) {\n            tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n            tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n            tickLineOptions.position = tickPosition;\n\n            lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n        }\n\n        if (majorTicks.visible) {\n            this.traverseMajorTicksPositions(render, majorTicks);\n        }\n\n        if (minorTicks.visible) {\n            this.traverseMinorTicksPositions(render, minorTicks);\n        }\n\n        return ticks;\n    }\n\n    createGridLines(altAxis) {\n        const options = this.options;\n        const { minorGridLines, majorGridLines, vertical } = options;\n        const lineBox = altAxis.lineBox();\n        const lineOptions = {\n            lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n            lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n            vertical: vertical\n        };\n        const majorTicks = [];\n\n        const container = this.gridLinesVisual();\n        function render(tickPosition, gridLine) {\n            if (!inArray(tickPosition, majorTicks)) {\n                lineOptions.position = tickPosition;\n                container.append(createAxisGridLine(lineOptions, gridLine));\n\n                majorTicks.push(tickPosition);\n            }\n        }\n\n        if (majorGridLines.visible) {\n            this.traverseMajorTicksPositions(render, majorGridLines);\n        }\n\n        if (minorGridLines.visible) {\n            this.traverseMinorTicksPositions(render, minorGridLines);\n        }\n\n        return container.children;\n    }\n\n    traverseMajorTicksPositions(callback, tickOptions) {\n        const { lineStart, step } = this.lineInfo();\n        const { logMin, logMax } = this;\n\n        for (let power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n            let position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n            callback(position, tickOptions);\n        }\n    }\n\n    traverseMinorTicksPositions(callback, tickOptions) {\n        const { min, max, minorUnit, majorUnit: base } = this.options;\n        const { lineStart, step } = this.lineInfo();\n        const { logMin, logMax } = this;\n        const start = Math.floor(logMin);\n\n        for (let power = start; power < logMax; power++) {\n            const minorOptions = this._minorIntervalOptions(power);\n            for (let idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n                const value = minorOptions.value + idx * minorOptions.minorStep;\n                if (value > max) {\n                    break;\n                }\n                if (value >= min) {\n                    const position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n                    callback(position, tickOptions);\n                }\n            }\n        }\n    }\n\n    createAxisLabel(index, labelOptions, labelContext) {\n        const power = Math.ceil(this.logMin + index);\n        const value = Math.pow(this.options.majorUnit, power);\n        const text = this.axisLabelText(value, labelOptions, labelContext);\n\n        return new AxisLabel(value, text, index, null, labelOptions);\n    }\n\n    shouldRenderNote(value) {\n        const range = this.range();\n        return range.min <= value && value <= range.max;\n    }\n\n    pan(delta) {\n        const range = this.translateRange(delta);\n        return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n    }\n\n    pointsRange(start, end) {\n        const startValue = this.getValue(start);\n        const endValue = this.getValue(end);\n        const min = Math.min(startValue, endValue);\n        const max = Math.max(startValue, endValue);\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    scaleRange(scale, cursor) {\n        const { majorUnit: base } = this.options;\n        const logMin = log(this.options.min, base);\n        const logMax = log(this.options.max, base);\n        const position = Math.abs(this.pointOffset(cursor));\n        const range = logMax - logMin;\n        const delta = this.scaleToDelta(scale, range);\n        const min = Math.pow(base, logMin + position * delta);\n        let max = Math.pow(base, logMax - (1 - position) * delta);\n\n        if (max - min < MIN_VALUE_RANGE) {\n            max = min + MIN_VALUE_RANGE;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    zoomRange(scale, cursor) {\n        const range = this.scaleRange(scale, cursor);\n        const { totalMin, totalMax } = this;\n\n        return {\n            min: limitValue(range.min, totalMin, totalMax),\n            max: limitValue(range.max, totalMin, totalMax)\n        };\n    }\n\n    _minorIntervalOptions(power) {\n        const { minorUnit, majorUnit: base } = this.options;\n        const value = Math.pow(base, power);\n        const nextValue = Math.pow(base, power + 1);\n        const difference = nextValue - value;\n        const minorStep = difference / minorUnit;\n\n        return {\n            value: value,\n            minorStep: minorStep\n        };\n    }\n\n    lineInfo() {\n        const info = super.lineInfo();\n        info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));\n\n        return info;\n    }\n}\n\nfunction initRange(autoMin, autoMax, axisOptions, options) {\n    let { min, max } = axisOptions;\n\n    if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n        throwNegativeValuesError();\n    }\n\n    if (!defined(options.max)) {\n        max = autoMax;\n    } else if (options.max <= 0) {\n        throwNegativeValuesError();\n    }\n\n    if (!defined(options.min)) {\n        min = autoMin;\n    } else if (options.min <= 0) {\n        throwNegativeValuesError();\n    }\n\n    return {\n        min: min,\n        max: max\n    };\n}\n\nfunction autoAxisMin(min, max, options) {\n    const base = options.majorUnit;\n    let autoMin = min;\n    if (min <= 0) {\n        autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n    } else if (!options.narrowRange) {\n        autoMin = Math.pow(base, Math.floor(log(min, base)));\n    }\n    return autoMin;\n}\n\nfunction autoAxisMax(max, base) {\n    const logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n    let autoMax;\n    if (max <= 0) {\n        autoMax = base;\n    } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n        autoMax = Math.pow(base, log(max, base) + 0.2);\n    } else {\n        autoMax = Math.pow(base, Math.ceil(log(max, base)));\n    }\n\n    return autoMax;\n}\n\nfunction throwNegativeValuesError() {\n    throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n}\n\nfunction log(x, base) {\n    return Math.log(x) / Math.log(base);\n}\n\nsetDefaultOptions(LogarithmicAxis, {\n    type: \"log\",\n    majorUnit: DEFAULT_MAJOR_UNIT,\n    minorUnit: 1,\n    axisCrossingValue: 1,\n    vertical: true,\n    majorGridLines: {\n        visible: true,\n        width: 1,\n        color: BLACK\n    },\n    zIndex: 1,\n    _deferLabels: true\n});\n\nexport default LogarithmicAxis;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}