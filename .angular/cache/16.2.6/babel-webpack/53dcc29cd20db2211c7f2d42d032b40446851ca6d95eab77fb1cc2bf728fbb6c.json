{"ast":null,"code":"import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\nimport ChartElement from './chart-element';\nimport TextBox from './text-box';\nimport AxisLabel from './axis-label';\nimport Note from './note';\nimport Box from './box';\nimport { ChartService } from '../services';\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport { NONE, BLACK, CENTER, TOP, BOTTOM, LEFT, RIGHT, OUTSIDE, X, Y, WIDTH, HEIGHT } from '../common/constants';\nimport { alignPathToPixel, deepExtend, getTemplate, grep, defined, isObject, inArray, limitValue, round, setDefaultOptions } from '../common';\nclass Axis extends ChartElement {\n  constructor(options, chartService = new ChartService()) {\n    super(options);\n    this.chartService = chartService;\n    if (!this.options.visible) {\n      this.options = deepExtend({}, this.options, {\n        labels: {\n          visible: false\n        },\n        line: {\n          visible: false\n        },\n        margin: 0,\n        majorTickSize: 0,\n        minorTickSize: 0\n      });\n    }\n    this.options.minorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.minorTickType !== NONE\n    }, this.options.minorTicks, {\n      size: this.options.minorTickSize,\n      align: this.options.minorTickType\n    });\n    this.options.majorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.majorTickType !== NONE\n    }, this.options.majorTicks, {\n      size: this.options.majorTickSize,\n      align: this.options.majorTickType\n    });\n    this.initFields();\n    if (!this.options._deferLabels) {\n      this.createLabels();\n    }\n    this.createTitle();\n    this.createNotes();\n  }\n  initFields() {}\n\n  // abstract labelsCount(): Number\n  // abstract createAxisLabel(index, options): AxisLabel\n\n  labelsRange() {\n    return {\n      min: this.options.labels.skip,\n      max: this.labelsCount()\n    };\n  }\n  normalizeLabelRotation(labelOptions) {\n    const rotation = labelOptions.rotation;\n    if (isObject(rotation)) {\n      labelOptions.alignRotation = rotation.align;\n      labelOptions.rotation = rotation.angle;\n    }\n  }\n  createLabels() {\n    const options = this.options;\n    const align = options.vertical ? RIGHT : CENTER;\n    const labelOptions = deepExtend({}, options.labels, {\n      align: align,\n      zIndex: options.zIndex\n    });\n    const step = Math.max(1, labelOptions.step);\n    this.clearLabels();\n    if (labelOptions.visible) {\n      this.normalizeLabelRotation(labelOptions);\n      if (labelOptions.rotation === \"auto\") {\n        labelOptions.rotation = 0;\n        options.autoRotateLabels = true;\n      }\n      const range = this.labelsRange();\n      for (let idx = range.min; idx < range.max; idx += step) {\n        const labelContext = {\n          index: idx,\n          count: range.max\n        };\n        let label = this.createAxisLabel(idx, labelOptions, labelContext);\n        if (label) {\n          this.append(label);\n          this.labels.push(label);\n        }\n      }\n    }\n  }\n  clearLabels() {\n    this.children = grep(this.children, child => !(child instanceof AxisLabel));\n    this.labels = [];\n  }\n  clearTitle() {\n    if (this.title) {\n      this.children = grep(this.children, child => child !== this.title);\n      this.title = undefined;\n    }\n  }\n  clear() {\n    this.clearLabels();\n    this.clearTitle();\n  }\n  lineBox() {\n    const {\n      options,\n      box\n    } = this;\n    const vertical = options.vertical;\n    const mirror = options.labels.mirror;\n    const axisX = mirror ? box.x1 : box.x2;\n    const axisY = mirror ? box.y2 : box.y1;\n    const lineWidth = options.line.width || 0;\n    return vertical ? new Box(axisX, box.y1, axisX, box.y2 - lineWidth) : new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n  }\n  createTitle() {\n    const options = this.options;\n    const titleOptions = deepExtend({\n      rotation: options.vertical ? -90 : 0,\n      text: \"\",\n      zIndex: 1,\n      visualSize: true\n    }, options.title);\n    if (titleOptions.visible && titleOptions.text) {\n      const title = new TextBox(titleOptions.text, titleOptions);\n      this.append(title);\n      this.title = title;\n    }\n  }\n  createNotes() {\n    const options = this.options;\n    const notes = options.notes;\n    const items = notes.data || [];\n    this.notes = [];\n    for (let i = 0; i < items.length; i++) {\n      const item = deepExtend({}, notes, items[i]);\n      item.value = this.parseNoteValue(item.value);\n      const note = new Note({\n        value: item.value,\n        text: item.label.text,\n        dataItem: item\n      }, item, this.chartService);\n      if (note.options.visible) {\n        if (defined(note.options.position)) {\n          if (options.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else if (!options.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        } else {\n          if (options.vertical) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        }\n        this.append(note);\n        this.notes.push(note);\n      }\n    }\n  }\n  parseNoteValue(value) {\n    return value;\n  }\n  renderVisual() {\n    super.renderVisual();\n    this.createPlotBands();\n  }\n  createVisual() {\n    super.createVisual();\n    this.createBackground();\n    this.createLine();\n  }\n  gridLinesVisual() {\n    let gridLines = this._gridLines;\n    if (!gridLines) {\n      gridLines = this._gridLines = new draw.Group({\n        zIndex: -2\n      });\n      this.appendVisual(this._gridLines);\n    }\n    return gridLines;\n  }\n  createTicks(lineGroup) {\n    const options = this.options;\n    const lineBox = this.lineBox();\n    const mirror = options.labels.mirror;\n    const majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n    const tickLineOptions = {\n      // TODO\n      // _alignLines: options._alignLines,\n      vertical: options.vertical\n    };\n    function render(tickPositions, tickOptions, skipUnit) {\n      const count = tickPositions.length;\n      const step = Math.max(1, tickOptions.step);\n      if (tickOptions.visible) {\n        for (let i = tickOptions.skip; i < count; i += step) {\n          if (defined(skipUnit) && i % skipUnit === 0) {\n            continue;\n          }\n          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n          tickLineOptions.position = tickPositions[i];\n          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n        }\n      }\n    }\n    render(this.getMajorTickPositions(), options.majorTicks);\n    render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n  }\n  createLine() {\n    const options = this.options;\n    const line = options.line;\n    const lineBox = this.lineBox();\n    if (line.width > 0 && line.visible) {\n      const path = new draw.Path({\n        stroke: {\n          width: line.width,\n          color: line.color,\n          dashType: line.dashType\n        }\n\n        /* TODO\n        zIndex: line.zIndex,\n        */\n      });\n\n      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n      if (options._alignLines) {\n        alignPathToPixel(path);\n      }\n      const group = this._lineGroup = new draw.Group();\n      group.append(path);\n      this.visual.append(group);\n      this.createTicks(group);\n    }\n  }\n  getActualTickSize() {\n    const options = this.options;\n    let tickSize = 0;\n    if (options.majorTicks.visible && options.minorTicks.visible) {\n      tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n    } else if (options.majorTicks.visible) {\n      tickSize = options.majorTicks.size;\n    } else if (options.minorTicks.visible) {\n      tickSize = options.minorTicks.size;\n    }\n    return tickSize;\n  }\n  createBackground() {\n    const {\n      options,\n      box\n    } = this;\n    const background = options.background;\n    if (background) {\n      this._backgroundPath = draw.Path.fromRect(box.toRect(), {\n        fill: {\n          color: background\n        },\n        stroke: null\n      });\n      this.visual.append(this._backgroundPath);\n    }\n  }\n  createPlotBands() {\n    const options = this.options;\n    const plotBands = options.plotBands || [];\n    const vertical = options.vertical;\n    const plotArea = this.plotArea;\n    if (plotBands.length === 0) {\n      return;\n    }\n    const group = this._plotbandGroup = new draw.Group({\n      zIndex: -1\n    });\n    const altAxis = grep(this.pane.axes, axis => axis.options.vertical !== this.options.vertical)[0];\n    for (let idx = 0; idx < plotBands.length; idx++) {\n      let item = plotBands[idx];\n      let slotX, slotY;\n      let labelOptions = item.label;\n      let label;\n      if (vertical) {\n        slotX = (altAxis || plotArea.axisX).lineBox();\n        slotY = this.getSlot(item.from, item.to, true);\n      } else {\n        slotX = this.getSlot(item.from, item.to, true);\n        slotY = (altAxis || plotArea.axisY).lineBox();\n      }\n      if (labelOptions) {\n        labelOptions.vAlign = labelOptions.position || LEFT;\n        label = this.createPlotBandLabel(labelOptions, item, new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2));\n      }\n      if (slotX.width() !== 0 && slotY.height() !== 0) {\n        const bandRect = new geom.Rect([slotX.x1, slotY.y1], [slotX.width(), slotY.height()]);\n        const path = draw.Path.fromRect(bandRect, {\n          fill: {\n            color: item.color,\n            opacity: item.opacity\n          },\n          stroke: null\n        });\n        group.append(path);\n        if (label) {\n          group.append(label);\n        }\n      }\n    }\n    this.appendVisual(group);\n  }\n  createPlotBandLabel(label, item, box) {\n    if (label.visible === false) {\n      return null;\n    }\n    let text = label.text;\n    let textbox;\n    if (defined(label) && label.visible) {\n      const labelTemplate = getTemplate(label);\n      if (labelTemplate) {\n        text = labelTemplate({\n          text: text,\n          item: item\n        });\n      } else if (label.format) {\n        text = this.chartService.format.auto(label.format, text);\n      }\n      if (!label.color) {\n        label.color = this.options.labels.color;\n      }\n    }\n    textbox = new TextBox(text, label);\n    textbox.reflow(box);\n    textbox.renderVisual();\n    return textbox.visual;\n  }\n  createGridLines(altAxis) {\n    const options = this.options;\n    const {\n      minorGridLines,\n      majorGridLines,\n      minorUnit,\n      vertical\n    } = options;\n    const axisLineVisible = altAxis.options.line.visible;\n    const majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n    const lineBox = altAxis.lineBox();\n    const linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n    const lineOptions = {\n      lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n      lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n      vertical: vertical\n    };\n    const majorTicks = [];\n    const container = this.gridLinesVisual();\n    function render(tickPositions, gridLine, skipUnit) {\n      const count = tickPositions.length;\n      const step = Math.max(1, gridLine.step);\n      if (gridLine.visible) {\n        for (let i = gridLine.skip; i < count; i += step) {\n          let pos = round(tickPositions[i]);\n          if (!inArray(pos, majorTicks)) {\n            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n              lineOptions.position = pos;\n              container.append(createAxisGridLine(lineOptions, gridLine));\n              majorTicks.push(pos);\n            }\n          }\n        }\n      }\n    }\n    render(this.getMajorTickPositions(), majorGridLines);\n    render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n    return container.children;\n  }\n  reflow(box) {\n    const {\n      options,\n      labels,\n      title\n    } = this;\n    const vertical = options.vertical;\n    const count = labels.length;\n    const sizeFn = vertical ? WIDTH : HEIGHT;\n    const titleSize = title ? title.box[sizeFn]() : 0;\n    const space = this.getActualTickSize() + options.margin + titleSize;\n    const rootBox = (this.getRoot() || {}).box || box;\n    const boxSize = rootBox[sizeFn]();\n    let maxLabelSize = 0;\n    for (let i = 0; i < count; i++) {\n      let labelSize = labels[i].box[sizeFn]();\n      if (labelSize + space <= boxSize) {\n        maxLabelSize = Math.max(maxLabelSize, labelSize);\n      }\n    }\n    if (vertical) {\n      this.box = new Box(box.x1, box.y1, box.x1 + maxLabelSize + space, box.y2);\n    } else {\n      this.box = new Box(box.x1, box.y1, box.x2, box.y1 + maxLabelSize + space);\n    }\n    this.arrangeTitle();\n    this.arrangeLabels();\n    this.arrangeNotes();\n  }\n  getLabelsTickPositions() {\n    return this.getMajorTickPositions();\n  }\n  labelTickIndex(label) {\n    return label.index;\n  }\n  arrangeLabels() {\n    const {\n      options,\n      labels\n    } = this;\n    const labelsBetweenTicks = this.labelsBetweenTicks();\n    const vertical = options.vertical;\n    const mirror = options.labels.mirror;\n    const tickPositions = this.getLabelsTickPositions();\n    for (let idx = 0; idx < labels.length; idx++) {\n      const label = labels[idx];\n      const tickIx = this.labelTickIndex(label);\n      const labelSize = vertical ? label.box.height() : label.box.width();\n      const firstTickPosition = tickPositions[tickIx];\n      const nextTickPosition = tickPositions[tickIx + 1];\n      let positionStart, positionEnd;\n      if (vertical) {\n        if (labelsBetweenTicks) {\n          const middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n          positionStart = middle - labelSize / 2;\n        } else {\n          positionStart = firstTickPosition - labelSize / 2;\n        }\n        positionEnd = positionStart;\n      } else {\n        if (labelsBetweenTicks) {\n          positionStart = firstTickPosition;\n          positionEnd = nextTickPosition;\n        } else {\n          positionStart = firstTickPosition - labelSize / 2;\n          positionEnd = positionStart + labelSize;\n        }\n      }\n      this.positionLabel(label, mirror, positionStart, positionEnd);\n    }\n  }\n  positionLabel(label, mirror, positionStart, positionEnd = positionStart) {\n    const options = this.options;\n    const vertical = options.vertical;\n    const lineBox = this.lineBox();\n    const labelOffset = this.getActualTickSize() + options.margin;\n    let labelBox;\n    if (vertical) {\n      let labelX = lineBox.x2;\n      if (mirror) {\n        labelX += labelOffset;\n        label.options.rotationOrigin = LEFT;\n      } else {\n        labelX -= labelOffset + label.box.width();\n        label.options.rotationOrigin = RIGHT;\n      }\n      labelBox = label.box.move(labelX, positionStart);\n    } else {\n      let labelY = lineBox.y1;\n      if (mirror) {\n        labelY -= labelOffset + label.box.height();\n        label.options.rotationOrigin = BOTTOM;\n      } else {\n        labelY += labelOffset;\n        label.options.rotationOrigin = TOP;\n      }\n      labelBox = new Box(positionStart, labelY, positionEnd, labelY + label.box.height());\n    }\n    label.reflow(labelBox);\n  }\n  autoRotateLabelAngle(labelBox, slotWidth) {\n    if (labelBox.width() < slotWidth) {\n      return 0;\n    }\n    if (labelBox.height() > slotWidth) {\n      return -90;\n    }\n    return -45;\n  }\n  autoRotateLabels() {\n    if (!this.options.autoRotateLabels || this.options.vertical) {\n      return false;\n    }\n    const tickPositions = this.getMajorTickPositions();\n    const labels = this.labels;\n    const limit = Math.min(labels.length, tickPositions.length - 1);\n    let angle = 0;\n    for (let idx = 0; idx < limit; idx++) {\n      const width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n      const labelBox = labels[idx].box;\n      const labelAngle = this.autoRotateLabelAngle(labelBox, width);\n      if (labelAngle !== 0) {\n        angle = labelAngle;\n      }\n      if (angle === -90) {\n        break;\n      }\n    }\n    if (angle !== 0) {\n      for (let idx = 0; idx < labels.length; idx++) {\n        labels[idx].options.rotation = angle;\n        labels[idx].reflow(new Box());\n      }\n      return true;\n    }\n  }\n  arrangeTitle() {\n    const {\n      options,\n      title\n    } = this;\n    const mirror = options.labels.mirror;\n    const vertical = options.vertical;\n    if (title) {\n      if (vertical) {\n        title.options.align = mirror ? RIGHT : LEFT;\n        title.options.vAlign = title.options.position;\n      } else {\n        title.options.align = title.options.position;\n        title.options.vAlign = mirror ? TOP : BOTTOM;\n      }\n      title.reflow(this.box);\n    }\n  }\n  arrangeNotes() {\n    for (let idx = 0; idx < this.notes.length; idx++) {\n      const item = this.notes[idx];\n      const value = item.options.value;\n      let slot;\n      if (defined(value)) {\n        if (this.shouldRenderNote(value)) {\n          item.show();\n        } else {\n          item.hide();\n        }\n        slot = this.noteSlot(value);\n      } else {\n        item.hide();\n      }\n      item.reflow(slot || this.lineBox());\n    }\n  }\n  noteSlot(value) {\n    return this.getSlot(value);\n  }\n  alignTo(secondAxis) {\n    const lineBox = secondAxis.lineBox();\n    const vertical = this.options.vertical;\n    const pos = vertical ? Y : X;\n    this.box.snapTo(lineBox, pos);\n    if (vertical) {\n      this.box.shrink(0, this.lineBox().height() - lineBox.height());\n    } else {\n      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n    }\n    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n  }\n  axisLabelText(value, options, context) {\n    let text;\n    const tmpl = getTemplate(options);\n    const defaultText = () => {\n      if (!options.format) {\n        return value;\n      }\n      return this.chartService.format.localeAuto(options.format, [value], options.culture);\n    };\n    if (tmpl) {\n      const templateContext = Object.assign({}, context, {\n        get text() {\n          return defaultText();\n        },\n        value,\n        format: options.format,\n        culture: options.culture\n      });\n      text = tmpl(templateContext);\n    } else {\n      text = defaultText();\n    }\n    return text;\n  }\n  slot(from, to, limit) {\n    const slot = this.getSlot(from, to, limit);\n    if (slot) {\n      return slot.toRect();\n    }\n  }\n  contentBox() {\n    const box = this.box.clone();\n    const labels = this.labels;\n    if (labels.length) {\n      const axis = this.options.vertical ? Y : X;\n      if (this.chartService.isPannable(axis)) {\n        const offset = this.maxLabelOffset();\n        box[axis + 1] -= offset.start;\n        box[axis + 2] += offset.end;\n      } else {\n        if (labels[0].options.visible) {\n          box.wrap(labels[0].box);\n        }\n        const lastLabel = labels[labels.length - 1];\n        if (lastLabel.options.visible) {\n          box.wrap(lastLabel.box);\n        }\n      }\n    }\n    return box;\n  }\n  maxLabelOffset() {\n    const {\n      vertical,\n      reverse\n    } = this.options;\n    const labelsBetweenTicks = this.labelsBetweenTicks();\n    const tickPositions = this.getLabelsTickPositions();\n    const offsetField = vertical ? Y : X;\n    const labels = this.labels;\n    const startPosition = reverse ? 1 : 0;\n    const endPosition = reverse ? 0 : 1;\n    let maxStartOffset = 0;\n    let maxEndOffset = 0;\n    for (let idx = 0; idx < labels.length; idx++) {\n      const label = labels[idx];\n      const tickIx = this.labelTickIndex(label);\n      let startTick, endTick;\n      if (labelsBetweenTicks) {\n        startTick = tickPositions[tickIx + startPosition];\n        endTick = tickPositions[tickIx + endPosition];\n      } else {\n        startTick = endTick = tickPositions[tickIx];\n      }\n      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n    }\n    return {\n      start: maxStartOffset,\n      end: maxEndOffset\n    };\n  }\n  limitRange(from, to, min, max, offset) {\n    const options = this.options;\n    if (from < min && offset < 0 && (!defined(options.min) || options.min <= min) || max < to && offset > 0 && (!defined(options.max) || max <= options.max)) {\n      return null;\n    }\n    if (to < min && offset > 0 || max < from && offset < 0) {\n      return {\n        min: from,\n        max: to\n      };\n    }\n    const rangeSize = to - from;\n    let minValue = from;\n    let maxValue = to;\n    if (from < min && offset < 0) {\n      minValue = limitValue(from, min, max);\n      maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n    } else if (to > max && offset > 0) {\n      maxValue = limitValue(to, min, max);\n      minValue = limitValue(to - rangeSize, min, max - rangeSize);\n    }\n    return {\n      min: minValue,\n      max: maxValue\n    };\n  }\n  valueRange() {\n    return {\n      min: this.seriesMin,\n      max: this.seriesMax\n    };\n  }\n  lineDir() {\n    /*\n     * Axis line direction:\n     *   * Vertical: up.\n     *   * Horizontal: right.\n     */\n\n    const {\n      vertical,\n      reverse\n    } = this.options;\n    return (vertical ? -1 : 1) * (reverse ? -1 : 1);\n  }\n  lineInfo() {\n    const {\n      vertical\n    } = this.options;\n    const lineBox = this.lineBox();\n    const lineSize = vertical ? lineBox.height() : lineBox.width();\n    const axis = vertical ? Y : X;\n    const axisDir = this.lineDir();\n    const startEdge = axisDir === 1 ? 1 : 2;\n    const axisOrigin = axis + startEdge.toString();\n    const lineStart = lineBox[axisOrigin];\n    return {\n      axis,\n      axisOrigin,\n      axisDir,\n      lineBox,\n      lineSize,\n      lineStart\n    };\n  }\n  pointOffset(point) {\n    const {\n      axis,\n      axisDir,\n      axisOrigin,\n      lineBox,\n      lineSize\n    } = this.lineInfo();\n    const relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];\n    const offset = relative / lineSize;\n    return offset;\n  }\n\n  // Computes the axis range change (delta) for a given scale factor.\n  // The delta is subtracted from the axis range:\n  //   * delta > 0 reduces the axis range (zoom-in)\n  //   * delta < 0 expands the axis range (zoom-out)\n  scaleToDelta(rawScale, range) {\n    // Scale >= 1 would result in axis range of 0.\n    // Scale <= -1 would reverse the scale direction.\n    const MAX_SCALE = 0.999;\n    const scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);\n    let delta;\n    if (scale > 0) {\n      delta = range * Math.min(1, scale);\n    } else {\n      delta = range - range / (1 + scale);\n    }\n    return delta;\n  }\n  labelsBetweenTicks() {\n    return !this.options.justified;\n  }\n\n  //add legacy fields to the options that are no longer generated by default\n  prepareUserOptions() {}\n}\nsetDefaultOptions(Axis, {\n  labels: {\n    visible: true,\n    rotation: 0,\n    mirror: false,\n    step: 1,\n    skip: 0\n  },\n  line: {\n    width: 1,\n    color: BLACK,\n    visible: true\n  },\n  title: {\n    visible: true,\n    position: CENTER\n  },\n  majorTicks: {\n    align: OUTSIDE,\n    size: 4,\n    skip: 0,\n    step: 1\n  },\n  minorTicks: {\n    align: OUTSIDE,\n    size: 3,\n    skip: 0,\n    step: 1\n  },\n  axisCrossingValue: 0,\n  majorTickType: OUTSIDE,\n  minorTickType: NONE,\n  majorGridLines: {\n    skip: 0,\n    step: 1\n  },\n  minorGridLines: {\n    visible: false,\n    width: 1,\n    color: BLACK,\n    skip: 0,\n    step: 1\n  },\n  // TODO: Move to line or labels options\n  margin: 5,\n  visible: true,\n  reverse: false,\n  justified: true,\n  notes: {\n    label: {\n      text: \"\"\n    }\n  },\n  _alignLines: true,\n  _deferLabels: false\n});\nexport default Axis;","map":{"version":3,"names":["drawing","draw","geometry","geom","ChartElement","TextBox","AxisLabel","Note","Box","ChartService","createAxisTick","createAxisGridLine","NONE","BLACK","CENTER","TOP","BOTTOM","LEFT","RIGHT","OUTSIDE","X","Y","WIDTH","HEIGHT","alignPathToPixel","deepExtend","getTemplate","grep","defined","isObject","inArray","limitValue","round","setDefaultOptions","Axis","constructor","options","chartService","visible","labels","line","margin","majorTickSize","minorTickSize","minorTicks","color","width","minorTickType","size","align","majorTicks","majorTickType","initFields","_deferLabels","createLabels","createTitle","createNotes","labelsRange","min","skip","max","labelsCount","normalizeLabelRotation","labelOptions","rotation","alignRotation","angle","vertical","zIndex","step","Math","clearLabels","autoRotateLabels","range","idx","labelContext","index","count","label","createAxisLabel","append","push","children","child","clearTitle","title","undefined","clear","lineBox","box","mirror","axisX","x1","x2","axisY","y2","y1","lineWidth","titleOptions","text","visualSize","notes","items","data","i","length","item","value","parseNoteValue","note","dataItem","position","reverse","renderVisual","createPlotBands","createVisual","createBackground","createLine","gridLinesVisual","gridLines","_gridLines","Group","appendVisual","createTicks","lineGroup","majorUnit","tickLineOptions","render","tickPositions","tickOptions","skipUnit","tickX","tickY","getMajorTickPositions","getMinorTickPositions","minorUnit","path","Path","stroke","dashType","moveTo","lineTo","_alignLines","group","_lineGroup","visual","getActualTickSize","tickSize","background","_backgroundPath","fromRect","toRect","fill","plotBands","plotArea","_plotbandGroup","altAxis","pane","axes","axis","slotX","slotY","getSlot","from","to","vAlign","createPlotBandLabel","height","bandRect","Rect","opacity","textbox","labelTemplate","format","auto","reflow","createGridLines","minorGridLines","majorGridLines","axisLineVisible","linePos","lineOptions","lineStart","lineEnd","container","gridLine","pos","sizeFn","titleSize","space","rootBox","getRoot","boxSize","maxLabelSize","labelSize","arrangeTitle","arrangeLabels","arrangeNotes","getLabelsTickPositions","labelTickIndex","labelsBetweenTicks","tickIx","firstTickPosition","nextTickPosition","positionStart","positionEnd","middle","positionLabel","labelOffset","labelBox","labelX","rotationOrigin","move","labelY","autoRotateLabelAngle","slotWidth","limit","abs","labelAngle","slot","shouldRenderNote","show","hide","noteSlot","alignTo","secondAxis","snapTo","shrink","axisLabelText","context","tmpl","defaultText","localeAuto","culture","templateContext","Object","assign","contentBox","clone","isPannable","offset","maxLabelOffset","start","end","wrap","lastLabel","offsetField","startPosition","endPosition","maxStartOffset","maxEndOffset","startTick","endTick","limitRange","rangeSize","minValue","maxValue","valueRange","seriesMin","seriesMax","lineDir","lineInfo","lineSize","axisDir","startEdge","axisOrigin","toString","pointOffset","point","relative","scaleToDelta","rawScale","MAX_SCALE","scale","delta","justified","prepareUserOptions","axisCrossingValue"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/core/axis.js"],"sourcesContent":["import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\n\nimport ChartElement from './chart-element';\nimport TextBox from './text-box';\nimport AxisLabel from './axis-label';\nimport Note from './note';\nimport Box from './box';\nimport { ChartService } from '../services';\n\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\n\nimport { NONE, BLACK, CENTER, TOP, BOTTOM, LEFT, RIGHT, OUTSIDE, X, Y, WIDTH, HEIGHT } from '../common/constants';\nimport { alignPathToPixel, deepExtend, getTemplate, grep, defined, isObject, inArray, limitValue, round, setDefaultOptions } from '../common';\n\nclass Axis extends ChartElement {\n    constructor(options, chartService = new ChartService()) {\n        super(options);\n\n        this.chartService = chartService;\n\n        if (!this.options.visible) {\n            this.options = deepExtend({}, this.options, {\n                labels: {\n                    visible: false\n                },\n                line: {\n                    visible: false\n                },\n                margin: 0,\n                majorTickSize: 0,\n                minorTickSize: 0\n            });\n        }\n\n        this.options.minorTicks = deepExtend({}, {\n            color: this.options.line.color,\n            width: this.options.line.width,\n            visible: this.options.minorTickType !== NONE\n        }, this.options.minorTicks, {\n            size: this.options.minorTickSize,\n            align: this.options.minorTickType\n        });\n\n        this.options.majorTicks = deepExtend({}, {\n            color: this.options.line.color,\n            width: this.options.line.width,\n            visible: this.options.majorTickType !== NONE\n        }, this.options.majorTicks, {\n            size: this.options.majorTickSize,\n            align: this.options.majorTickType\n        });\n\n        this.initFields();\n\n        if (!this.options._deferLabels) {\n            this.createLabels();\n        }\n\n        this.createTitle();\n        this.createNotes();\n    }\n\n    initFields() {\n    }\n\n    // abstract labelsCount(): Number\n    // abstract createAxisLabel(index, options): AxisLabel\n\n    labelsRange() {\n        return {\n            min: this.options.labels.skip,\n            max: this.labelsCount()\n        };\n    }\n\n    normalizeLabelRotation(labelOptions) {\n        const rotation = labelOptions.rotation;\n\n        if (isObject(rotation)) {\n            labelOptions.alignRotation = rotation.align;\n            labelOptions.rotation = rotation.angle;\n        }\n    }\n\n    createLabels() {\n        const options = this.options;\n        const align = options.vertical ? RIGHT : CENTER;\n        const labelOptions = deepExtend({ }, options.labels, {\n            align: align,\n            zIndex: options.zIndex\n        });\n        const step = Math.max(1, labelOptions.step);\n\n        this.clearLabels();\n\n        if (labelOptions.visible) {\n            this.normalizeLabelRotation(labelOptions);\n            if (labelOptions.rotation === \"auto\") {\n                labelOptions.rotation = 0;\n                options.autoRotateLabels = true;\n            }\n\n            const range = this.labelsRange();\n            for (let idx = range.min; idx < range.max; idx += step) {\n                const labelContext = { index: idx, count: range.max };\n                let label = this.createAxisLabel(idx, labelOptions, labelContext);\n                if (label) {\n                    this.append(label);\n                    this.labels.push(label);\n                }\n            }\n        }\n    }\n\n    clearLabels() {\n        this.children = grep(this.children, child => !(child instanceof AxisLabel));\n        this.labels = [];\n    }\n\n    clearTitle() {\n        if (this.title) {\n            this.children = grep(this.children, child => child !== this.title);\n            this.title = undefined;\n        }\n    }\n\n    clear() {\n        this.clearLabels();\n        this.clearTitle();\n    }\n\n    lineBox() {\n        const { options, box } = this;\n        const vertical = options.vertical;\n        const mirror = options.labels.mirror;\n        const axisX = mirror ? box.x1 : box.x2;\n        const axisY = mirror ? box.y2 : box.y1;\n        const lineWidth = options.line.width || 0;\n\n        return vertical ?\n            new Box(axisX, box.y1, axisX, box.y2 - lineWidth) :\n            new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n    }\n\n    createTitle() {\n        const options = this.options;\n        const titleOptions = deepExtend({\n            rotation: options.vertical ? -90 : 0,\n            text: \"\",\n            zIndex: 1,\n            visualSize: true\n        }, options.title);\n\n        if (titleOptions.visible && titleOptions.text) {\n            const title = new TextBox(titleOptions.text, titleOptions);\n            this.append(title);\n            this.title = title;\n        }\n    }\n\n    createNotes() {\n        const options = this.options;\n        const notes = options.notes;\n        const items = notes.data || [];\n\n        this.notes = [];\n\n        for (let i = 0; i < items.length; i++) {\n            const item = deepExtend({}, notes, items[i]);\n            item.value = this.parseNoteValue(item.value);\n\n            const note = new Note({\n                value: item.value,\n                text: item.label.text,\n                dataItem: item\n            }, item, this.chartService);\n\n            if (note.options.visible) {\n                if (defined(note.options.position)) {\n                    if (options.vertical && !inArray(note.options.position, [ LEFT, RIGHT ])) {\n                        note.options.position = options.reverse ? LEFT : RIGHT;\n                    } else if (!options.vertical && !inArray(note.options.position, [ TOP, BOTTOM ])) {\n                        note.options.position = options.reverse ? BOTTOM : TOP;\n                    }\n                } else {\n                    if (options.vertical) {\n                        note.options.position = options.reverse ? LEFT : RIGHT;\n                    } else {\n                        note.options.position = options.reverse ? BOTTOM : TOP;\n                    }\n                }\n                this.append(note);\n                this.notes.push(note);\n            }\n        }\n    }\n\n    parseNoteValue(value) {\n        return value;\n    }\n\n    renderVisual() {\n        super.renderVisual();\n\n        this.createPlotBands();\n    }\n\n    createVisual() {\n        super.createVisual();\n\n        this.createBackground();\n        this.createLine();\n    }\n\n    gridLinesVisual() {\n        let gridLines = this._gridLines;\n        if (!gridLines) {\n            gridLines = this._gridLines = new draw.Group({\n                zIndex: -2\n            });\n            this.appendVisual(this._gridLines);\n        }\n\n        return gridLines;\n    }\n\n    createTicks(lineGroup) {\n        const options = this.options;\n        const lineBox = this.lineBox();\n        const mirror = options.labels.mirror;\n        const majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n        const tickLineOptions = {\n            // TODO\n            // _alignLines: options._alignLines,\n            vertical: options.vertical\n        };\n\n        function render(tickPositions, tickOptions, skipUnit) {\n            const count = tickPositions.length;\n            const step = Math.max(1, tickOptions.step);\n\n            if (tickOptions.visible) {\n                for (let i = tickOptions.skip; i < count; i += step) {\n                    if (defined(skipUnit) && (i % skipUnit === 0)) {\n                        continue;\n                    }\n\n                    tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n                    tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n                    tickLineOptions.position = tickPositions[i];\n\n                    lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n                }\n            }\n        }\n\n        render(this.getMajorTickPositions(), options.majorTicks);\n        render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n    }\n\n    createLine() {\n        const options = this.options;\n        const line = options.line;\n        const lineBox = this.lineBox();\n\n        if (line.width > 0 && line.visible) {\n            const path = new draw.Path({\n                stroke: {\n                    width: line.width,\n                    color: line.color,\n                    dashType: line.dashType\n                }\n\n                /* TODO\n                zIndex: line.zIndex,\n                */\n            });\n\n            path.moveTo(lineBox.x1, lineBox.y1)\n                .lineTo(lineBox.x2, lineBox.y2);\n\n            if (options._alignLines) {\n                alignPathToPixel(path);\n            }\n\n            const group = this._lineGroup = new draw.Group();\n            group.append(path);\n\n            this.visual.append(group);\n            this.createTicks(group);\n        }\n    }\n\n    getActualTickSize() {\n        const options = this.options;\n        let tickSize = 0;\n\n        if (options.majorTicks.visible && options.minorTicks.visible) {\n            tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n        } else if (options.majorTicks.visible) {\n            tickSize = options.majorTicks.size;\n        } else if (options.minorTicks.visible) {\n            tickSize = options.minorTicks.size;\n        }\n\n        return tickSize;\n    }\n\n    createBackground() {\n        const { options, box } = this;\n        const background = options.background;\n\n        if (background) {\n            this._backgroundPath = draw.Path.fromRect(box.toRect(), {\n                fill: {\n                    color: background\n                },\n                stroke: null\n            });\n\n            this.visual.append(this._backgroundPath);\n        }\n    }\n\n    createPlotBands() {\n        const options = this.options;\n        const plotBands = options.plotBands || [];\n        const vertical = options.vertical;\n        const plotArea = this.plotArea;\n\n        if (plotBands.length === 0) {\n            return;\n        }\n\n        const group = this._plotbandGroup = new draw.Group({\n            zIndex: -1\n        });\n\n        const altAxis = grep(this.pane.axes, axis => axis.options.vertical !== this.options.vertical)[0];\n\n        for (let idx = 0; idx < plotBands.length; idx++) {\n            let item = plotBands[idx];\n            let slotX, slotY;\n            let labelOptions = item.label;\n            let label;\n\n            if (vertical) {\n                slotX = (altAxis || plotArea.axisX).lineBox();\n                slotY = this.getSlot(item.from, item.to, true);\n            } else {\n                slotX = this.getSlot(item.from, item.to, true);\n                slotY = (altAxis || plotArea.axisY).lineBox();\n            }\n\n            if (labelOptions) {\n                labelOptions.vAlign = labelOptions.position || LEFT;\n                label = this.createPlotBandLabel(\n                    labelOptions,\n                    item,\n                    new Box(\n                        slotX.x1,\n                        slotY.y1,\n                        slotX.x2,\n                        slotY.y2\n                    )\n\n                );\n            }\n\n            if (slotX.width() !== 0 && slotY.height() !== 0) {\n                const bandRect = new geom.Rect(\n                    [ slotX.x1, slotY.y1 ],\n                    [ slotX.width(), slotY.height() ]\n                );\n\n                const path = draw.Path.fromRect(bandRect, {\n                    fill: {\n                        color: item.color,\n                        opacity: item.opacity\n                    },\n                    stroke: null\n                });\n\n                group.append(path);\n                if (label) {\n                    group.append(label);\n                }\n            }\n        }\n\n        this.appendVisual(group);\n    }\n\n    createPlotBandLabel(label, item, box) {\n\n        if (label.visible === false) {\n            return null;\n        }\n\n        let text = label.text;\n        let textbox;\n\n        if (defined(label) && label.visible) {\n            const labelTemplate = getTemplate(label);\n            if (labelTemplate) {\n                text = labelTemplate({ text: text, item: item });\n            } else if (label.format) {\n                text = this.chartService.format.auto(label.format, text);\n            }\n\n            if (!label.color) {\n                label.color = this.options.labels.color;\n            }\n        }\n\n        textbox = new TextBox(text, label);\n        textbox.reflow(box);\n        textbox.renderVisual();\n\n        return textbox.visual;\n    }\n\n    createGridLines(altAxis) {\n        const options = this.options;\n        const { minorGridLines, majorGridLines, minorUnit, vertical } = options;\n        const axisLineVisible = altAxis.options.line.visible;\n        const majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n        const lineBox = altAxis.lineBox();\n        const linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n        const lineOptions = {\n            lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n            lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n            vertical: vertical\n        };\n        const majorTicks = [];\n\n        const container = this.gridLinesVisual();\n\n        function render(tickPositions, gridLine, skipUnit) {\n            const count = tickPositions.length;\n            const step = Math.max(1, gridLine.step);\n\n            if (gridLine.visible) {\n                for (let i = gridLine.skip; i < count; i += step) {\n                    let pos = round(tickPositions[i]);\n                    if (!inArray(pos, majorTicks)) {\n                        if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n                            lineOptions.position = pos;\n                            container.append(createAxisGridLine(lineOptions, gridLine));\n\n                            majorTicks.push(pos);\n                        }\n                    }\n                }\n            }\n        }\n\n        render(this.getMajorTickPositions(), majorGridLines);\n        render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n\n        return container.children;\n    }\n\n    reflow(box) {\n        const { options, labels, title } = this;\n        const vertical = options.vertical;\n        const count = labels.length;\n        const sizeFn = vertical ? WIDTH : HEIGHT;\n        const titleSize = title ? title.box[sizeFn]() : 0;\n        const space = this.getActualTickSize() + options.margin + titleSize;\n        const rootBox = (this.getRoot() || {}).box || box;\n        const boxSize = rootBox[sizeFn]();\n        let maxLabelSize = 0;\n\n        for (let i = 0; i < count; i++) {\n            let labelSize = labels[i].box[sizeFn]();\n            if (labelSize + space <= boxSize) {\n                maxLabelSize = Math.max(maxLabelSize, labelSize);\n            }\n        }\n\n        if (vertical) {\n            this.box = new Box(\n                box.x1, box.y1,\n                box.x1 + maxLabelSize + space, box.y2\n            );\n        } else {\n            this.box = new Box(\n                box.x1, box.y1,\n                box.x2, box.y1 + maxLabelSize + space\n            );\n        }\n\n        this.arrangeTitle();\n        this.arrangeLabels();\n        this.arrangeNotes();\n    }\n\n    getLabelsTickPositions() {\n        return this.getMajorTickPositions();\n    }\n\n    labelTickIndex(label) {\n        return label.index;\n    }\n\n    arrangeLabels() {\n        const { options, labels } = this;\n        const labelsBetweenTicks = this.labelsBetweenTicks();\n        const vertical = options.vertical;\n        const mirror = options.labels.mirror;\n        const tickPositions = this.getLabelsTickPositions();\n\n        for (let idx = 0; idx < labels.length; idx++) {\n            const label = labels[idx];\n            const tickIx = this.labelTickIndex(label);\n            const labelSize = vertical ? label.box.height() : label.box.width();\n            const firstTickPosition = tickPositions[tickIx];\n            const nextTickPosition = tickPositions[tickIx + 1];\n            let positionStart, positionEnd;\n\n            if (vertical) {\n                if (labelsBetweenTicks) {\n                    const middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n                    positionStart = middle - (labelSize / 2);\n                } else {\n                    positionStart = firstTickPosition - (labelSize / 2);\n                }\n\n                positionEnd = positionStart;\n            } else {\n                if (labelsBetweenTicks) {\n                    positionStart = firstTickPosition;\n                    positionEnd = nextTickPosition;\n                } else {\n                    positionStart = firstTickPosition - (labelSize / 2);\n                    positionEnd = positionStart + labelSize;\n                }\n            }\n\n            this.positionLabel(label, mirror, positionStart, positionEnd);\n        }\n    }\n\n    positionLabel(label, mirror, positionStart, positionEnd = positionStart) {\n        const options = this.options;\n        const vertical = options.vertical;\n        const lineBox = this.lineBox();\n        const labelOffset = this.getActualTickSize() + options.margin;\n        let labelBox;\n\n        if (vertical) {\n            let labelX = lineBox.x2;\n\n            if (mirror) {\n                labelX += labelOffset;\n                label.options.rotationOrigin = LEFT;\n            } else {\n                labelX -= labelOffset + label.box.width();\n                label.options.rotationOrigin = RIGHT;\n            }\n\n            labelBox = label.box.move(labelX, positionStart);\n        } else {\n            let labelY = lineBox.y1;\n\n            if (mirror) {\n                labelY -= labelOffset + label.box.height();\n                label.options.rotationOrigin = BOTTOM;\n            } else {\n                labelY += labelOffset;\n                label.options.rotationOrigin = TOP;\n            }\n\n            labelBox = new Box(\n                positionStart, labelY,\n                positionEnd, labelY + label.box.height()\n            );\n        }\n\n        label.reflow(labelBox);\n    }\n\n    autoRotateLabelAngle(labelBox, slotWidth) {\n        if (labelBox.width() < slotWidth) {\n            return 0;\n        }\n\n        if (labelBox.height() > slotWidth) {\n            return -90;\n        }\n\n        return -45;\n    }\n\n    autoRotateLabels() {\n        if (!this.options.autoRotateLabels || this.options.vertical) {\n            return false;\n        }\n\n        const tickPositions = this.getMajorTickPositions();\n        const labels = this.labels;\n        const limit = Math.min(labels.length, tickPositions.length - 1);\n        let angle = 0;\n\n        for (let idx = 0; idx < limit; idx++) {\n            const width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n            const labelBox = labels[idx].box;\n            const labelAngle = this.autoRotateLabelAngle(labelBox, width);\n\n            if (labelAngle !== 0) {\n                angle = labelAngle;\n            }\n\n            if (angle === -90) {\n                break;\n            }\n        }\n\n        if (angle !== 0) {\n            for (let idx = 0; idx < labels.length; idx++) {\n                labels[idx].options.rotation = angle;\n                labels[idx].reflow(new Box());\n            }\n\n            return true;\n        }\n    }\n\n    arrangeTitle() {\n        const { options, title } = this;\n        const mirror = options.labels.mirror;\n        const vertical = options.vertical;\n\n        if (title) {\n            if (vertical) {\n                title.options.align = mirror ? RIGHT : LEFT;\n                title.options.vAlign = title.options.position;\n            } else {\n                title.options.align = title.options.position;\n                title.options.vAlign = mirror ? TOP : BOTTOM;\n            }\n\n            title.reflow(this.box);\n        }\n    }\n\n    arrangeNotes() {\n        for (let idx = 0; idx < this.notes.length; idx++) {\n            const item = this.notes[idx];\n            const value = item.options.value;\n            let slot;\n\n            if (defined(value)) {\n                if (this.shouldRenderNote(value)) {\n                    item.show();\n                } else {\n                    item.hide();\n                }\n\n                slot = this.noteSlot(value);\n            } else {\n                item.hide();\n            }\n\n            item.reflow(slot || this.lineBox());\n        }\n    }\n\n    noteSlot(value) {\n        return this.getSlot(value);\n    }\n\n    alignTo(secondAxis) {\n        const lineBox = secondAxis.lineBox();\n        const vertical = this.options.vertical;\n        const pos = vertical ? Y : X;\n\n        this.box.snapTo(lineBox, pos);\n        if (vertical) {\n            this.box.shrink(0, this.lineBox().height() - lineBox.height());\n        } else {\n            this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n        }\n        this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n        this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n    }\n\n    axisLabelText(value, options, context) {\n        let text;\n        const tmpl = getTemplate(options);\n        const defaultText = () => {\n            if (!options.format) {\n                return value;\n            }\n\n            return this.chartService.format.localeAuto(\n                options.format, [ value ], options.culture\n            );\n        };\n\n        if (tmpl) {\n            const templateContext = Object.assign({}, context, {\n                get text() { return defaultText(); },\n                value,\n                format: options.format,\n                culture: options.culture\n            });\n\n            text = tmpl(templateContext);\n        } else {\n            text = defaultText();\n        }\n\n        return text;\n    }\n\n    slot(from , to, limit) {\n        const slot = this.getSlot(from, to, limit);\n        if (slot) {\n            return slot.toRect();\n        }\n    }\n\n    contentBox() {\n        const box = this.box.clone();\n        const labels = this.labels;\n        if (labels.length) {\n            const axis = this.options.vertical ? Y : X;\n            if (this.chartService.isPannable(axis)) {\n                const offset = this.maxLabelOffset();\n                box[axis + 1] -= offset.start;\n                box[axis + 2] += offset.end;\n            } else {\n                if (labels[0].options.visible) {\n                    box.wrap(labels[0].box);\n                }\n                const lastLabel = labels[labels.length - 1];\n                if (lastLabel.options.visible) {\n                    box.wrap(lastLabel.box);\n                }\n            }\n        }\n\n        return box;\n    }\n\n    maxLabelOffset() {\n        const { vertical, reverse } = this.options;\n        const labelsBetweenTicks = this.labelsBetweenTicks();\n        const tickPositions = this.getLabelsTickPositions();\n        const offsetField = vertical ? Y : X;\n        const labels = this.labels;\n        const startPosition = reverse ? 1 : 0;\n        const endPosition = reverse ? 0 : 1;\n        let maxStartOffset = 0;\n        let maxEndOffset = 0;\n\n        for (let idx = 0; idx < labels.length; idx++) {\n            const label = labels[idx];\n            const tickIx = this.labelTickIndex(label);\n            let startTick, endTick;\n\n            if (labelsBetweenTicks) {\n                startTick = tickPositions[tickIx + startPosition];\n                endTick = tickPositions[tickIx + endPosition];\n            } else {\n                startTick = endTick = tickPositions[tickIx];\n            }\n\n            maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n            maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n        }\n\n        return {\n            start: maxStartOffset,\n            end: maxEndOffset\n        };\n    }\n\n    limitRange(from, to, min, max, offset) {\n        const options = this.options;\n\n        if ((from < min && offset < 0 && (!defined(options.min) || options.min <= min)) || (max < to && offset > 0 && (!defined(options.max) || max <= options.max))) {\n            return null;\n        }\n\n        if ((to < min && offset > 0) || (max < from && offset < 0)) {\n            return {\n                min: from,\n                max: to\n            };\n        }\n\n        const rangeSize = to - from;\n        let minValue = from;\n        let maxValue = to;\n\n        if (from < min && offset < 0) {\n            minValue = limitValue(from, min, max);\n            maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n        } else if (to > max && offset > 0) {\n            maxValue = limitValue(to, min, max);\n            minValue = limitValue(to - rangeSize, min, max - rangeSize);\n        }\n\n        return {\n            min: minValue,\n            max: maxValue\n        };\n    }\n\n    valueRange() {\n        return {\n            min: this.seriesMin,\n            max: this.seriesMax\n        };\n    }\n\n    lineDir() {\n        /*\n         * Axis line direction:\n         *   * Vertical: up.\n         *   * Horizontal: right.\n         */\n\n        const { vertical, reverse } = this.options;\n        return (vertical ? -1 : 1) * (reverse ? -1 : 1);\n    }\n\n    lineInfo() {\n        const { vertical } = this.options;\n        const lineBox = this.lineBox();\n        const lineSize = vertical ? lineBox.height() : lineBox.width();\n        const axis = vertical ? Y : X;\n        const axisDir = this.lineDir();\n        const startEdge = axisDir === 1 ? 1 : 2;\n        const axisOrigin = axis + startEdge.toString();\n        const lineStart = lineBox[axisOrigin];\n\n        return {\n            axis,\n            axisOrigin,\n            axisDir,\n            lineBox,\n            lineSize,\n            lineStart\n        };\n    }\n\n    pointOffset(point) {\n        const { axis, axisDir, axisOrigin, lineBox, lineSize } = this.lineInfo();\n        const relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];\n        const offset = relative / lineSize;\n\n        return offset;\n    }\n\n    // Computes the axis range change (delta) for a given scale factor.\n    // The delta is subtracted from the axis range:\n    //   * delta > 0 reduces the axis range (zoom-in)\n    //   * delta < 0 expands the axis range (zoom-out)\n    scaleToDelta(rawScale, range) {\n        // Scale >= 1 would result in axis range of 0.\n        // Scale <= -1 would reverse the scale direction.\n        const MAX_SCALE = 0.999;\n        const scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);\n\n        let delta;\n        if (scale > 0) {\n            delta = range * Math.min(1, scale);\n        } else {\n            delta = range - (range / (1 + scale));\n        }\n\n        return delta;\n    }\n\n    labelsBetweenTicks() {\n        return !this.options.justified;\n    }\n\n    //add legacy fields to the options that are no longer generated by default\n    prepareUserOptions() {\n    }\n}\n\nsetDefaultOptions(Axis, {\n    labels: {\n        visible: true,\n        rotation: 0,\n        mirror: false,\n        step: 1,\n        skip: 0\n    },\n    line: {\n        width: 1,\n        color: BLACK,\n        visible: true\n    },\n    title: {\n        visible: true,\n        position: CENTER\n    },\n    majorTicks: {\n        align: OUTSIDE,\n        size: 4,\n        skip: 0,\n        step: 1\n    },\n    minorTicks: {\n        align: OUTSIDE,\n        size: 3,\n        skip: 0,\n        step: 1\n    },\n    axisCrossingValue: 0,\n    majorTickType: OUTSIDE,\n    minorTickType: NONE,\n    majorGridLines: {\n        skip: 0,\n        step: 1\n    },\n    minorGridLines: {\n        visible: false,\n        width: 1,\n        color: BLACK,\n        skip: 0,\n        step: 1\n    },\n    // TODO: Move to line or labels options\n    margin: 5,\n    visible: true,\n    reverse: false,\n    justified: true,\n    notes: {\n        label: {\n            text: \"\"\n        }\n    },\n\n    _alignLines: true,\n    _deferLabels: false\n});\n\nexport default Axis;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}