{"ast":null,"code":"import Class from '../class';\nimport namedColors from './named-colors';\nimport { Bytes, RGB, HSV, HSL } from './parse-color';\nconst DARK_TRESHOLD = 180;\nclass Color extends Class {\n  constructor(value) {\n    super();\n    if (arguments.length === 1) {\n      const formats = Color.formats;\n      const resolvedColor = this.resolveColor(value);\n      for (let idx = 0; idx < formats.length; idx++) {\n        const formatRegex = formats[idx].re;\n        const processor = formats[idx].process;\n        const parts = formatRegex.exec(resolvedColor);\n        if (parts) {\n          const channels = processor(parts);\n          this.r = channels[0];\n          this.g = channels[1];\n          this.b = channels[2];\n        }\n      }\n    } else {\n      this.r = arguments[0];\n      this.g = arguments[1];\n      this.b = arguments[2];\n    }\n    this.r = this.normalizeByte(this.r);\n    this.g = this.normalizeByte(this.g);\n    this.b = this.normalizeByte(this.b);\n  }\n  toHex() {\n    const pad = this.padDigit;\n    const r = this.r.toString(16);\n    const g = this.g.toString(16);\n    const b = this.b.toString(16);\n    return \"#\" + pad(r) + pad(g) + pad(b);\n  }\n  resolveColor(value) {\n    let color = value || \"black\";\n    if (color.charAt(0) === \"#\") {\n      color = color.substr(1, 6);\n    }\n    color = color.replace(/ /g, \"\");\n    color = color.toLowerCase();\n    color = Color.namedColors[color] || color;\n    return color;\n  }\n  normalizeByte(value) {\n    if (value < 0 || isNaN(value)) {\n      return 0;\n    }\n    return value > 255 ? 255 : value;\n  }\n  padDigit(value) {\n    return value.length === 1 ? \"0\" + value : value;\n  }\n  brightness(value) {\n    const round = Math.round;\n    this.r = round(this.normalizeByte(this.r * value));\n    this.g = round(this.normalizeByte(this.g * value));\n    this.b = round(this.normalizeByte(this.b * value));\n    return this;\n  }\n  percBrightness() {\n    return Math.sqrt(0.241 * this.r * this.r + 0.691 * this.g * this.g + 0.068 * this.b * this.b);\n  }\n  isDark() {\n    return this.percBrightness() < DARK_TRESHOLD;\n  }\n  static fromBytes(r, g, b, a) {\n    return new Bytes(r, g, b, a != null ? a : 1);\n  }\n  static fromRGB(r, g, b, a) {\n    return new RGB(r, g, b, a != null ? a : 1);\n  }\n  static fromHSV(h, s, v, a) {\n    return new HSV(h, s, v, a != null ? a : 1);\n  }\n  static fromHSL(h, s, l, a) {\n    return new HSL(h, s, l, a != null ? a : 1);\n  }\n}\nColor.formats = [{\n  re: /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/,\n  process: function (parts) {\n    return [parseInt(parts[1], 10), parseInt(parts[2], 10), parseInt(parts[3], 10)];\n  }\n}, {\n  re: /^(\\w{2})(\\w{2})(\\w{2})$/,\n  process: function (parts) {\n    return [parseInt(parts[1], 16), parseInt(parts[2], 16), parseInt(parts[3], 16)];\n  }\n}, {\n  re: /^(\\w{1})(\\w{1})(\\w{1})$/,\n  process: function (parts) {\n    return [parseInt(parts[1] + parts[1], 16), parseInt(parts[2] + parts[2], 16), parseInt(parts[3] + parts[3], 16)];\n  }\n}];\nColor.namedColors = namedColors;\nexport default Color;","map":{"version":3,"names":["Class","namedColors","Bytes","RGB","HSV","HSL","DARK_TRESHOLD","Color","constructor","value","arguments","length","formats","resolvedColor","resolveColor","idx","formatRegex","re","processor","process","parts","exec","channels","r","g","b","normalizeByte","toHex","pad","padDigit","toString","color","charAt","substr","replace","toLowerCase","isNaN","brightness","round","Math","percBrightness","sqrt","isDark","fromBytes","a","fromRGB","fromHSV","h","s","v","fromHSL","l","parseInt"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-drawing/dist/es2015/common/color/color.js"],"sourcesContent":["import Class from '../class';\nimport namedColors from './named-colors';\nimport { Bytes, RGB, HSV, HSL } from './parse-color';\n\nconst DARK_TRESHOLD = 180;\n\nclass Color extends Class {\n    constructor(value) {\n        super();\n\n        if (arguments.length === 1) {\n            const formats = Color.formats;\n            const resolvedColor = this.resolveColor(value);\n\n            for (let idx = 0; idx < formats.length; idx++) {\n                const formatRegex = formats[idx].re;\n                const processor = formats[idx].process;\n                const parts = formatRegex.exec(resolvedColor);\n\n                if (parts) {\n                    const channels = processor(parts);\n                    this.r = channels[0];\n                    this.g = channels[1];\n                    this.b = channels[2];\n                }\n            }\n        } else {\n            this.r = arguments[0];\n            this.g = arguments[1];\n            this.b = arguments[2];\n        }\n\n        this.r = this.normalizeByte(this.r);\n        this.g = this.normalizeByte(this.g);\n        this.b = this.normalizeByte(this.b);\n    }\n\n    toHex() {\n        const pad = this.padDigit;\n        const r = this.r.toString(16);\n        const g = this.g.toString(16);\n        const b = this.b.toString(16);\n\n        return \"#\" + pad(r) + pad(g) + pad(b);\n    }\n\n    resolveColor(value) {\n        let color = value || \"black\";\n\n        if (color.charAt(0) === \"#\") {\n            color = color.substr(1, 6);\n        }\n\n        color = color.replace(/ /g, \"\");\n        color = color.toLowerCase();\n        color = Color.namedColors[color] || color;\n\n        return color;\n    }\n\n    normalizeByte(value) {\n        if (value < 0 || isNaN(value)) {\n            return 0;\n        }\n\n        return value > 255 ? 255 : value;\n    }\n\n    padDigit(value) {\n        return (value.length === 1) ? \"0\" + value : value;\n    }\n\n    brightness(value) {\n        const round = Math.round;\n\n        this.r = round(this.normalizeByte(this.r * value));\n        this.g = round(this.normalizeByte(this.g * value));\n        this.b = round(this.normalizeByte(this.b * value));\n\n        return this;\n    }\n\n    percBrightness() {\n        return Math.sqrt(0.241 * this.r * this.r + 0.691 * this.g * this.g + 0.068 * this.b * this.b);\n    }\n\n    isDark() {\n        return this.percBrightness() < DARK_TRESHOLD;\n    }\n\n    static fromBytes(r, g, b, a) {\n        return new Bytes(r, g, b, a != null ? a : 1);\n    }\n\n    static fromRGB(r, g, b, a) {\n        return new RGB(r, g, b, a != null ? a : 1);\n    }\n\n    static fromHSV(h, s, v, a) {\n        return new HSV(h, s, v, a != null ? a : 1);\n    }\n\n    static fromHSL(h, s, l, a) {\n        return new HSL(h, s, l, a != null ? a : 1);\n    }\n}\n\nColor.formats = [ {\n    re: /^rgb\\((\\d{1,3}),\\s*(\\d{1,3}),\\s*(\\d{1,3})\\)$/,\n    process: function(parts) {\n        return [\n            parseInt(parts[1], 10), parseInt(parts[2], 10), parseInt(parts[3], 10)\n        ];\n    }\n}, {\n    re: /^(\\w{2})(\\w{2})(\\w{2})$/,\n    process: function(parts) {\n        return [\n            parseInt(parts[1], 16), parseInt(parts[2], 16), parseInt(parts[3], 16)\n        ];\n    }\n}, {\n    re: /^(\\w{1})(\\w{1})(\\w{1})$/,\n    process: function(parts) {\n        return [\n            parseInt(parts[1] + parts[1], 16),\n            parseInt(parts[2] + parts[2], 16),\n            parseInt(parts[3] + parts[3], 16)\n        ];\n    }\n} ];\n\nColor.namedColors = namedColors;\n\nexport default Color;"],"mappings":"AAAA,OAAOA,KAAK,MAAM,UAAU;AAC5B,OAAOC,WAAW,MAAM,gBAAgB;AACxC,SAASC,KAAK,EAAEC,GAAG,EAAEC,GAAG,EAAEC,GAAG,QAAQ,eAAe;AAEpD,MAAMC,aAAa,GAAG,GAAG;AAEzB,MAAMC,KAAK,SAASP,KAAK,CAAC;EACtBQ,WAAWA,CAACC,KAAK,EAAE;IACf,KAAK,CAAC,CAAC;IAEP,IAAIC,SAAS,CAACC,MAAM,KAAK,CAAC,EAAE;MACxB,MAAMC,OAAO,GAAGL,KAAK,CAACK,OAAO;MAC7B,MAAMC,aAAa,GAAG,IAAI,CAACC,YAAY,CAACL,KAAK,CAAC;MAE9C,KAAK,IAAIM,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGH,OAAO,CAACD,MAAM,EAAEI,GAAG,EAAE,EAAE;QAC3C,MAAMC,WAAW,GAAGJ,OAAO,CAACG,GAAG,CAAC,CAACE,EAAE;QACnC,MAAMC,SAAS,GAAGN,OAAO,CAACG,GAAG,CAAC,CAACI,OAAO;QACtC,MAAMC,KAAK,GAAGJ,WAAW,CAACK,IAAI,CAACR,aAAa,CAAC;QAE7C,IAAIO,KAAK,EAAE;UACP,MAAME,QAAQ,GAAGJ,SAAS,CAACE,KAAK,CAAC;UACjC,IAAI,CAACG,CAAC,GAAGD,QAAQ,CAAC,CAAC,CAAC;UACpB,IAAI,CAACE,CAAC,GAAGF,QAAQ,CAAC,CAAC,CAAC;UACpB,IAAI,CAACG,CAAC,GAAGH,QAAQ,CAAC,CAAC,CAAC;QACxB;MACJ;IACJ,CAAC,MAAM;MACH,IAAI,CAACC,CAAC,GAAGb,SAAS,CAAC,CAAC,CAAC;MACrB,IAAI,CAACc,CAAC,GAAGd,SAAS,CAAC,CAAC,CAAC;MACrB,IAAI,CAACe,CAAC,GAAGf,SAAS,CAAC,CAAC,CAAC;IACzB;IAEA,IAAI,CAACa,CAAC,GAAG,IAAI,CAACG,aAAa,CAAC,IAAI,CAACH,CAAC,CAAC;IACnC,IAAI,CAACC,CAAC,GAAG,IAAI,CAACE,aAAa,CAAC,IAAI,CAACF,CAAC,CAAC;IACnC,IAAI,CAACC,CAAC,GAAG,IAAI,CAACC,aAAa,CAAC,IAAI,CAACD,CAAC,CAAC;EACvC;EAEAE,KAAKA,CAAA,EAAG;IACJ,MAAMC,GAAG,GAAG,IAAI,CAACC,QAAQ;IACzB,MAAMN,CAAC,GAAG,IAAI,CAACA,CAAC,CAACO,QAAQ,CAAC,EAAE,CAAC;IAC7B,MAAMN,CAAC,GAAG,IAAI,CAACA,CAAC,CAACM,QAAQ,CAAC,EAAE,CAAC;IAC7B,MAAML,CAAC,GAAG,IAAI,CAACA,CAAC,CAACK,QAAQ,CAAC,EAAE,CAAC;IAE7B,OAAO,GAAG,GAAGF,GAAG,CAACL,CAAC,CAAC,GAAGK,GAAG,CAACJ,CAAC,CAAC,GAAGI,GAAG,CAACH,CAAC,CAAC;EACzC;EAEAX,YAAYA,CAACL,KAAK,EAAE;IAChB,IAAIsB,KAAK,GAAGtB,KAAK,IAAI,OAAO;IAE5B,IAAIsB,KAAK,CAACC,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;MACzBD,KAAK,GAAGA,KAAK,CAACE,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;IAC9B;IAEAF,KAAK,GAAGA,KAAK,CAACG,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;IAC/BH,KAAK,GAAGA,KAAK,CAACI,WAAW,CAAC,CAAC;IAC3BJ,KAAK,GAAGxB,KAAK,CAACN,WAAW,CAAC8B,KAAK,CAAC,IAAIA,KAAK;IAEzC,OAAOA,KAAK;EAChB;EAEAL,aAAaA,CAACjB,KAAK,EAAE;IACjB,IAAIA,KAAK,GAAG,CAAC,IAAI2B,KAAK,CAAC3B,KAAK,CAAC,EAAE;MAC3B,OAAO,CAAC;IACZ;IAEA,OAAOA,KAAK,GAAG,GAAG,GAAG,GAAG,GAAGA,KAAK;EACpC;EAEAoB,QAAQA,CAACpB,KAAK,EAAE;IACZ,OAAQA,KAAK,CAACE,MAAM,KAAK,CAAC,GAAI,GAAG,GAAGF,KAAK,GAAGA,KAAK;EACrD;EAEA4B,UAAUA,CAAC5B,KAAK,EAAE;IACd,MAAM6B,KAAK,GAAGC,IAAI,CAACD,KAAK;IAExB,IAAI,CAACf,CAAC,GAAGe,KAAK,CAAC,IAAI,CAACZ,aAAa,CAAC,IAAI,CAACH,CAAC,GAAGd,KAAK,CAAC,CAAC;IAClD,IAAI,CAACe,CAAC,GAAGc,KAAK,CAAC,IAAI,CAACZ,aAAa,CAAC,IAAI,CAACF,CAAC,GAAGf,KAAK,CAAC,CAAC;IAClD,IAAI,CAACgB,CAAC,GAAGa,KAAK,CAAC,IAAI,CAACZ,aAAa,CAAC,IAAI,CAACD,CAAC,GAAGhB,KAAK,CAAC,CAAC;IAElD,OAAO,IAAI;EACf;EAEA+B,cAAcA,CAAA,EAAG;IACb,OAAOD,IAAI,CAACE,IAAI,CAAC,KAAK,GAAG,IAAI,CAAClB,CAAC,GAAG,IAAI,CAACA,CAAC,GAAG,KAAK,GAAG,IAAI,CAACC,CAAC,GAAG,IAAI,CAACA,CAAC,GAAG,KAAK,GAAG,IAAI,CAACC,CAAC,GAAG,IAAI,CAACA,CAAC,CAAC;EACjG;EAEAiB,MAAMA,CAAA,EAAG;IACL,OAAO,IAAI,CAACF,cAAc,CAAC,CAAC,GAAGlC,aAAa;EAChD;EAEA,OAAOqC,SAASA,CAACpB,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEmB,CAAC,EAAE;IACzB,OAAO,IAAI1C,KAAK,CAACqB,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEmB,CAAC,IAAI,IAAI,GAAGA,CAAC,GAAG,CAAC,CAAC;EAChD;EAEA,OAAOC,OAAOA,CAACtB,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEmB,CAAC,EAAE;IACvB,OAAO,IAAIzC,GAAG,CAACoB,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEmB,CAAC,IAAI,IAAI,GAAGA,CAAC,GAAG,CAAC,CAAC;EAC9C;EAEA,OAAOE,OAAOA,CAACC,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEL,CAAC,EAAE;IACvB,OAAO,IAAIxC,GAAG,CAAC2C,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEL,CAAC,IAAI,IAAI,GAAGA,CAAC,GAAG,CAAC,CAAC;EAC9C;EAEA,OAAOM,OAAOA,CAACH,CAAC,EAAEC,CAAC,EAAEG,CAAC,EAAEP,CAAC,EAAE;IACvB,OAAO,IAAIvC,GAAG,CAAC0C,CAAC,EAAEC,CAAC,EAAEG,CAAC,EAAEP,CAAC,IAAI,IAAI,GAAGA,CAAC,GAAG,CAAC,CAAC;EAC9C;AACJ;AAEArC,KAAK,CAACK,OAAO,GAAG,CAAE;EACdK,EAAE,EAAE,8CAA8C;EAClDE,OAAO,EAAE,SAAAA,CAASC,KAAK,EAAE;IACrB,OAAO,CACHgC,QAAQ,CAAChC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,EAAEgC,QAAQ,CAAChC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,EAAEgC,QAAQ,CAAChC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CACzE;EACL;AACJ,CAAC,EAAE;EACCH,EAAE,EAAE,yBAAyB;EAC7BE,OAAO,EAAE,SAAAA,CAASC,KAAK,EAAE;IACrB,OAAO,CACHgC,QAAQ,CAAChC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,EAAEgC,QAAQ,CAAChC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,EAAEgC,QAAQ,CAAChC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CACzE;EACL;AACJ,CAAC,EAAE;EACCH,EAAE,EAAE,yBAAyB;EAC7BE,OAAO,EAAE,SAAAA,CAASC,KAAK,EAAE;IACrB,OAAO,CACHgC,QAAQ,CAAChC,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,EACjCgC,QAAQ,CAAChC,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,EACjCgC,QAAQ,CAAChC,KAAK,CAAC,CAAC,CAAC,GAAGA,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CACpC;EACL;AACJ,CAAC,CAAE;AAEHb,KAAK,CAACN,WAAW,GAAGA,WAAW;AAE/B,eAAeM,KAAK"},"metadata":{},"sourceType":"module","externalDependencies":[]}