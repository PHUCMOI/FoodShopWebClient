{"ast":null,"code":"import { isPresent, isBlank } from '../utils';\nimport { getter } from '../accessor';\nconst compare = (a, b) => {\n  if (isBlank(a)) {\n    return a === b ? 0 : -1;\n  }\n  if (isBlank(b)) {\n    return 1;\n  }\n  if (a.localeCompare) {\n    return a.localeCompare(b);\n  }\n  return a > b ? 1 : a < b ? -1 : 0;\n};\nconst compareDesc = (a, b) => compare(b, a);\nconst descriptorAsFunc = descriptor => {\n  if (typeof descriptor.compare === 'function') {\n    return descriptor.compare;\n  }\n  const prop = getter(descriptor.field, true);\n  return (a, b) => (descriptor.dir === 'asc' ? compare : compareDesc)(prop(a), prop(b));\n};\nconst initial = (_a, _b) => 0;\n// tslint:disable:max-line-length\n/**\n * Converts the `SortDescriptors` into a [Comparer]({% slug api_kendo-data-query_comparer %}) function that can be used through `Array.sort`. If multiple descriptors are provided, sorting is applied in a right-to-left order.\n * @param {SortDescriptor[]} descriptors - The descriptors which will be converted.\n * @returns {Comparer} - The produced function.\n *\n * @example\n * ```ts\n * import { composeSortDescriptors } from '@progress/kendo-data-query';\n *\n * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n * const comparer = composeSortDescriptors([{ field: \"name\", dir: \"asc\" }]);\n * const result = data.sort(comparer);\n * // output: [{ name: \"Beef\" }, { name: \"Pepper\" }, { name: \"Pork\" }];\n * ```\n */\n// tslint:enable:max-line-length\nexport const composeSortDescriptors = descriptors => descriptors.filter(x => isPresent(x.dir) || isPresent(x.compare)).map(descriptor => descriptorAsFunc(descriptor)).reduce((acc, curr) => (a, b) => acc(a, b) || curr(a, b), initial);","map":{"version":3,"names":["isPresent","isBlank","getter","compare","a","b","localeCompare","compareDesc","descriptorAsFunc","descriptor","prop","field","dir","initial","_a","_b","composeSortDescriptors","descriptors","filter","x","map","reduce","acc","curr"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-data-query/dist/es2015/sorting/sort-array.operator.js"],"sourcesContent":["import { isPresent, isBlank } from '../utils';\nimport { getter } from '../accessor';\nconst compare = (a, b) => {\n    if (isBlank(a)) {\n        return a === b ? 0 : -1;\n    }\n    if (isBlank(b)) {\n        return 1;\n    }\n    if (a.localeCompare) {\n        return a.localeCompare(b);\n    }\n    return a > b ? 1 : (a < b ? -1 : 0);\n};\nconst compareDesc = (a, b) => compare(b, a);\nconst descriptorAsFunc = (descriptor) => {\n    if (typeof descriptor.compare === 'function') {\n        return descriptor.compare;\n    }\n    const prop = getter(descriptor.field, true);\n    return (a, b) => (descriptor.dir === 'asc' ? compare : compareDesc)(prop(a), prop(b));\n};\nconst initial = (_a, _b) => 0;\n// tslint:disable:max-line-length\n/**\n * Converts the `SortDescriptors` into a [Comparer]({% slug api_kendo-data-query_comparer %}) function that can be used through `Array.sort`. If multiple descriptors are provided, sorting is applied in a right-to-left order.\n * @param {SortDescriptor[]} descriptors - The descriptors which will be converted.\n * @returns {Comparer} - The produced function.\n *\n * @example\n * ```ts\n * import { composeSortDescriptors } from '@progress/kendo-data-query';\n *\n * const data = [{ name: \"Pork\" }, { name: \"Pepper\" }, { name: \"Beef\" } ];\n * const comparer = composeSortDescriptors([{ field: \"name\", dir: \"asc\" }]);\n * const result = data.sort(comparer);\n * // output: [{ name: \"Beef\" }, { name: \"Pepper\" }, { name: \"Pork\" }];\n * ```\n */\n// tslint:enable:max-line-length\nexport const composeSortDescriptors = (descriptors) => (descriptors\n    .filter(x => isPresent(x.dir) || isPresent(x.compare))\n    .map((descriptor) => descriptorAsFunc(descriptor))\n    .reduce((acc, curr) => (a, b) => acc(a, b) || curr(a, b), initial));\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,OAAO,QAAQ,UAAU;AAC7C,SAASC,MAAM,QAAQ,aAAa;AACpC,MAAMC,OAAO,GAAGA,CAACC,CAAC,EAAEC,CAAC,KAAK;EACtB,IAAIJ,OAAO,CAACG,CAAC,CAAC,EAAE;IACZ,OAAOA,CAAC,KAAKC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;EAC3B;EACA,IAAIJ,OAAO,CAACI,CAAC,CAAC,EAAE;IACZ,OAAO,CAAC;EACZ;EACA,IAAID,CAAC,CAACE,aAAa,EAAE;IACjB,OAAOF,CAAC,CAACE,aAAa,CAACD,CAAC,CAAC;EAC7B;EACA,OAAOD,CAAC,GAAGC,CAAC,GAAG,CAAC,GAAID,CAAC,GAAGC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAE;AACvC,CAAC;AACD,MAAME,WAAW,GAAGA,CAACH,CAAC,EAAEC,CAAC,KAAKF,OAAO,CAACE,CAAC,EAAED,CAAC,CAAC;AAC3C,MAAMI,gBAAgB,GAAIC,UAAU,IAAK;EACrC,IAAI,OAAOA,UAAU,CAACN,OAAO,KAAK,UAAU,EAAE;IAC1C,OAAOM,UAAU,CAACN,OAAO;EAC7B;EACA,MAAMO,IAAI,GAAGR,MAAM,CAACO,UAAU,CAACE,KAAK,EAAE,IAAI,CAAC;EAC3C,OAAO,CAACP,CAAC,EAAEC,CAAC,KAAK,CAACI,UAAU,CAACG,GAAG,KAAK,KAAK,GAAGT,OAAO,GAAGI,WAAW,EAAEG,IAAI,CAACN,CAAC,CAAC,EAAEM,IAAI,CAACL,CAAC,CAAC,CAAC;AACzF,CAAC;AACD,MAAMQ,OAAO,GAAGA,CAACC,EAAE,EAAEC,EAAE,KAAK,CAAC;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,sBAAsB,GAAIC,WAAW,IAAMA,WAAW,CAC9DC,MAAM,CAACC,CAAC,IAAInB,SAAS,CAACmB,CAAC,CAACP,GAAG,CAAC,IAAIZ,SAAS,CAACmB,CAAC,CAAChB,OAAO,CAAC,CAAC,CACrDiB,GAAG,CAAEX,UAAU,IAAKD,gBAAgB,CAACC,UAAU,CAAC,CAAC,CACjDY,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAK,CAACnB,CAAC,EAAEC,CAAC,KAAKiB,GAAG,CAAClB,CAAC,EAAEC,CAAC,CAAC,IAAIkB,IAAI,CAACnB,CAAC,EAAEC,CAAC,CAAC,EAAEQ,OAAO,CAAE"},"metadata":{},"sourceType":"module","externalDependencies":[]}