{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport BoxElement from './box-element';\nimport TextBox from './text-box';\nimport ShapeElement from './shape-element';\nimport Box from './box';\nimport { CIRCLE, TOP, BOTTOM, LEFT, RIGHT, CENTER, INSIDE, OUTSIDE, NOTE_CLICK, NOTE_HOVER, NOTE_LEAVE } from '../common/constants';\nimport { alignPathToPixel, defined, deepExtend, eventElement, getTemplate, inArray, setDefaultOptions } from '../common';\nconst DEFAULT_ICON_SIZE = 7;\nconst DEFAULT_LABEL_COLOR = \"#fff\";\nclass Note extends BoxElement {\n  constructor(fields, options, chartService) {\n    super(options);\n    this.fields = fields;\n    this.chartService = chartService;\n    this.render();\n  }\n  hide() {\n    this.options.visible = false;\n  }\n  show() {\n    this.options.visible = true;\n  }\n  render() {\n    const options = this.options;\n    if (options.visible) {\n      const {\n        label,\n        icon\n      } = options;\n      const box = new Box();\n      const childAlias = () => this;\n      let size = icon.size;\n      let text = this.fields.text;\n      let width, height;\n      if (defined(label) && label.visible) {\n        const noteTemplate = getTemplate(label);\n        if (noteTemplate) {\n          text = noteTemplate(this.fields);\n        } else if (label.format) {\n          text = this.chartService.format.auto(label.format, text);\n        }\n        if (!label.color) {\n          label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;\n        }\n        this.label = new TextBox(text, deepExtend({}, label));\n        this.label.aliasFor = childAlias;\n        if (label.position === INSIDE && !defined(size)) {\n          if (icon.type === CIRCLE) {\n            size = Math.max(this.label.box.width(), this.label.box.height());\n          } else {\n            width = this.label.box.width();\n            height = this.label.box.height();\n          }\n          box.wrap(this.label.box);\n        }\n      }\n      icon.width = width || size || DEFAULT_ICON_SIZE;\n      icon.height = height || size || DEFAULT_ICON_SIZE;\n      const marker = new ShapeElement(deepExtend({}, icon));\n      marker.aliasFor = childAlias;\n      this.marker = marker;\n      this.append(marker);\n      if (this.label) {\n        this.append(this.label);\n      }\n      marker.reflow(new Box());\n      this.wrapperBox = box.wrap(marker.box);\n    }\n  }\n  reflow(targetBox) {\n    const {\n      options,\n      label,\n      marker,\n      wrapperBox\n    } = this;\n    const center = targetBox.center();\n    const length = options.line.length;\n    const position = options.position;\n\n    // TODO: Review\n    if (options.visible) {\n      let lineStart, box, contentBox;\n      if (inArray(position, [LEFT, RIGHT])) {\n        if (position === LEFT) {\n          contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);\n          if (options.line.visible) {\n            lineStart = [targetBox.x1, center.y];\n            this.linePoints = [lineStart, [contentBox.x2, center.y]];\n            box = contentBox.clone().wrapPoint(lineStart);\n          }\n        } else {\n          contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);\n          if (options.line.visible) {\n            lineStart = [targetBox.x2, center.y];\n            this.linePoints = [lineStart, [contentBox.x1, center.y]];\n            box = contentBox.clone().wrapPoint(lineStart);\n          }\n        }\n      } else {\n        if (position === BOTTOM) {\n          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);\n          if (options.line.visible) {\n            lineStart = [center.x, targetBox.y2];\n            this.linePoints = [lineStart, [center.x, contentBox.y1]];\n            box = contentBox.clone().wrapPoint(lineStart);\n          }\n        } else {\n          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);\n          if (options.line.visible) {\n            lineStart = [center.x, targetBox.y1];\n            this.linePoints = [lineStart, [center.x, contentBox.y2]];\n            box = contentBox.clone().wrapPoint(lineStart);\n          }\n        }\n      }\n      if (marker) {\n        marker.reflow(contentBox);\n      }\n      if (label) {\n        label.reflow(contentBox);\n        if (marker) {\n          if (options.label.position === OUTSIDE) {\n            label.box.alignTo(marker.box, position);\n          }\n          label.reflow(label.box);\n        }\n      }\n      this.contentBox = contentBox;\n      this.targetBox = targetBox;\n      this.box = box || contentBox;\n    }\n  }\n  createVisual() {\n    super.createVisual();\n    this.visual.options.noclip = this.options.noclip;\n    if (this.options.visible) {\n      this.createLine();\n    }\n  }\n  renderVisual() {\n    const options = this.options;\n    const customVisual = options.visual;\n    if (options.visible && customVisual) {\n      this.visual = customVisual(Object.assign(this.fields, {\n        sender: this.getSender(),\n        rect: this.targetBox.toRect(),\n        options: {\n          background: options.background,\n          border: options.background,\n          icon: options.icon,\n          label: options.label,\n          line: options.line,\n          position: options.position,\n          visible: options.visible\n        },\n        createVisual: () => {\n          this.createVisual();\n          this.renderChildren();\n          const defaultVisual = this.visual;\n          delete this.visual;\n          return defaultVisual;\n        }\n      }));\n      this.addVisual();\n    } else {\n      super.renderVisual();\n    }\n  }\n  createLine() {\n    const options = this.options.line;\n    if (this.linePoints) {\n      const path = draw.Path.fromPoints(this.linePoints, {\n        stroke: {\n          color: options.color,\n          width: options.width,\n          dashType: options.dashType\n        }\n      });\n      alignPathToPixel(path);\n      this.visual.append(path);\n    }\n  }\n  click(widget, e) {\n    const args = this.eventArgs(e);\n    if (!widget.trigger(NOTE_CLICK, args)) {\n      e.preventDefault();\n    }\n  }\n  over(widget, e) {\n    const args = this.eventArgs(e);\n    if (!widget.trigger(NOTE_HOVER, args)) {\n      e.preventDefault();\n    }\n  }\n  out(widget, e) {\n    const args = this.eventArgs(e);\n    widget.trigger(NOTE_LEAVE, args);\n  }\n  eventArgs(e) {\n    const options = this.options;\n    return Object.assign(this.fields, {\n      element: eventElement(e),\n      text: defined(options.label) ? options.label.text : \"\",\n      visual: this.visual\n    });\n  }\n}\nsetDefaultOptions(Note, {\n  icon: {\n    visible: true,\n    type: CIRCLE\n  },\n  label: {\n    position: INSIDE,\n    visible: true,\n    align: CENTER,\n    vAlign: CENTER\n  },\n  line: {\n    visible: true\n  },\n  visible: true,\n  position: TOP,\n  zIndex: 2\n});\nexport default Note;","map":{"version":3,"names":["drawing","draw","BoxElement","TextBox","ShapeElement","Box","CIRCLE","TOP","BOTTOM","LEFT","RIGHT","CENTER","INSIDE","OUTSIDE","NOTE_CLICK","NOTE_HOVER","NOTE_LEAVE","alignPathToPixel","defined","deepExtend","eventElement","getTemplate","inArray","setDefaultOptions","DEFAULT_ICON_SIZE","DEFAULT_LABEL_COLOR","Note","constructor","fields","options","chartService","render","hide","visible","show","label","icon","box","childAlias","size","text","width","height","noteTemplate","format","auto","color","position","background","aliasFor","type","Math","max","wrap","marker","append","reflow","wrapperBox","targetBox","center","length","line","lineStart","contentBox","alignTo","translate","y","x1","linePoints","x2","clone","wrapPoint","x","y2","y1","createVisual","visual","noclip","createLine","renderVisual","customVisual","Object","assign","sender","getSender","rect","toRect","border","renderChildren","defaultVisual","addVisual","path","Path","fromPoints","stroke","dashType","click","widget","e","args","eventArgs","trigger","preventDefault","over","out","element","align","vAlign","zIndex"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/core/note.js"],"sourcesContent":["import { drawing as draw } from '@progress/kendo-drawing';\n\nimport BoxElement from './box-element';\nimport TextBox from './text-box';\nimport ShapeElement from './shape-element';\nimport Box from './box';\n\nimport { CIRCLE, TOP, BOTTOM, LEFT, RIGHT, CENTER, INSIDE, OUTSIDE, NOTE_CLICK, NOTE_HOVER, NOTE_LEAVE } from '../common/constants';\nimport { alignPathToPixel, defined, deepExtend, eventElement, getTemplate, inArray, setDefaultOptions } from '../common';\n\nconst DEFAULT_ICON_SIZE = 7;\nconst DEFAULT_LABEL_COLOR = \"#fff\";\n\nclass Note extends BoxElement {\n    constructor(fields, options, chartService) {\n        super(options);\n\n        this.fields = fields;\n        this.chartService = chartService;\n\n        this.render();\n    }\n\n    hide() {\n        this.options.visible = false;\n    }\n\n    show() {\n        this.options.visible = true;\n    }\n\n    render() {\n        const options = this.options;\n\n        if (options.visible) {\n            const { label, icon } = options;\n            const box = new Box();\n            const childAlias = () => this;\n            let size = icon.size;\n            let text = this.fields.text;\n            let width, height;\n\n            if (defined(label) && label.visible) {\n                const noteTemplate = getTemplate(label);\n                if (noteTemplate) {\n                    text = noteTemplate(this.fields);\n                } else if (label.format) {\n                    text = this.chartService.format.auto(label.format, text);\n                }\n\n                if (!label.color) {\n                    label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;\n                }\n\n                this.label = new TextBox(text, deepExtend({}, label));\n                this.label.aliasFor = childAlias;\n\n                if (label.position === INSIDE && !defined(size)) {\n                    if (icon.type === CIRCLE) {\n                        size = Math.max(this.label.box.width(), this.label.box.height());\n                    } else {\n                        width = this.label.box.width();\n                        height = this.label.box.height();\n                    }\n                    box.wrap(this.label.box);\n                }\n            }\n\n            icon.width = width || size || DEFAULT_ICON_SIZE;\n            icon.height = height || size || DEFAULT_ICON_SIZE;\n\n            const marker = new ShapeElement(deepExtend({}, icon));\n            marker.aliasFor = childAlias;\n\n            this.marker = marker;\n            this.append(marker);\n\n            if (this.label) {\n                this.append(this.label);\n            }\n\n            marker.reflow(new Box());\n            this.wrapperBox = box.wrap(marker.box);\n        }\n    }\n\n    reflow(targetBox) {\n        const { options, label, marker, wrapperBox } = this;\n        const center = targetBox.center();\n        const length = options.line.length;\n        const position = options.position;\n\n        // TODO: Review\n        if (options.visible) {\n            let lineStart, box, contentBox;\n\n            if (inArray(position, [ LEFT, RIGHT ])) {\n                if (position === LEFT) {\n                    contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);\n\n                    if (options.line.visible) {\n                        lineStart = [ targetBox.x1, center.y ];\n                        this.linePoints = [\n                            lineStart,\n                            [ contentBox.x2, center.y ]\n                        ];\n                        box = contentBox.clone().wrapPoint(lineStart);\n                    }\n                } else {\n                    contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);\n\n                    if (options.line.visible) {\n                        lineStart = [ targetBox.x2, center.y ];\n                        this.linePoints = [\n                            lineStart,\n                            [ contentBox.x1, center.y ]\n                        ];\n                        box = contentBox.clone().wrapPoint(lineStart);\n                    }\n                }\n            } else {\n                if (position === BOTTOM) {\n                    contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);\n\n                    if (options.line.visible) {\n                        lineStart = [ center.x, targetBox.y2 ];\n                        this.linePoints = [\n                            lineStart,\n                            [ center.x, contentBox.y1 ]\n                        ];\n                        box = contentBox.clone().wrapPoint(lineStart);\n                    }\n                } else {\n                    contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);\n\n                    if (options.line.visible) {\n                        lineStart = [ center.x, targetBox.y1 ];\n                        this.linePoints = [\n                            lineStart,\n                            [ center.x, contentBox.y2 ]\n                        ];\n                        box = contentBox.clone().wrapPoint(lineStart);\n                    }\n                }\n            }\n\n            if (marker) {\n                marker.reflow(contentBox);\n            }\n\n            if (label) {\n                label.reflow(contentBox);\n                if (marker) {\n                    if (options.label.position === OUTSIDE) {\n                        label.box.alignTo(marker.box, position);\n                    }\n                    label.reflow(label.box);\n                }\n            }\n\n            this.contentBox = contentBox;\n            this.targetBox = targetBox;\n            this.box = box || contentBox;\n        }\n    }\n\n    createVisual() {\n        super.createVisual();\n        this.visual.options.noclip = this.options.noclip;\n\n        if (this.options.visible) {\n            this.createLine();\n        }\n    }\n\n    renderVisual() {\n        const options = this.options;\n        const customVisual = options.visual;\n        if (options.visible && customVisual) {\n            this.visual = customVisual(Object.assign(this.fields, {\n                sender: this.getSender(),\n                rect: this.targetBox.toRect(),\n                options: {\n                    background: options.background,\n                    border: options.background,\n                    icon: options.icon,\n                    label: options.label,\n                    line: options.line,\n                    position: options.position,\n                    visible: options.visible\n                },\n                createVisual: () => {\n                    this.createVisual();\n                    this.renderChildren();\n                    const defaultVisual = this.visual;\n                    delete this.visual;\n                    return defaultVisual;\n                }\n            }));\n            this.addVisual();\n        } else {\n            super.renderVisual();\n        }\n    }\n\n    createLine() {\n        const options = this.options.line;\n\n        if (this.linePoints) {\n            const path = draw.Path.fromPoints(this.linePoints, {\n                stroke: {\n                    color: options.color,\n                    width: options.width,\n                    dashType: options.dashType\n                }\n            });\n\n            alignPathToPixel(path);\n            this.visual.append(path);\n        }\n    }\n\n    click(widget, e) {\n        const args = this.eventArgs(e);\n\n        if (!widget.trigger(NOTE_CLICK, args)) {\n            e.preventDefault();\n        }\n    }\n\n    over(widget, e) {\n        const args = this.eventArgs(e);\n\n        if (!widget.trigger(NOTE_HOVER, args)) {\n            e.preventDefault();\n        }\n    }\n\n    out(widget, e) {\n        const args = this.eventArgs(e);\n\n        widget.trigger(NOTE_LEAVE, args);\n    }\n\n    eventArgs(e) {\n        const options = this.options;\n\n        return Object.assign(this.fields, {\n            element: eventElement(e),\n            text: defined(options.label) ? options.label.text : \"\",\n            visual: this.visual\n        });\n    }\n}\n\nsetDefaultOptions(Note, {\n    icon: {\n        visible: true,\n        type: CIRCLE\n    },\n    label: {\n        position: INSIDE,\n        visible: true,\n        align: CENTER,\n        vAlign: CENTER\n    },\n    line: {\n        visible: true\n    },\n    visible: true,\n    position: TOP,\n    zIndex: 2\n});\n\nexport default Note;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}