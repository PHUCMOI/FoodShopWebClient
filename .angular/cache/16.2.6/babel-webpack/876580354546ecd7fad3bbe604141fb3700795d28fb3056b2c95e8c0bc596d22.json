{"ast":null,"code":"import { exec, map, groupCombinator } from '../transducers';\nimport { isArray, isPresent } from '../utils';\nimport { aggregateBy } from './aggregate.operators';\nimport { filterBy } from '../filtering/filter-expression.factory';\n/**\n * @hidden\n */\nexport const normalizeGroups = descriptors => {\n  descriptors = isArray(descriptors) ? descriptors : [descriptors];\n  return descriptors.map(x => Object.assign({\n    dir: \"asc\"\n  }, x));\n};\nconst identity = map(x => x);\n/**\n * Groups the provided data according to the specified descriptors.\n *\n * @param {Array} data - The data that will be grouped.\n * @param {GroupDescriptor[]} descriptors - The descriptors.\n * @param {any} transformers - For internal use.\n * @param {Array} originalData - For internal use.\n * @returns {(Array<GroupResult<T>> | T[])} - The grouped data.\n *\n * @example\n * ```ts\n *\n * import { groupBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = groupBy(data, [{ field: \"subcategory\" }]);\n * ```\n */\nexport const groupBy = (data, descriptors = [], transformers = identity, originalData = data) => {\n  descriptors = normalizeGroups(descriptors);\n  if (!descriptors.length) {\n    return data;\n  }\n  const descriptor = descriptors[0];\n  const initialValue = {};\n  const view = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);\n  const result = [];\n  Object.keys(view).forEach(field => {\n    Object.keys(view[field]).forEach(value => {\n      const group = view[field][value];\n      let aggregateResult = {};\n      let filteredData = originalData;\n      if (isPresent(descriptor.aggregates)) {\n        filteredData = filterBy(originalData, {\n          field: descriptor.field,\n          ignoreCase: false,\n          operator: 'eq',\n          value: group.value\n        });\n        aggregateResult = aggregateBy(filteredData, descriptor.aggregates);\n      }\n      result[group.__position] = {\n        aggregates: aggregateResult,\n        field: field,\n        items: descriptors.length > 1 ? groupBy(group.items, descriptors.slice(1), identity, filteredData) : group.items,\n        value: group.value\n      };\n    });\n  });\n  return result;\n};","map":{"version":3,"names":["exec","map","groupCombinator","isArray","isPresent","aggregateBy","filterBy","normalizeGroups","descriptors","x","Object","assign","dir","identity","groupBy","data","transformers","originalData","length","descriptor","initialValue","view","field","result","keys","forEach","value","group","aggregateResult","filteredData","aggregates","ignoreCase","operator","__position","items","slice"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-data-query/dist/es2015/grouping/group.operators.js"],"sourcesContent":["import { exec, map, groupCombinator } from '../transducers';\nimport { isArray, isPresent } from '../utils';\nimport { aggregateBy } from './aggregate.operators';\nimport { filterBy } from '../filtering/filter-expression.factory';\n/**\n * @hidden\n */\nexport const normalizeGroups = (descriptors) => {\n    descriptors = isArray(descriptors) ? descriptors : [descriptors];\n    return descriptors.map(x => Object.assign({ dir: \"asc\" }, x));\n};\nconst identity = map(x => x);\n/**\n * Groups the provided data according to the specified descriptors.\n *\n * @param {Array} data - The data that will be grouped.\n * @param {GroupDescriptor[]} descriptors - The descriptors.\n * @param {any} transformers - For internal use.\n * @param {Array} originalData - For internal use.\n * @returns {(Array<GroupResult<T>> | T[])} - The grouped data.\n *\n * @example\n * ```ts\n *\n * import { groupBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = groupBy(data, [{ field: \"subcategory\" }]);\n * ```\n */\nexport const groupBy = (data, descriptors = [], transformers = identity, originalData = data) => {\n    descriptors = normalizeGroups(descriptors);\n    if (!descriptors.length) {\n        return data;\n    }\n    const descriptor = descriptors[0];\n    const initialValue = {};\n    const view = exec(transformers(groupCombinator(descriptor.field)), initialValue, data);\n    const result = [];\n    Object.keys(view).forEach(field => {\n        Object.keys(view[field]).forEach(value => {\n            const group = view[field][value];\n            let aggregateResult = {};\n            let filteredData = originalData;\n            if (isPresent(descriptor.aggregates)) {\n                filteredData = filterBy(originalData, {\n                    field: descriptor.field,\n                    ignoreCase: false,\n                    operator: 'eq',\n                    value: group.value\n                });\n                aggregateResult = aggregateBy(filteredData, descriptor.aggregates);\n            }\n            result[group.__position] = {\n                aggregates: aggregateResult,\n                field: field,\n                items: descriptors.length > 1 ?\n                    groupBy(group.items, descriptors.slice(1), identity, filteredData)\n                    : group.items,\n                value: group.value\n            };\n        });\n    });\n    return result;\n};\n"],"mappings":"AAAA,SAASA,IAAI,EAAEC,GAAG,EAAEC,eAAe,QAAQ,gBAAgB;AAC3D,SAASC,OAAO,EAAEC,SAAS,QAAQ,UAAU;AAC7C,SAASC,WAAW,QAAQ,uBAAuB;AACnD,SAASC,QAAQ,QAAQ,wCAAwC;AACjE;AACA;AACA;AACA,OAAO,MAAMC,eAAe,GAAIC,WAAW,IAAK;EAC5CA,WAAW,GAAGL,OAAO,CAACK,WAAW,CAAC,GAAGA,WAAW,GAAG,CAACA,WAAW,CAAC;EAChE,OAAOA,WAAW,CAACP,GAAG,CAACQ,CAAC,IAAIC,MAAM,CAACC,MAAM,CAAC;IAAEC,GAAG,EAAE;EAAM,CAAC,EAAEH,CAAC,CAAC,CAAC;AACjE,CAAC;AACD,MAAMI,QAAQ,GAAGZ,GAAG,CAACQ,CAAC,IAAIA,CAAC,CAAC;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,OAAO,GAAGA,CAACC,IAAI,EAAEP,WAAW,GAAG,EAAE,EAAEQ,YAAY,GAAGH,QAAQ,EAAEI,YAAY,GAAGF,IAAI,KAAK;EAC7FP,WAAW,GAAGD,eAAe,CAACC,WAAW,CAAC;EAC1C,IAAI,CAACA,WAAW,CAACU,MAAM,EAAE;IACrB,OAAOH,IAAI;EACf;EACA,MAAMI,UAAU,GAAGX,WAAW,CAAC,CAAC,CAAC;EACjC,MAAMY,YAAY,GAAG,CAAC,CAAC;EACvB,MAAMC,IAAI,GAAGrB,IAAI,CAACgB,YAAY,CAACd,eAAe,CAACiB,UAAU,CAACG,KAAK,CAAC,CAAC,EAAEF,YAAY,EAAEL,IAAI,CAAC;EACtF,MAAMQ,MAAM,GAAG,EAAE;EACjBb,MAAM,CAACc,IAAI,CAACH,IAAI,CAAC,CAACI,OAAO,CAACH,KAAK,IAAI;IAC/BZ,MAAM,CAACc,IAAI,CAACH,IAAI,CAACC,KAAK,CAAC,CAAC,CAACG,OAAO,CAACC,KAAK,IAAI;MACtC,MAAMC,KAAK,GAAGN,IAAI,CAACC,KAAK,CAAC,CAACI,KAAK,CAAC;MAChC,IAAIE,eAAe,GAAG,CAAC,CAAC;MACxB,IAAIC,YAAY,GAAGZ,YAAY;MAC/B,IAAIb,SAAS,CAACe,UAAU,CAACW,UAAU,CAAC,EAAE;QAClCD,YAAY,GAAGvB,QAAQ,CAACW,YAAY,EAAE;UAClCK,KAAK,EAAEH,UAAU,CAACG,KAAK;UACvBS,UAAU,EAAE,KAAK;UACjBC,QAAQ,EAAE,IAAI;UACdN,KAAK,EAAEC,KAAK,CAACD;QACjB,CAAC,CAAC;QACFE,eAAe,GAAGvB,WAAW,CAACwB,YAAY,EAAEV,UAAU,CAACW,UAAU,CAAC;MACtE;MACAP,MAAM,CAACI,KAAK,CAACM,UAAU,CAAC,GAAG;QACvBH,UAAU,EAAEF,eAAe;QAC3BN,KAAK,EAAEA,KAAK;QACZY,KAAK,EAAE1B,WAAW,CAACU,MAAM,GAAG,CAAC,GACzBJ,OAAO,CAACa,KAAK,CAACO,KAAK,EAAE1B,WAAW,CAAC2B,KAAK,CAAC,CAAC,CAAC,EAAEtB,QAAQ,EAAEgB,YAAY,CAAC,GAChEF,KAAK,CAACO,KAAK;QACjBR,KAAK,EAAEC,KAAK,CAACD;MACjB,CAAC;IACL,CAAC,CAAC;EACN,CAAC,CAAC;EACF,OAAOH,MAAM;AACjB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}