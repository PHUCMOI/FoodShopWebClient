{"ast":null,"code":"import { ChartElement, Box } from '../../core';\nimport ClipAnimationMixin from '../mixins/clip-animation-mixin';\nimport ErrorRangeCalculator from '../error-bars/error-range-calculator';\nimport ScatterErrorBar from '../error-bars/scatter-error-bar';\nimport LinePoint from '../line-chart/line-point';\nimport { hasValue, evalOptions } from '../utils';\nimport { deepExtend, isNumber, isString, defined, isFunction, setDefaultOptions } from '../../common';\nimport { X, Y, MIN_VALUE, MAX_VALUE } from '../../common/constants';\nimport { parseDate } from '../../date-utils';\nclass ScatterChart extends ChartElement {\n  constructor(plotArea, options) {\n    super(options);\n    this.plotArea = plotArea;\n    this.chartService = plotArea.chartService;\n    this._initFields();\n    this.render();\n  }\n  _initFields() {\n    // X and Y axis ranges grouped by name, e.g.:\n    // primary: { min: 0, max: 1 }\n    this.xAxisRanges = {};\n    this.yAxisRanges = {};\n    this.points = [];\n    this.seriesPoints = [];\n    this.seriesOptions = [];\n    this._evalSeries = [];\n  }\n  render() {\n    this.traverseDataPoints(this.addValue.bind(this));\n  }\n  addErrorBar(point, field, fields) {\n    const value = point.value[field];\n    const valueErrorField = field + \"Value\";\n    const lowField = field + \"ErrorLow\";\n    const highField = field + \"ErrorHigh\";\n    const {\n      seriesIx,\n      series\n    } = fields;\n    const errorBars = point.options.errorBars;\n    const lowValue = fields[lowField];\n    const highValue = fields[highField];\n    if (isNumber(value)) {\n      let errorRange;\n      if (isNumber(lowValue) && isNumber(highValue)) {\n        errorRange = {\n          low: lowValue,\n          high: highValue\n        };\n      }\n      if (errorBars && defined(errorBars[valueErrorField])) {\n        this.seriesErrorRanges = this.seriesErrorRanges || {\n          x: [],\n          y: []\n        };\n        this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] || new ErrorRangeCalculator(errorBars[valueErrorField], series, field);\n        errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value, errorBars[valueErrorField]);\n      }\n      if (errorRange) {\n        this.addPointErrorBar(errorRange, point, field);\n      }\n    }\n  }\n  addPointErrorBar(errorRange, point, field) {\n    const {\n      low,\n      high\n    } = errorRange;\n    const {\n      series,\n      options: {\n        errorBars: options\n      }\n    } = point;\n    const isVertical = field === Y;\n    const item = {};\n    point[field + \"Low\"] = low;\n    point[field + \"High\"] = high;\n    point.errorBars = point.errorBars || [];\n    const errorBar = new ScatterErrorBar(low, high, isVertical, this, series, options);\n    point.errorBars.push(errorBar);\n    point.append(errorBar);\n    item[field] = low;\n    this.updateRange(item, series);\n    item[field] = high;\n    this.updateRange(item, series);\n  }\n  addValue(value, fields) {\n    const {\n      x,\n      y\n    } = value;\n    const seriesIx = fields.seriesIx;\n    const series = this.options.series[seriesIx];\n    const missingValues = this.seriesMissingValues(series);\n    const seriesPoints = this.seriesPoints[seriesIx];\n    let pointValue = value;\n    if (!(hasValue(x) && hasValue(y))) {\n      pointValue = this.createMissingValue(pointValue, missingValues);\n    }\n    let point;\n    if (pointValue) {\n      point = this.createPoint(pointValue, fields);\n      if (point) {\n        Object.assign(point, fields);\n        this.addErrorBar(point, X, fields);\n        this.addErrorBar(point, Y, fields);\n      }\n      this.updateRange(pointValue, fields.series);\n    }\n    this.points.push(point);\n    seriesPoints.push(point);\n  }\n  seriesMissingValues(series) {\n    return series.missingValues;\n  }\n  createMissingValue() {}\n  updateRange(value, series) {\n    const intlService = this.chartService.intl;\n    const {\n      xAxis: xAxisName,\n      yAxis: yAxisName\n    } = series;\n    let {\n      x,\n      y\n    } = value;\n    let xAxisRange = this.xAxisRanges[xAxisName];\n    let yAxisRange = this.yAxisRanges[yAxisName];\n    if (hasValue(x)) {\n      xAxisRange = this.xAxisRanges[xAxisName] = xAxisRange || {\n        min: MAX_VALUE,\n        max: MIN_VALUE\n      };\n      if (isString(x)) {\n        x = parseDate(intlService, x);\n      }\n      xAxisRange.min = Math.min(xAxisRange.min, x);\n      xAxisRange.max = Math.max(xAxisRange.max, x);\n    }\n    if (hasValue(y)) {\n      yAxisRange = this.yAxisRanges[yAxisName] = yAxisRange || {\n        min: MAX_VALUE,\n        max: MIN_VALUE\n      };\n      if (isString(y)) {\n        y = parseDate(intlService, y);\n      }\n      yAxisRange.min = Math.min(yAxisRange.min, y);\n      yAxisRange.max = Math.max(yAxisRange.max, y);\n    }\n  }\n  evalPointOptions(options, value, fields) {\n    const {\n      series,\n      seriesIx\n    } = fields;\n    const state = {\n      defaults: series._defaults,\n      excluded: [\"data\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\", \"drilldownSeriesFactory\"]\n    };\n    let doEval = this._evalSeries[seriesIx];\n    if (!defined(doEval)) {\n      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n    }\n    let pointOptions = options;\n    if (doEval) {\n      pointOptions = deepExtend({}, options);\n      evalOptions(pointOptions, {\n        value: value,\n        series: series,\n        dataItem: fields.dataItem\n      }, state);\n    }\n    return pointOptions;\n  }\n  pointType() {\n    return LinePoint;\n  }\n  pointOptions(series, seriesIx) {\n    let options = this.seriesOptions[seriesIx];\n    if (!options) {\n      const defaults = this.pointType().prototype.defaults;\n      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n        markers: {\n          opacity: series.opacity\n        },\n        tooltip: {\n          format: this.options.tooltip.format\n        },\n        labels: {\n          format: this.options.labels.format\n        }\n      }, series);\n    }\n    return options;\n  }\n  createPoint(value, fields) {\n    const series = fields.series;\n    let pointOptions = this.pointOptions(series, fields.seriesIx);\n    let color = fields.color || series.color;\n    pointOptions = this.evalPointOptions(pointOptions, value, fields);\n    if (isFunction(series.color)) {\n      color = pointOptions.color;\n    }\n    const point = new LinePoint(value, pointOptions);\n    point.color = color;\n    this.append(point);\n    return point;\n  }\n  seriesAxes(series) {\n    const {\n      xAxis: xAxisName,\n      yAxis: yAxisName\n    } = series;\n    const plotArea = this.plotArea;\n    const xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;\n    const yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;\n    if (!xAxis) {\n      throw new Error(\"Unable to locate X axis with name \" + xAxisName);\n    }\n    if (!yAxis) {\n      throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\n    }\n    return {\n      x: xAxis,\n      y: yAxis\n    };\n  }\n  reflow(targetBox) {\n    const chartPoints = this.points;\n    const limit = !this.options.clip;\n    let pointIx = 0;\n    this.traverseDataPoints((value, fields) => {\n      const point = chartPoints[pointIx++];\n      const seriesAxes = this.seriesAxes(fields.series);\n      const slotX = seriesAxes.x.getSlot(value.x, value.x, limit);\n      const slotY = seriesAxes.y.getSlot(value.y, value.y, limit);\n      if (point) {\n        if (slotX && slotY) {\n          const pointSlot = this.pointSlot(slotX, slotY);\n          point.reflow(pointSlot);\n        } else {\n          point.visible = false;\n        }\n      }\n    });\n    this.box = targetBox;\n  }\n  pointSlot(slotX, slotY) {\n    return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n  }\n  traverseDataPoints(callback) {\n    const {\n      options: {\n        series\n      },\n      seriesPoints\n    } = this;\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      const currentSeriesPoints = seriesPoints[seriesIx];\n      if (!currentSeriesPoints) {\n        seriesPoints[seriesIx] = [];\n      }\n      for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n        const {\n          valueFields: value,\n          fields\n        } = this.plotArea.bindPoint(currentSeries, pointIx);\n        callback(value, deepExtend({\n          pointIx: pointIx,\n          series: currentSeries,\n          seriesIx: seriesIx,\n          dataItem: currentSeries.data[pointIx],\n          owner: this\n        }, fields));\n      }\n    }\n  }\n  formatPointValue(point, format) {\n    const value = point.value;\n    return this.chartService.format.auto(format, value.x, value.y);\n  }\n  animationPoints() {\n    const points = this.points;\n    const result = [];\n    for (let idx = 0; idx < points.length; idx++) {\n      result.push((points[idx] || {}).marker);\n    }\n    return result;\n  }\n}\nsetDefaultOptions(ScatterChart, {\n  series: [],\n  tooltip: {\n    format: \"{0}, {1}\"\n  },\n  labels: {\n    format: \"{0}, {1}\"\n  },\n  clip: true\n});\ndeepExtend(ScatterChart.prototype, ClipAnimationMixin);\nexport default ScatterChart;","map":{"version":3,"names":["ChartElement","Box","ClipAnimationMixin","ErrorRangeCalculator","ScatterErrorBar","LinePoint","hasValue","evalOptions","deepExtend","isNumber","isString","defined","isFunction","setDefaultOptions","X","Y","MIN_VALUE","MAX_VALUE","parseDate","ScatterChart","constructor","plotArea","options","chartService","_initFields","render","xAxisRanges","yAxisRanges","points","seriesPoints","seriesOptions","_evalSeries","traverseDataPoints","addValue","bind","addErrorBar","point","field","fields","value","valueErrorField","lowField","highField","seriesIx","series","errorBars","lowValue","highValue","errorRange","low","high","seriesErrorRanges","x","y","getErrorRange","addPointErrorBar","isVertical","item","errorBar","push","append","updateRange","missingValues","seriesMissingValues","pointValue","createMissingValue","createPoint","Object","assign","intlService","intl","xAxis","xAxisName","yAxis","yAxisName","xAxisRange","yAxisRange","min","max","Math","evalPointOptions","state","defaults","_defaults","excluded","doEval","pointOptions","dataItem","pointType","prototype","markers","opacity","tooltip","format","labels","color","seriesAxes","namedXAxes","axisX","namedYAxes","axisY","Error","reflow","targetBox","chartPoints","limit","clip","pointIx","slotX","getSlot","slotY","pointSlot","visible","box","x1","y1","x2","y2","callback","length","currentSeries","currentSeriesPoints","data","valueFields","bindPoint","owner","formatPointValue","auto","animationPoints","result","idx","marker"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/scatter-charts/scatter-chart.js"],"sourcesContent":["import { ChartElement, Box } from '../../core';\n\nimport ClipAnimationMixin from '../mixins/clip-animation-mixin';\nimport ErrorRangeCalculator from '../error-bars/error-range-calculator';\nimport ScatterErrorBar from '../error-bars/scatter-error-bar';\nimport LinePoint from '../line-chart/line-point';\n\nimport { hasValue, evalOptions } from '../utils';\n\nimport { deepExtend, isNumber, isString, defined, isFunction, setDefaultOptions } from '../../common';\nimport { X, Y, MIN_VALUE, MAX_VALUE } from '../../common/constants';\nimport { parseDate } from '../../date-utils';\n\nclass ScatterChart extends ChartElement {\n    constructor(plotArea, options) {\n\n        super(options);\n\n        this.plotArea = plotArea;\n        this.chartService = plotArea.chartService;\n        this._initFields();\n\n        this.render();\n    }\n\n    _initFields() {\n        // X and Y axis ranges grouped by name, e.g.:\n        // primary: { min: 0, max: 1 }\n        this.xAxisRanges = {};\n        this.yAxisRanges = {};\n\n        this.points = [];\n        this.seriesPoints = [];\n        this.seriesOptions = [];\n        this._evalSeries = [];\n    }\n\n    render() {\n        this.traverseDataPoints(this.addValue.bind(this));\n    }\n\n    addErrorBar(point, field, fields) {\n        const value = point.value[field];\n        const valueErrorField = field + \"Value\";\n        const lowField = field + \"ErrorLow\";\n        const highField = field + \"ErrorHigh\";\n        const { seriesIx, series } = fields;\n        const errorBars = point.options.errorBars;\n        const lowValue = fields[lowField];\n        const highValue = fields[highField];\n\n        if (isNumber(value)) {\n            let errorRange;\n            if (isNumber(lowValue) && isNumber(highValue)) {\n                errorRange = { low: lowValue, high: highValue };\n            }\n\n            if (errorBars && defined(errorBars[valueErrorField])) {\n                this.seriesErrorRanges = this.seriesErrorRanges || { x: [], y: [] };\n                this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] ||\n                    new ErrorRangeCalculator(errorBars[valueErrorField], series, field);\n\n                errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value, errorBars[valueErrorField]);\n            }\n\n            if (errorRange) {\n                this.addPointErrorBar(errorRange, point, field);\n            }\n        }\n    }\n\n    addPointErrorBar(errorRange, point, field) {\n        const { low, high } = errorRange;\n        const { series, options: { errorBars: options } } = point;\n        const isVertical = field === Y;\n        const item = {};\n\n        point[field + \"Low\"] = low;\n        point[field + \"High\"] = high;\n\n        point.errorBars = point.errorBars || [];\n        const errorBar = new ScatterErrorBar(low, high, isVertical, this, series, options);\n        point.errorBars.push(errorBar);\n        point.append(errorBar);\n\n        item[field] = low;\n        this.updateRange(item, series);\n        item[field] = high;\n        this.updateRange(item, series);\n    }\n\n    addValue(value, fields) {\n        const { x, y } = value;\n        const seriesIx = fields.seriesIx;\n        const series = this.options.series[seriesIx];\n        const missingValues = this.seriesMissingValues(series);\n        const seriesPoints = this.seriesPoints[seriesIx];\n\n        let pointValue = value;\n        if (!(hasValue(x) && hasValue(y))) {\n            pointValue = this.createMissingValue(pointValue, missingValues);\n        }\n\n        let point;\n        if (pointValue) {\n            point = this.createPoint(pointValue, fields);\n            if (point) {\n                Object.assign(point, fields);\n                this.addErrorBar(point, X, fields);\n                this.addErrorBar(point, Y, fields);\n            }\n            this.updateRange(pointValue, fields.series);\n        }\n\n        this.points.push(point);\n        seriesPoints.push(point);\n    }\n\n    seriesMissingValues(series) {\n        return series.missingValues;\n    }\n\n    createMissingValue() {}\n\n    updateRange(value, series) {\n        const intlService = this.chartService.intl;\n        const { xAxis: xAxisName, yAxis: yAxisName } = series;\n        let { x, y } = value;\n        let xAxisRange = this.xAxisRanges[xAxisName];\n        let yAxisRange = this.yAxisRanges[yAxisName];\n\n        if (hasValue(x)) {\n            xAxisRange = this.xAxisRanges[xAxisName] =\n                xAxisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n            if (isString(x)) {\n                x = parseDate(intlService, x);\n            }\n\n            xAxisRange.min = Math.min(xAxisRange.min, x);\n            xAxisRange.max = Math.max(xAxisRange.max, x);\n        }\n\n        if (hasValue(y)) {\n            yAxisRange = this.yAxisRanges[yAxisName] =\n                yAxisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n            if (isString(y)) {\n                y = parseDate(intlService, y);\n            }\n\n            yAxisRange.min = Math.min(yAxisRange.min, y);\n            yAxisRange.max = Math.max(yAxisRange.max, y);\n        }\n    }\n\n    evalPointOptions(options, value, fields) {\n        const { series, seriesIx } = fields;\n        const state = {\n            defaults: series._defaults,\n            excluded: [\n                \"data\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\",\n                \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\",\n                \"drilldownSeriesFactory\"\n            ]\n        };\n\n        let doEval = this._evalSeries[seriesIx];\n        if (!defined(doEval)) {\n            this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n        }\n\n        let pointOptions = options;\n        if (doEval) {\n            pointOptions = deepExtend({}, options);\n            evalOptions(pointOptions, {\n                value: value,\n                series: series,\n                dataItem: fields.dataItem\n            }, state);\n        }\n\n        return pointOptions;\n    }\n\n    pointType() {\n        return LinePoint;\n    }\n\n    pointOptions(series, seriesIx) {\n        let options = this.seriesOptions[seriesIx];\n        if (!options) {\n            const defaults = this.pointType().prototype.defaults;\n            this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n                markers: {\n                    opacity: series.opacity\n                },\n                tooltip: {\n                    format: this.options.tooltip.format\n                },\n                labels: {\n                    format: this.options.labels.format\n                }\n            }, series);\n        }\n\n        return options;\n    }\n\n    createPoint(value, fields) {\n        const series = fields.series;\n        let pointOptions = this.pointOptions(series, fields.seriesIx);\n        let color = fields.color || series.color;\n\n        pointOptions = this.evalPointOptions(pointOptions, value, fields);\n\n        if (isFunction(series.color)) {\n            color = pointOptions.color;\n        }\n\n        const point = new LinePoint(value, pointOptions);\n        point.color = color;\n\n        this.append(point);\n\n        return point;\n    }\n\n    seriesAxes(series) {\n        const { xAxis: xAxisName, yAxis: yAxisName } = series;\n        const plotArea = this.plotArea;\n        const xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;\n        const yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;\n\n        if (!xAxis) {\n            throw new Error(\"Unable to locate X axis with name \" + xAxisName);\n        }\n\n        if (!yAxis) {\n            throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\n        }\n\n        return {\n            x: xAxis,\n            y: yAxis\n        };\n    }\n\n    reflow(targetBox) {\n        const chartPoints = this.points;\n        const limit = !this.options.clip;\n        let pointIx = 0;\n\n\n        this.traverseDataPoints((value, fields) => {\n            const point = chartPoints[pointIx++];\n            const seriesAxes = this.seriesAxes(fields.series);\n            const slotX = seriesAxes.x.getSlot(value.x, value.x, limit);\n            const slotY = seriesAxes.y.getSlot(value.y, value.y, limit);\n\n            if (point) {\n                if (slotX && slotY) {\n                    const pointSlot = this.pointSlot(slotX, slotY);\n                    point.reflow(pointSlot);\n                } else {\n                    point.visible = false;\n                }\n            }\n        });\n\n        this.box = targetBox;\n    }\n\n    pointSlot(slotX, slotY) {\n        return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n    }\n\n    traverseDataPoints(callback) {\n        const { options: { series }, seriesPoints } = this;\n\n        for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            const currentSeries = series[seriesIx];\n            const currentSeriesPoints = seriesPoints[seriesIx];\n            if (!currentSeriesPoints) {\n                seriesPoints[seriesIx] = [];\n            }\n\n            for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n                const { valueFields: value, fields } = this.plotArea.bindPoint(currentSeries, pointIx);\n\n                callback(value, deepExtend({\n                    pointIx: pointIx,\n                    series: currentSeries,\n                    seriesIx: seriesIx,\n                    dataItem: currentSeries.data[pointIx],\n                    owner: this\n                }, fields));\n            }\n        }\n    }\n\n    formatPointValue(point, format) {\n        const value = point.value;\n        return this.chartService.format.auto(format, value.x, value.y);\n    }\n\n    animationPoints() {\n        const points = this.points;\n        const result = [];\n        for (let idx = 0; idx < points.length; idx++) {\n            result.push((points[idx] || {}).marker);\n        }\n        return result;\n    }\n}\nsetDefaultOptions(ScatterChart, {\n    series: [],\n    tooltip: {\n        format: \"{0}, {1}\"\n    },\n    labels: {\n        format: \"{0}, {1}\"\n    },\n    clip: true\n});\ndeepExtend(ScatterChart.prototype, ClipAnimationMixin);\n\nexport default ScatterChart;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}