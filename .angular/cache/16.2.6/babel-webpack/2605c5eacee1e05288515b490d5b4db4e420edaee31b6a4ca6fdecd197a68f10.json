{"ast":null,"code":"import { DateObject } from '../common/dateobject';\nimport { approximateStringMatching } from './utils';\nimport { KeyCode } from '../common/keycode';\nimport { Key } from '../common/key';\nimport { extend, isPresent, isDocumentAvailable, millisecondDigitsInFormat, millisecondStepFor, isValidDate, deepExtend } from '../common/utils';\nimport { Observable } from '../common/observable';\nimport { DateInputInteractionMode } from './interaction-mode';\nimport { isEqual, cloneDate } from '@progress/kendo-date-math';\nimport { Constants } from '../common/constants';\nconst DEFAULT_SEGMENT_STEP = 1;\nconst DRAG_START = \"dragStart\";\nconst DROP = \"drop\";\nconst TOUCH_START = \"touchstart\";\nconst MOUSE_DOWN = \"mousedown\";\nconst MOUSE_UP = \"mouseup\";\nconst CLICK = \"click\";\nconst INPUT = \"input\";\nconst KEY_DOWN = \"keydown\";\nconst FOCUS = \"focus\";\nconst BLUR = \"blur\";\nconst PASTE = \"paste\";\nconst MOUSE_SCROLL = \"DOMMouseScroll\";\nconst MOUSE_WHEEL = \"mousewheel\";\nconst VALUE_CHANGE = \"valueChange\";\nconst INPUT_END = \"inputEnd\";\nconst BLUR_END = \"blurEnd\";\nconst FOCUS_END = \"focusEnd\";\nconst CHANGE = \"change\";\nconst defaultDateInputOptions = {\n  format: \"d\",\n  hasPlaceholder: false,\n  placeholder: null,\n  cycleTime: true,\n  locale: null,\n  steps: {\n    millisecond: DEFAULT_SEGMENT_STEP,\n    second: DEFAULT_SEGMENT_STEP,\n    minute: DEFAULT_SEGMENT_STEP,\n    hour: DEFAULT_SEGMENT_STEP,\n    day: DEFAULT_SEGMENT_STEP,\n    month: DEFAULT_SEGMENT_STEP,\n    year: DEFAULT_SEGMENT_STEP\n  },\n  formatPlaceholder: null,\n  events: {\n    [VALUE_CHANGE]: null,\n    [INPUT]: null,\n    [INPUT_END]: null,\n    [FOCUS]: null,\n    [FOCUS_END]: null,\n    [BLUR]: null,\n    [BLUR_END]: null,\n    [KEY_DOWN]: null,\n    [MOUSE_WHEEL]: null,\n    [CHANGE]: null\n  },\n  selectNearestSegmentOnFocus: false,\n  selectPreviousSegmentOnBackspace: false,\n  enableMouseWheel: false,\n  allowCaretMode: false,\n  autoSwitchParts: true,\n  autoSwitchKeys: [],\n  twoDigitYearMax: Constants.twoDigitYearMax,\n  autoCorrectParts: true,\n  autoFill: false\n};\nexport class DateInput extends Observable {\n  constructor(element, options) {\n    super(options);\n    this.dateObject = null;\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    this.currentText = '';\n    this.currentFormat = '';\n    this.interactionMode = DateInputInteractionMode.None;\n    this.previousElementSelection = {\n      start: 0,\n      end: 0\n    };\n    this.init(element, options);\n  }\n  get value() {\n    return this.dateObject && this.dateObject.getValue();\n  }\n  init(element, options) {\n    let dateValue = isValidDate(this.options.value) ? cloneDate(this.options.value) : new Date(options.formattedValue);\n    if (!isValidDate(dateValue)) {\n      dateValue = null;\n    }\n    this.element = element;\n    // this.element._kendoWidget = this;\n    this.options = deepExtend({}, defaultDateInputOptions, options);\n    this.intl = this.options.intlService;\n    this.dateObject = this.createDateObject();\n    this.dateObject.setValue(dateValue);\n    this.setTextAndFormat();\n    this.bindEvents();\n    this.resetSegmentValue = true;\n    this.interactionMode = DateInputInteractionMode.None;\n    this.forceUpdate();\n  }\n  destroy() {\n    this.unbindEvents();\n    this.dateObject = null;\n    super.destroy();\n  }\n  bindEvents() {\n    this.onElementDragStart = this.onElementDragStart.bind(this);\n    this.element.addEventListener(DRAG_START, this.onElementDragStart);\n    this.onElementDrop = this.onElementDrop.bind(this);\n    this.element.addEventListener(DROP, this.onElementDrop);\n    this.onElementClick = this.onElementClick.bind(this);\n    this.element.addEventListener(CLICK, this.onElementClick);\n    this.onElementMouseDown = this.onElementMouseDown.bind(this);\n    this.element.addEventListener(MOUSE_DOWN, this.onElementMouseDown);\n    this.element.addEventListener(TOUCH_START, this.onElementMouseDown);\n    this.onElementMouseUp = this.onElementMouseUp.bind(this);\n    this.element.addEventListener(MOUSE_UP, this.onElementMouseUp);\n    this.onElementInput = this.onElementInput.bind(this);\n    this.element.addEventListener(INPUT, this.onElementInput);\n    this.onElementKeyDown = this.onElementKeyDown.bind(this);\n    this.element.addEventListener(KEY_DOWN, this.onElementKeyDown);\n    this.onElementFocus = this.onElementFocus.bind(this);\n    this.element.addEventListener(FOCUS, this.onElementFocus);\n    this.onElementBlur = this.onElementBlur.bind(this);\n    this.element.addEventListener(BLUR, this.onElementBlur);\n    this.onElementChange = this.onElementChange.bind(this);\n    this.element.addEventListener(CHANGE, this.onElementChange);\n    this.onElementPaste = this.onElementPaste.bind(this);\n    this.element.addEventListener(PASTE, this.onElementPaste);\n    this.onElementMouseWheel = this.onElementMouseWheel.bind(this);\n    this.element.addEventListener(MOUSE_SCROLL, this.onElementMouseWheel);\n    this.element.addEventListener(MOUSE_WHEEL, this.onElementMouseWheel);\n  }\n  unbindEvents() {\n    this.element.removeEventListener(DRAG_START, this.onElementDragStart);\n    this.element.removeEventListener(DROP, this.onElementDrop);\n    this.element.removeEventListener(TOUCH_START, this.onElementMouseDown);\n    this.element.removeEventListener(MOUSE_DOWN, this.onElementMouseDown);\n    this.element.removeEventListener(MOUSE_UP, this.onElementMouseUp);\n    this.element.removeEventListener(CLICK, this.onElementClick);\n    this.element.removeEventListener(INPUT, this.onElementInput);\n    this.element.removeEventListener(KEY_DOWN, this.onElementKeyDown);\n    this.element.removeEventListener(FOCUS, this.onElementFocus);\n    this.element.removeEventListener(BLUR, this.onElementBlur);\n    this.element.removeEventListener(CHANGE, this.onElementChange);\n    this.element.removeEventListener(PASTE, this.onElementPaste);\n    this.element.removeEventListener(MOUSE_SCROLL, this.onElementMouseWheel);\n    this.element.removeEventListener(MOUSE_WHEEL, this.onElementMouseWheel);\n  }\n  setOptions(options, refresh = false) {\n    this.options = deepExtend({}, this.options, options);\n    this.setDateObjectOptions();\n    if (refresh) {\n      this.unbindEvents();\n      this.init(this.element, this.options);\n    }\n  }\n  /**\n   * @hidden\n   */\n  setDateObjectOptions() {\n    if (this.dateObject) {\n      const newOptions = this.getDateObjectOptions();\n      this.dateObject.setOptions(newOptions);\n    }\n  }\n  /**\n   * @hidden\n   */\n  resetLocale() {\n    this.unbindEvents();\n    this.init(this.element, this.options);\n  }\n  /**\n   * @hidden\n   */\n  isInCaretMode() {\n    return this.interactionMode === DateInputInteractionMode.Caret;\n  }\n  focus() {\n    this.element.focus();\n    if (this.options.selectNearestSegmentOnFocus) {\n      this.selectNearestSegment(0);\n    }\n  }\n  /**\n   * @hidden\n   */\n  onElementDragStart(e) {\n    e.preventDefault();\n  }\n  /**\n   * @hidden\n   */\n  onElementDrop(e) {\n    e.preventDefault();\n  }\n  /**\n   * @hidden\n   */\n  onElementMouseDown() {\n    this.mouseDownStarted = true;\n    this.focusedPriorToMouseDown = this.isActive;\n  }\n  /**\n   * @hidden\n   */\n  onElementMouseUp(e) {\n    this.mouseDownStarted = false;\n    e.preventDefault();\n  }\n  /**\n   * @hidden\n   */\n  onElementClick(e) {\n    this.mouseDownStarted = false;\n    this.switchedPartOnPreviousKeyAction = false;\n    const selection = this.selection;\n    if (this.isInCaretMode()) {\n      // explicitly refresh the input element value\n      // caret mode can change the number of symbols in the element\n      // thus clicking on a segment can result in incorrect selection\n      this.forceUpdate();\n    }\n    if (e.detail === 3) {\n      // when 3 clicks occur, leave the native event to handle the change\n      // this results in selecting the whole element value\n    } else {\n      if (this.isActive && this.options.selectNearestSegmentOnFocus) {\n        const selectionPresent = this.element.selectionStart !== this.element.selectionEnd;\n        const placeholderToggled = isPresent(this.options.placeholder) && !this.dateObject.hasValue() && !this.focusedPriorToMouseDown;\n        // focus first segment if the user hasn't selected something during mousedown and if the placeholder was just toggled\n        const selectFirstSegment = !selectionPresent && placeholderToggled;\n        const index = selectFirstSegment ? 0 : this.caret()[0];\n        this.selectNearestSegment(index);\n      } else {\n        this.setSelection(this.selectionByIndex(selection.start));\n      }\n    }\n  }\n  /**\n   * @hidden\n   */\n  onElementInput(e) {\n    this.triggerInput({\n      event: e\n    });\n    if (!this.element || !this.dateObject) {\n      return;\n    }\n    const switchedPartOnPreviousKeyAction = this.switchedPartOnPreviousKeyAction;\n    if (this.isPasteInProgress) {\n      if (this.options.allowCaretMode) {\n        // pasting should leave the input with caret\n        // thus allow direct input instead of selection mode\n        this.resetSegmentValue = false;\n      }\n      this.updateOnPaste(e);\n      this.isPasteInProgress = false;\n      return;\n    }\n    const keyDownEvent = this.keyDownEvent || {};\n    const isBackspaceKey = keyDownEvent.keyCode === KeyCode.BACKSPACE || keyDownEvent.key === Key.BACKSPACE;\n    const isDeleteKey = keyDownEvent.keyCode === KeyCode.DELETE || keyDownEvent.key === Key.DELETE;\n    const originalInteractionMode = this.interactionMode;\n    if (this.options.allowCaretMode && originalInteractionMode !== DateInputInteractionMode.Caret && !isDeleteKey && !isBackspaceKey) {\n      this.resetSegmentValue = true;\n    }\n    if (this.options.allowCaretMode) {\n      this.interactionMode = DateInputInteractionMode.Caret;\n    } else {\n      this.interactionMode = DateInputInteractionMode.Selection;\n    }\n    const hasCaret = this.isInCaretMode();\n    if (hasCaret && this.keyDownEvent.key === Key.SPACE) {\n      // do not allow custom \"holes\" in the date segments\n      this.restorePreviousInputEventState();\n      return;\n    }\n    const oldExistingDateValue = this.dateObject && this.dateObject.getValue();\n    const oldDateValue = this.dateObject ? this.dateObject.value : null;\n    const {\n      text: currentText,\n      format: currentFormat\n    } = this.dateObject.getTextAndFormat();\n    this.currentFormat = currentFormat;\n    let oldText = \"\";\n    if (hasCaret) {\n      if (isBackspaceKey || isDeleteKey) {\n        oldText = this.previousElementValue;\n      } else if (originalInteractionMode === DateInputInteractionMode.Caret) {\n        oldText = this.previousElementValue;\n      } else {\n        oldText = currentText;\n      }\n    } else {\n      oldText = currentText;\n    }\n    const newText = this.elementValue;\n    let diff = approximateStringMatching({\n      oldText: oldText,\n      newText: newText,\n      formatPattern: this.currentFormat,\n      selectionStart: this.selection.start,\n      isInCaretMode: hasCaret,\n      keyEvent: this.keyDownEvent\n    });\n    if (diff && diff.length && diff[0] && diff[0][1] !== Constants.formatSeparator) {\n      this.switchedPartOnPreviousKeyAction = false;\n    }\n    if (hasCaret && (!diff || diff.length === 0)) {\n      this.restorePreviousInputEventState();\n      return;\n    } else if (hasCaret && diff.length === 1) {\n      if (!diff[0] || !diff[0][0]) {\n        this.restorePreviousInputEventState();\n        return;\n      } else if (hasCaret && diff[0] && (diff[0][0] === Constants.formatSeparator || diff[0][1] === Constants.formatSeparator)) {\n        this.restorePreviousInputEventState();\n        return;\n      }\n    }\n    const navigationOnly = diff.length === 1 && diff[0][1] === Constants.formatSeparator;\n    const parsePartsResults = [];\n    let switchPart = false;\n    let error = null;\n    if (!navigationOnly) {\n      for (let i = 0; i < diff.length; i++) {\n        const parsePartResult = this.dateObject.parsePart({\n          symbol: diff[i][0],\n          currentChar: diff[i][1],\n          resetSegmentValue: this.resetSegmentValue,\n          cycleSegmentValue: !this.isInCaretMode(),\n          rawTextValue: this.element.value,\n          isDeleting: isBackspaceKey || isDeleteKey,\n          originalFormat: this.currentFormat\n        });\n        parsePartsResults.push(parsePartResult);\n        if (!parsePartResult.value) {\n          error = {\n            type: \"parse\"\n          };\n        }\n        switchPart = parsePartResult.switchToNext;\n      }\n    }\n    if (!this.options.autoSwitchParts) {\n      switchPart = false;\n    }\n    this.resetSegmentValue = false;\n    const hasFixedFormat = this.options.format === this.currentFormat ||\n    // all not fixed formats are 1 symbol, e.g. \"d\"\n    isPresent(this.options.format) && this.options.format.length > 1;\n    const lastParseResult = parsePartsResults[parsePartsResults.length - 1];\n    const lastParseResultHasNoValue = lastParseResult && !isPresent(lastParseResult.value);\n    const parsingFailedOnDelete = hasCaret && (isBackspaceKey || isDeleteKey) && lastParseResultHasNoValue;\n    const resetPart = lastParseResult ? lastParseResult.resetPart : false;\n    const newExistingDateValue = this.dateObject.getValue();\n    const hasExistingDateValueChanged = !isEqual(oldExistingDateValue, newExistingDateValue);\n    const newDateValue = this.dateObject.value;\n    let symbolForSelection;\n    const currentSelection = this.selection;\n    if (hasCaret) {\n      const diffChar = diff && diff.length > 0 ? diff[0][0] : null;\n      let hasLeadingZero = this.dateObject.getLeadingZero()[diffChar];\n      if (diff.length && diff[0][0] !== Constants.formatSeparator) {\n        if (switchPart) {\n          this.forceUpdateWithSelection();\n          this.switchDateSegment(1);\n        } else if (resetPart) {\n          symbolForSelection = this.currentFormat[currentSelection.start];\n          if (symbolForSelection) {\n            this.forceUpdate();\n            this.setSelection(this.selectionBySymbol(symbolForSelection));\n          } else {\n            this.restorePreviousInputEventState();\n          }\n        } else if (parsingFailedOnDelete) {\n          this.forceUpdate();\n          if (diff.length && diff[0][0] !== Constants.formatSeparator) {\n            this.setSelection(this.selectionBySymbol(diff[0][0]));\n          }\n        } else if (lastParseResultHasNoValue) {\n          if (e.data === \"0\" && hasLeadingZero) {\n            // do not reset element value on a leading zero\n            // wait for consecutive input to determine the value\n          } else if (isPresent(oldExistingDateValue) && !isPresent(newExistingDateValue)) {\n            this.restorePreviousInputEventState();\n          } else if (!isPresent(oldExistingDateValue) && isPresent(newExistingDateValue)) {\n            this.forceUpdateWithSelection();\n          } else if (isPresent(oldExistingDateValue) && isPresent(newExistingDateValue)) {\n            if (hasExistingDateValueChanged) {\n              this.forceUpdateWithSelection();\n            } else {\n              this.restorePreviousInputEventState();\n            }\n          } else if (!isPresent(oldExistingDateValue) && !isPresent(newExistingDateValue)) {\n            this.forceUpdateWithSelection();\n          } else if (oldDateValue !== newDateValue) {\n            // this can happen on auto correct when no valid value is parsed\n          } else {\n            this.restorePreviousInputEventState();\n          }\n        } else if (!lastParseResultHasNoValue) {\n          // the user types a valid but incomplete date (e.g. year \"123\" with format \"yyyy\")\n          // let them continue typing, but refresh for not fixed formats\n          if (!hasFixedFormat) {\n            this.forceUpdateWithSelection();\n          }\n        }\n      } else {\n        if (!this.options.autoSwitchParts && diff[0][1] === Constants.formatSeparator) {\n          // do not change the selection when a separator is pressed\n          // this should happen only if autoSwitchKeys contains the separator explicitly\n        } else {\n          this.setSelection(this.selectionBySymbol(diff[0][0]));\n        }\n      }\n    } else if (!hasCaret) {\n      this.forceUpdate();\n      if (diff.length && diff[0][0] !== Constants.formatSeparator) {\n        this.setSelection(this.selectionBySymbol(diff[0][0]));\n      }\n      if (this.options.autoSwitchParts) {\n        if (navigationOnly) {\n          this.resetSegmentValue = true;\n          if (!switchedPartOnPreviousKeyAction) {\n            this.switchDateSegment(1);\n          }\n          this.switchedPartOnPreviousKeyAction = true;\n        } else if (switchPart) {\n          this.switchDateSegment(1);\n          this.switchedPartOnPreviousKeyAction = true;\n        }\n      } else {\n        if (lastParseResult && lastParseResult.switchToNext) {\n          // the value is complete and should be switched, but the \"autoSwitchParts\" option prevents this\n          // ensure that the segment value can be reset on next input\n          this.resetSegmentValue = true;\n        } else if (navigationOnly) {\n          this.resetSegmentValue = true;\n          if (!switchedPartOnPreviousKeyAction) {\n            this.switchDateSegment(1);\n          }\n          this.switchedPartOnPreviousKeyAction = true;\n        }\n      }\n      if (isBackspaceKey && this.options.selectPreviousSegmentOnBackspace) {\n        // kendo angular have this UX\n        this.switchDateSegment(-1);\n      }\n    }\n    this.tryTriggerValueChange({\n      oldValue: oldExistingDateValue,\n      event: e\n    });\n    this.triggerInputEnd({\n      event: e,\n      error: error\n    });\n    if (hasCaret) {\n      // a format like \"F\" can dynamically change the resolved format pattern based on the value, e.g.\n      // \"Tuesday, February 1, 2022 3:04:05 AM\" becomes\n      // \"Wednesday, February 2, 2022 3:04:05 AM\" giving a diff of 2 (\"Tuesday\".length - \"Wednesday\".length)\n      this.setTextAndFormat();\n    }\n  }\n  /**\n   * @hidden\n   */\n  onElementFocus(e) {\n    if (this.triggerFocus({\n      event: e\n    })) {\n      return;\n    }\n    this.isActive = true;\n    this.interactionMode = DateInputInteractionMode.None;\n    this.switchedPartOnPreviousKeyAction = false;\n    this.refreshElementValue();\n    if (!this.mouseDownStarted) {\n      this.caret(0, this.elementValue.length);\n    }\n    this.mouseDownStarted = false;\n    this.triggerFocusEnd({\n      event: e\n    });\n  }\n  /**\n   * @hidden\n   */\n  onElementBlur(e) {\n    this.resetSegmentValue = true;\n    this.isActive = false;\n    if (this.triggerBlur({\n      event: e\n    })) {\n      return;\n    }\n    if (this.options.autoFill) {\n      this.autoFill();\n    }\n    this.interactionMode = DateInputInteractionMode.None;\n    this.switchedPartOnPreviousKeyAction = false;\n    this.refreshElementValue();\n    this.triggerBlurEnd({\n      event: e\n    });\n  }\n  /**\n   * @hidden\n   */\n  onElementChange(e) {\n    this.triggerChange({\n      event: e\n    });\n  }\n  /**\n   * @hidden\n   */\n  onElementKeyDown(e) {\n    if (this.triggerKeyDown({\n      event: e\n    })) {\n      return;\n    }\n    const {\n      start,\n      end\n    } = this.selection;\n    this.keyDownEvent = e;\n    this.previousElementValue = this.element.value;\n    this.previousElementSelection = {\n      start,\n      end\n    };\n    if (this.keyEventMatchesAutoSwitchKeys(e)) {\n      const isTabKey = e.keyCode === KeyCode.TAB;\n      if (isTabKey) {\n        const {\n          start: selectionStart,\n          end: selectionEnd\n        } = this.selection;\n        if (e.shiftKey && isTabKey) {\n          this.switchDateSegment(-1);\n        } else {\n          this.switchDateSegment(1);\n        }\n        if (selectionStart !== this.selection.start || selectionEnd !== this.selection.end) {\n          // when the selection changes, prevent the default Tab behavior\n          e.preventDefault();\n          return;\n        }\n      } else {\n        // do not allow the \"input\" event to be triggered\n        e.preventDefault();\n        this.switchDateSegment(1);\n        return;\n      }\n    }\n    const symbol = this.currentFormat[this.selection.start];\n    const step = this.getStepFromSymbol(symbol);\n    let shouldPreventDefault = false;\n    if (e.altKey || e.ctrlKey || e.metaKey || e.keyCode === KeyCode.TAB) {\n      return;\n    }\n    switch (e.keyCode) {\n      case KeyCode.ARROW_LEFT:\n        this.switchDateSegment(-1);\n        shouldPreventDefault = true;\n        this.switchedPartOnPreviousKeyAction = false;\n        break;\n      case KeyCode.ARROW_UP:\n        this.modifyDateSegmentValue(step, symbol, event);\n        shouldPreventDefault = true;\n        this.switchedPartOnPreviousKeyAction = false;\n        break;\n      case KeyCode.ARROW_RIGHT:\n        this.switchDateSegment(1);\n        shouldPreventDefault = true;\n        this.switchedPartOnPreviousKeyAction = false;\n        break;\n      case KeyCode.ARROW_DOWN:\n        this.modifyDateSegmentValue(-step, symbol, event);\n        shouldPreventDefault = true;\n        this.switchedPartOnPreviousKeyAction = false;\n        break;\n      case KeyCode.ENTER:\n        // todo: handle \"change\" event\n        break;\n      case KeyCode.HOME:\n        this.selectNearestSegment(0);\n        shouldPreventDefault = true;\n        this.switchedPartOnPreviousKeyAction = false;\n        this.resetSegmentValue = true;\n        break;\n      case KeyCode.END:\n        this.selectNearestSegment(this.elementValue.length);\n        shouldPreventDefault = true;\n        this.switchedPartOnPreviousKeyAction = false;\n        this.resetSegmentValue = true;\n        break;\n      default:\n        // allow the \"input\" event to handle the change\n        return;\n    }\n    if (shouldPreventDefault) {\n      e.preventDefault();\n    }\n  }\n  /**\n   * @hidden\n   */\n  onElementPaste() {\n    this.isPasteInProgress = true;\n  }\n  /**\n   * @hidden\n   */\n  onElementMouseWheel(e) {\n    if (!this.options.enableMouseWheel || this.triggerMouseWheel({\n      event: e\n    })) {\n      return;\n    }\n    if (!this.isActive) {\n      return;\n    }\n    const event = e;\n    if (event.shiftKey) {\n      this.switchDateSegment((event.wheelDelta || -event.detail) > 0 ? -1 : 1);\n    } else {\n      this.modifyDateSegmentValue((event.wheelDelta || -event.detail) > 0 ? 1 : -1);\n    }\n    event.returnValue = false;\n    if (event.preventDefault) {\n      event.preventDefault();\n    }\n    if (event.stopPropagation) {\n      event.stopPropagation();\n    }\n  }\n  updateOnPaste(e) {\n    let value = this.intl.parseDate(this.elementValue, this.inputFormat) || this.value;\n    if (isPresent(value) && this.dateObject.shouldNormalizeCentury()) {\n      value = this.dateObject.normalizeCentury(value);\n    }\n    const oldDateObjectValue = this.dateObject && this.dateObject.getValue();\n    this.writeValue(value);\n    this.tryTriggerValueChange({\n      oldValue: oldDateObjectValue,\n      event: e\n    });\n  }\n  get elementValue() {\n    return (this.element || {}).value || '';\n  }\n  get inputFormat() {\n    if (!this.options.format) {\n      return Constants.defaultDateFormat;\n    }\n    if (typeof this.options.format === 'string') {\n      return this.options.format;\n    } else {\n      return this.options.format.inputFormat;\n    }\n  }\n  get displayFormat() {\n    if (!this.options.format) {\n      return Constants.defaultDateFormat;\n    }\n    if (typeof this.options.format === 'string') {\n      return this.options.format;\n    } else {\n      return this.options.format.displayFormat;\n    }\n  }\n  get selection() {\n    let returnValue = {\n      start: 0,\n      end: 0\n    };\n    if (this.element !== null && this.element.selectionStart !== undefined) {\n      returnValue = {\n        start: this.element.selectionStart,\n        end: this.element.selectionEnd\n      };\n    }\n    return returnValue;\n  }\n  setSelection(selection) {\n    if (this.element && document.activeElement === this.element) {\n      this.element.setSelectionRange(selection.start, selection.end);\n      if (selection.start !== selection.end) {\n        this.interactionMode = DateInputInteractionMode.Selection;\n      }\n    }\n  }\n  /**\n   * @hidden\n   */\n  selectionBySymbol(symbol) {\n    let start = -1;\n    let end = 0;\n    for (let i = 0; i < this.currentFormat.length; i++) {\n      if (this.currentFormat[i] === symbol) {\n        end = i + 1;\n        if (start === -1) {\n          start = i;\n        }\n      }\n    }\n    if (start < 0) {\n      start = 0;\n    }\n    if (!this.options.autoCorrectParts && this.currentFormat.length !== this.currentText.length) {\n      if (this.currentFormat.length < this.currentText.length) {\n        end += this.currentText.length - this.currentFormat.length;\n      } else {\n        end = Math.max(0, end - (this.currentFormat.length - this.currentText.length));\n      }\n    }\n    return {\n      start,\n      end\n    };\n  }\n  /**\n   * @hidden\n   */\n  selectionByIndex(index) {\n    let selection = {\n      start: index,\n      end: index\n    };\n    for (let i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {\n      if (i < this.currentFormat.length && this.currentFormat[i] !== Constants.formatSeparator) {\n        selection = this.selectionBySymbol(this.currentFormat[i]);\n        break;\n      }\n      if (j >= 0 && this.currentFormat[j] !== Constants.formatSeparator) {\n        selection = this.selectionBySymbol(this.currentFormat[j]);\n        break;\n      }\n    }\n    return selection;\n  }\n  switchDateSegment(offset) {\n    const selection = this.selection;\n    if (this.isInCaretMode()) {\n      let start = selection.start;\n      const currentSymbol = this.currentFormat[start - 1];\n      let symbol = \"\";\n      let symbolCandidate = \"\";\n      if (offset < 0) {\n        for (let i = start + offset; i >= 0; i--) {\n          symbolCandidate = this.currentFormat[i];\n          if (symbolCandidate !== Constants.formatSeparator && symbolCandidate !== currentSymbol) {\n            start = i;\n            symbol = symbolCandidate;\n            break;\n          }\n        }\n      } else {\n        for (let i = start + offset; i < this.currentFormat.length; i++) {\n          symbolCandidate = this.currentFormat[i];\n          if (symbolCandidate !== Constants.formatSeparator && symbolCandidate !== currentSymbol) {\n            start = i;\n            symbol = symbolCandidate;\n            break;\n          }\n        }\n      }\n      if (symbol) {\n        this.forceUpdate();\n        this.setSelection(this.selectionBySymbol(symbol));\n        this.interactionMode = DateInputInteractionMode.Selection;\n        return;\n      }\n    }\n    this.interactionMode = DateInputInteractionMode.None;\n    let {\n      start: selectionStart,\n      end: selectionEnd\n    } = this.selection;\n    if (selectionStart < selectionEnd && this.currentFormat[selectionStart] !== this.currentFormat[selectionEnd - 1]) {\n      this.setSelection(this.selectionByIndex(offset > 0 ? selectionStart : selectionEnd - 1));\n      this.resetSegmentValue = true;\n      this.interactionMode = DateInputInteractionMode.None;\n      return;\n    }\n    const previousFormatSymbol = this.currentFormat[selectionStart];\n    let a = selectionStart + offset;\n    while (a > 0 && a < this.currentFormat.length) {\n      if (this.currentFormat[a] !== previousFormatSymbol && this.currentFormat[a] !== Constants.formatSeparator) {\n        break;\n      }\n      a += offset;\n    }\n    if (this.currentFormat[a] === Constants.formatSeparator) {\n      // no known symbol is found\n      return;\n    }\n    let b = a;\n    while (b >= 0 && b < this.currentFormat.length) {\n      if (this.currentFormat[b] !== this.currentFormat[a]) {\n        break;\n      }\n      b += offset;\n    }\n    if (a > b && (b + 1 !== selectionStart || a + 1 !== selectionEnd)) {\n      this.setSelection({\n        start: b + 1,\n        end: a + 1\n      });\n      this.resetSegmentValue = true;\n    } else if (a < b && (a !== selectionStart || b !== selectionEnd)) {\n      this.setSelection({\n        start: a,\n        end: b\n      });\n      this.resetSegmentValue = true;\n    }\n    this.interactionMode = DateInputInteractionMode.None;\n  }\n  modifyDateSegmentValue(offset, symbol = \"\", event = {}) {\n    if (!this.dateObject || this.options.readonly) {\n      return;\n    }\n    const oldValue = this.value;\n    let step = DEFAULT_SEGMENT_STEP;\n    const caret = this.caret();\n    symbol = symbol || this.currentFormat[caret[0]];\n    if (symbol === \"S\" && (!this.options.steps.millisecond || this.options.steps.millisecond === DEFAULT_SEGMENT_STEP)) {\n      const msDigits = millisecondDigitsInFormat(this.inputFormat);\n      step = millisecondStepFor(msDigits);\n    }\n    this.dateObject.modifyPart(symbol, step * offset);\n    this.tryTriggerValueChange({\n      oldValue: oldValue,\n      event: event\n    });\n    this.forceUpdate();\n    this.setSelection(this.selectionBySymbol(symbol));\n  }\n  /**\n   * @hidden\n   */\n  tryTriggerValueChange(args = {\n    oldValue: null,\n    event: {}\n  }) {\n    if (!isEqual(this.value, args.oldValue)) {\n      return this.triggerValueChange(args);\n    }\n  }\n  /**\n   * @hidden\n   */\n  triggerValueChange(args = {\n    oldValue: null,\n    event: {}\n  }) {\n    return this.trigger(VALUE_CHANGE, extend(args, {\n      value: this.value\n    }));\n  }\n  /**\n   * @hidden\n   */\n  triggerInput(args = {\n    event: {}\n  }) {\n    return this.trigger(INPUT, extend(args, {\n      value: this.value\n    }));\n  }\n  /**\n   * @hidden\n   */\n  triggerInputEnd(args = {\n    event: {},\n    error: null\n  }) {\n    return this.trigger(INPUT_END, extend(args, {\n      value: this.value\n    }));\n  }\n  /**\n   * @hidden\n   */\n  triggerFocus(args = {\n    event: {}\n  }) {\n    return this.trigger(FOCUS, extend({}, args));\n  }\n  /**\n   * @hidden\n   */\n  triggerFocusEnd(args = {\n    event: {}\n  }) {\n    return this.trigger(FOCUS_END, extend({}, args));\n  }\n  /**\n   * @hidden\n   */\n  triggerBlur(args = {\n    event: {}\n  }) {\n    return this.trigger(BLUR, extend({}, args));\n  }\n  /**\n   * @hidden\n   */\n  triggerBlurEnd(args = {\n    event: {}\n  }) {\n    return this.trigger(BLUR_END, extend({}, args));\n  }\n  /**\n   * @hidden\n   */\n  triggerChange(args = {\n    event: {}\n  }) {\n    return this.trigger(CHANGE, extend(args, {\n      value: this.value\n    }));\n  }\n  /**\n   * @hidden\n   */\n  triggerKeyDown(args = {\n    event: {}\n  }) {\n    return this.trigger(KEY_DOWN, extend({}, args));\n  }\n  /**\n   * @hidden\n   */\n  triggerMouseWheel(args = {\n    event: {}\n  }) {\n    return this.trigger(MOUSE_WHEEL, extend({}, args));\n  }\n  /**\n   * @hidden\n   */\n  forceUpdate() {\n    this.setTextAndFormat();\n    this.refreshElementValue();\n  }\n  /**\n   * @hidden\n   */\n  forceUpdateWithSelection() {\n    const {\n      start,\n      end\n    } = this.selection;\n    const elementValueLength = this.elementValue.length;\n    this.forceUpdate();\n    const selectionOffset = this.elementValue.length - elementValueLength;\n    this.setSelection({\n      start: start + selectionOffset,\n      end: end + selectionOffset\n    });\n  }\n  /**\n   * @hidden\n   */\n  setTextAndFormat() {\n    const {\n      text: currentText,\n      format: currentFormat\n    } = this.dateObject.getTextAndFormat();\n    this.currentFormat = currentFormat;\n    this.currentText = currentText;\n  }\n  /**\n   * @hidden\n   */\n  setElementValue(value) {\n    this.element.value = value;\n  }\n  /**\n   * @hidden\n   */\n  getStepFromSymbol(symbol) {\n    /* eslint-disable no-fallthrough */\n    switch (symbol) {\n      case \"S\":\n        return Number(this.options.steps.millisecond);\n      case \"s\":\n        return Number(this.options.steps.second);\n      case \"m\":\n        return Number(this.options.steps.minute);\n      // represents hour as value from 01 through 12\n      case \"h\":\n      // represents hour as value from 01 through 23\n      case \"H\":\n        return Number(this.options.steps.hour);\n      case \"M\":\n        return Number(this.options.steps.month);\n      // there is no 'D' format specifier for day\n      case \"d\":\n      // used for formats such as \"EEEE, MMMM d, yyyy\",\n      // where \"EEEE\" stands for full name of the day e.g. Monday\n      case \"E\":\n        return Number(this.options.steps.day);\n      // there is no 'Y' format specifier for year\n      case \"y\":\n        return Number(this.options.steps.year);\n      default:\n        return DEFAULT_SEGMENT_STEP;\n    }\n    /* eslint-enable no-fallthrough */\n  }\n  /**\n   * @hidden\n   */\n  restorePreviousInputEventState() {\n    this.restorePreviousElementValue();\n    this.restorePreviousElementSelection();\n  }\n  /**\n   * @hidden\n   */\n  restorePreviousElementValue() {\n    this.setElementValue(this.previousElementValue || '');\n  }\n  /**\n   * @hidden\n   */\n  restorePreviousElementSelection() {\n    const {\n      start,\n      end\n    } = this.previousElementSelection;\n    this.setSelection({\n      start: start || 0,\n      end: end || 0\n    });\n  }\n  writeValue(value) {\n    this.verifyValue(value);\n    this.dateObject = this.getDateObject(value);\n    this.refreshElementValue();\n  }\n  verifyValue(value) {\n    if (value && !isValidDate(value)) {\n      throw new Error(\"The 'value' should be a valid JavaScript Date instance.\");\n    }\n  }\n  refreshElementValue() {\n    const start = this.caret()[0];\n    const element = this.element;\n    const format = this.isActive ? this.inputFormat : this.displayFormat;\n    const {\n      text: currentText,\n      format: currentFormat\n    } = this.dateObject.getTextAndFormat(format);\n    this.currentFormat = currentFormat;\n    this.currentText = currentText;\n    const hasPlaceholder = this.options.hasPlaceholder || isPresent(this.options.placeholder);\n    const showPlaceholder = !this.isActive && hasPlaceholder && !this.dateObject.hasValue();\n    if (hasPlaceholder && isPresent(this.options.placeholder)) {\n      element.placeholder = this.options.placeholder;\n    }\n    const newElementValue = showPlaceholder ? \"\" : currentText;\n    this.previousElementValue = this.elementValue;\n    this.setElementValue(newElementValue);\n    if (this.isActive && !this.options.allowCaretMode && this.options.selectNearestSegmentOnFocus) {\n      this.selectNearestSegment(start);\n    }\n  }\n  /**\n   * @hidden\n   */\n  caret(start, end = start) {\n    const isPosition = start !== undefined;\n    let returnValue = [start, start];\n    const element = this.element;\n    if (isPosition && (this.options.disabled || this.options.readonly)) {\n      return undefined;\n    }\n    try {\n      if (element.selectionStart !== undefined) {\n        if (isPosition) {\n          if (isDocumentAvailable() && document.activeElement !== element) {\n            element.focus();\n          }\n          element.setSelectionRange(start, end);\n        }\n        returnValue = [element.selectionStart, element.selectionEnd];\n      }\n    } catch (e) {\n      returnValue = [];\n    }\n    return returnValue;\n  }\n  selectNearestSegment(index) {\n    // Finds the nearest (in both directions) known part.\n    for (let i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {\n      if (i < this.currentFormat.length && this.currentFormat[i] !== \"_\") {\n        this.selectDateSegment(this.currentFormat[i]);\n        return;\n      }\n      if (j >= 0 && this.currentFormat[j] !== \"_\") {\n        this.selectDateSegment(this.currentFormat[j]);\n        return;\n      }\n    }\n  }\n  selectDateSegment(symbol) {\n    let begin = -1;\n    let end = 0;\n    for (let i = 0; i < this.currentFormat.length; i++) {\n      if (this.currentFormat[i] === symbol) {\n        end = i + 1;\n        if (begin === -1) {\n          begin = i;\n        }\n      }\n    }\n    if (begin < 0) {\n      begin = 0;\n    }\n    this.caret(0, 0);\n    this.caret(begin, end);\n  }\n  /**\n   * @hidden\n   */\n  getDateObject(value) {\n    const {\n      leadingZero\n    } = this.dateObject || {} || null;\n    this.options.value = value;\n    const dateObject = this.createDateObject();\n    dateObject.setLeadingZero(this.isActive ? leadingZero : null);\n    return dateObject;\n  }\n  /* tslint:disable:align */\n  /**\n   * @hidden\n   */\n  createDateObject() {\n    const defaultOptions = this.getDateObjectOptions();\n    const dateObject = new DateObject(extend({}, defaultOptions));\n    return dateObject;\n  }\n  /**\n   * @hidden\n   */\n  getDateObjectOptions() {\n    const newOptions = {\n      intlService: this.options.intlService,\n      formatPlaceholder: this.options.formatPlaceholder ? this.options.formatPlaceholder : 'formatPattern',\n      format: this.inputFormat,\n      cycleTime: this.options.cycleTime,\n      twoDigitYearMax: this.options.twoDigitYearMax,\n      autoCorrectParts: this.options.autoCorrectParts,\n      value: this.options.value\n    };\n    return newOptions;\n  }\n  /* tslint:enable:align */\n  /**\n   * @hidden\n   */\n  keyEventMatchesAutoSwitchKeys(keyObject) {\n    const autoSwitchKeys = (this.options.autoSwitchKeys || []).map(x => x.toString().toLowerCase().trim());\n    if (autoSwitchKeys.indexOf(keyObject.keyCode.toString()) >= 0 || autoSwitchKeys.indexOf(keyObject.keyCode) >= 0 || autoSwitchKeys.indexOf(keyObject.key.toLowerCase().trim()) >= 0) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * @hidden\n   */\n  autoFill() {\n    let dateObject = this.dateObject,\n      currentDate = new Date(),\n      day,\n      month,\n      year,\n      hours,\n      minutes,\n      seconds;\n    if (dateObject.date || dateObject.month || dateObject.year || dateObject.hours || dateObject.minutes || dateObject.seconds) {\n      year = dateObject.year ? dateObject.value.getFullYear() : currentDate.getFullYear(), month = dateObject.month ? dateObject.value.getMonth() : currentDate.getMonth(), day = dateObject.date ? dateObject.value.getDate() : currentDate.getDate(), hours = dateObject.hours ? dateObject.value.getHours() : currentDate.getHours(), minutes = dateObject.minutes ? dateObject.value.getMinutes() : currentDate.getMinutes(), seconds = dateObject.seconds ? dateObject.value.getSeconds() : currentDate.getSeconds();\n      dateObject.setValue(new Date(year, month, day, hours, minutes, seconds));\n      this.refreshElementValue();\n      this.triggerChange();\n    }\n  }\n}","map":{"version":3,"names":["DateObject","approximateStringMatching","KeyCode","Key","extend","isPresent","isDocumentAvailable","millisecondDigitsInFormat","millisecondStepFor","isValidDate","deepExtend","Observable","DateInputInteractionMode","isEqual","cloneDate","Constants","DEFAULT_SEGMENT_STEP","DRAG_START","DROP","TOUCH_START","MOUSE_DOWN","MOUSE_UP","CLICK","INPUT","KEY_DOWN","FOCUS","BLUR","PASTE","MOUSE_SCROLL","MOUSE_WHEEL","VALUE_CHANGE","INPUT_END","BLUR_END","FOCUS_END","CHANGE","defaultDateInputOptions","format","hasPlaceholder","placeholder","cycleTime","locale","steps","millisecond","second","minute","hour","day","month","year","formatPlaceholder","events","selectNearestSegmentOnFocus","selectPreviousSegmentOnBackspace","enableMouseWheel","allowCaretMode","autoSwitchParts","autoSwitchKeys","twoDigitYearMax","autoCorrectParts","autoFill","DateInput","constructor","element","options","dateObject","currentText","currentFormat","interactionMode","None","previousElementSelection","start","end","init","value","getValue","dateValue","Date","formattedValue","intl","intlService","createDateObject","setValue","setTextAndFormat","bindEvents","resetSegmentValue","forceUpdate","destroy","unbindEvents","onElementDragStart","bind","addEventListener","onElementDrop","onElementClick","onElementMouseDown","onElementMouseUp","onElementInput","onElementKeyDown","onElementFocus","onElementBlur","onElementChange","onElementPaste","onElementMouseWheel","removeEventListener","setOptions","refresh","setDateObjectOptions","newOptions","getDateObjectOptions","resetLocale","isInCaretMode","Caret","focus","selectNearestSegment","e","preventDefault","mouseDownStarted","focusedPriorToMouseDown","isActive","switchedPartOnPreviousKeyAction","selection","detail","selectionPresent","selectionStart","selectionEnd","placeholderToggled","hasValue","selectFirstSegment","index","caret","setSelection","selectionByIndex","triggerInput","event","isPasteInProgress","updateOnPaste","keyDownEvent","isBackspaceKey","keyCode","BACKSPACE","key","isDeleteKey","DELETE","originalInteractionMode","Selection","hasCaret","SPACE","restorePreviousInputEventState","oldExistingDateValue","oldDateValue","text","getTextAndFormat","oldText","previousElementValue","newText","elementValue","diff","formatPattern","keyEvent","length","formatSeparator","navigationOnly","parsePartsResults","switchPart","error","i","parsePartResult","parsePart","symbol","currentChar","cycleSegmentValue","rawTextValue","isDeleting","originalFormat","push","type","switchToNext","hasFixedFormat","lastParseResult","lastParseResultHasNoValue","parsingFailedOnDelete","resetPart","newExistingDateValue","hasExistingDateValueChanged","newDateValue","symbolForSelection","currentSelection","diffChar","hasLeadingZero","getLeadingZero","forceUpdateWithSelection","switchDateSegment","selectionBySymbol","data","tryTriggerValueChange","oldValue","triggerInputEnd","triggerFocus","refreshElementValue","triggerFocusEnd","triggerBlur","triggerBlurEnd","triggerChange","triggerKeyDown","keyEventMatchesAutoSwitchKeys","isTabKey","TAB","shiftKey","step","getStepFromSymbol","shouldPreventDefault","altKey","ctrlKey","metaKey","ARROW_LEFT","ARROW_UP","modifyDateSegmentValue","ARROW_RIGHT","ARROW_DOWN","ENTER","HOME","END","triggerMouseWheel","wheelDelta","returnValue","stopPropagation","parseDate","inputFormat","shouldNormalizeCentury","normalizeCentury","oldDateObjectValue","writeValue","defaultDateFormat","displayFormat","undefined","document","activeElement","setSelectionRange","Math","max","j","offset","currentSymbol","symbolCandidate","previousFormatSymbol","a","b","readonly","msDigits","modifyPart","args","triggerValueChange","trigger","elementValueLength","selectionOffset","setElementValue","Number","restorePreviousElementValue","restorePreviousElementSelection","verifyValue","getDateObject","Error","showPlaceholder","newElementValue","isPosition","disabled","selectDateSegment","begin","leadingZero","setLeadingZero","defaultOptions","keyObject","map","x","toString","toLowerCase","trim","indexOf","currentDate","hours","minutes","seconds","date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-dateinputs-common/dist/es2015/dateinput/dateinput.js"],"sourcesContent":["import { DateObject } from '../common/dateobject';\nimport { approximateStringMatching } from './utils';\nimport { KeyCode } from '../common/keycode';\nimport { Key } from '../common/key';\nimport { extend, isPresent, isDocumentAvailable, millisecondDigitsInFormat, millisecondStepFor, isValidDate, deepExtend } from '../common/utils';\nimport { Observable } from '../common/observable';\nimport { DateInputInteractionMode } from './interaction-mode';\nimport { isEqual, cloneDate } from '@progress/kendo-date-math';\nimport { Constants } from '../common/constants';\nconst DEFAULT_SEGMENT_STEP = 1;\nconst DRAG_START = \"dragStart\";\nconst DROP = \"drop\";\nconst TOUCH_START = \"touchstart\";\nconst MOUSE_DOWN = \"mousedown\";\nconst MOUSE_UP = \"mouseup\";\nconst CLICK = \"click\";\nconst INPUT = \"input\";\nconst KEY_DOWN = \"keydown\";\nconst FOCUS = \"focus\";\nconst BLUR = \"blur\";\nconst PASTE = \"paste\";\nconst MOUSE_SCROLL = \"DOMMouseScroll\";\nconst MOUSE_WHEEL = \"mousewheel\";\nconst VALUE_CHANGE = \"valueChange\";\nconst INPUT_END = \"inputEnd\";\nconst BLUR_END = \"blurEnd\";\nconst FOCUS_END = \"focusEnd\";\nconst CHANGE = \"change\";\nconst defaultDateInputOptions = {\n    format: \"d\",\n    hasPlaceholder: false,\n    placeholder: null,\n    cycleTime: true,\n    locale: null,\n    steps: {\n        millisecond: DEFAULT_SEGMENT_STEP,\n        second: DEFAULT_SEGMENT_STEP,\n        minute: DEFAULT_SEGMENT_STEP,\n        hour: DEFAULT_SEGMENT_STEP,\n        day: DEFAULT_SEGMENT_STEP,\n        month: DEFAULT_SEGMENT_STEP,\n        year: DEFAULT_SEGMENT_STEP\n    },\n    formatPlaceholder: null,\n    events: {\n        [VALUE_CHANGE]: null,\n        [INPUT]: null,\n        [INPUT_END]: null,\n        [FOCUS]: null,\n        [FOCUS_END]: null,\n        [BLUR]: null,\n        [BLUR_END]: null,\n        [KEY_DOWN]: null,\n        [MOUSE_WHEEL]: null,\n        [CHANGE]: null\n    },\n    selectNearestSegmentOnFocus: false,\n    selectPreviousSegmentOnBackspace: false,\n    enableMouseWheel: false,\n    allowCaretMode: false,\n    autoSwitchParts: true,\n    autoSwitchKeys: [],\n    twoDigitYearMax: Constants.twoDigitYearMax,\n    autoCorrectParts: true,\n    autoFill: false\n};\nexport class DateInput extends Observable {\n    constructor(element, options) {\n        super(options);\n        this.dateObject = null;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        this.currentText = '';\n        this.currentFormat = '';\n        this.interactionMode = DateInputInteractionMode.None;\n        this.previousElementSelection = { start: 0, end: 0 };\n        this.init(element, options);\n    }\n    get value() {\n        return this.dateObject && this.dateObject.getValue();\n    }\n    init(element, options) {\n        let dateValue = isValidDate(this.options.value) ? cloneDate(this.options.value) : new Date(options.formattedValue);\n        if (!isValidDate(dateValue)) {\n            dateValue = null;\n        }\n        this.element = element;\n        // this.element._kendoWidget = this;\n        this.options = deepExtend({}, defaultDateInputOptions, options);\n        this.intl = this.options.intlService;\n        this.dateObject = this.createDateObject();\n        this.dateObject.setValue(dateValue);\n        this.setTextAndFormat();\n        this.bindEvents();\n        this.resetSegmentValue = true;\n        this.interactionMode = DateInputInteractionMode.None;\n        this.forceUpdate();\n    }\n    destroy() {\n        this.unbindEvents();\n        this.dateObject = null;\n        super.destroy();\n    }\n    bindEvents() {\n        this.onElementDragStart = this.onElementDragStart.bind(this);\n        this.element.addEventListener(DRAG_START, this.onElementDragStart);\n        this.onElementDrop = this.onElementDrop.bind(this);\n        this.element.addEventListener(DROP, this.onElementDrop);\n        this.onElementClick = this.onElementClick.bind(this);\n        this.element.addEventListener(CLICK, this.onElementClick);\n        this.onElementMouseDown = this.onElementMouseDown.bind(this);\n        this.element.addEventListener(MOUSE_DOWN, this.onElementMouseDown);\n        this.element.addEventListener(TOUCH_START, this.onElementMouseDown);\n        this.onElementMouseUp = this.onElementMouseUp.bind(this);\n        this.element.addEventListener(MOUSE_UP, this.onElementMouseUp);\n        this.onElementInput = this.onElementInput.bind(this);\n        this.element.addEventListener(INPUT, this.onElementInput);\n        this.onElementKeyDown = this.onElementKeyDown.bind(this);\n        this.element.addEventListener(KEY_DOWN, this.onElementKeyDown);\n        this.onElementFocus = this.onElementFocus.bind(this);\n        this.element.addEventListener(FOCUS, this.onElementFocus);\n        this.onElementBlur = this.onElementBlur.bind(this);\n        this.element.addEventListener(BLUR, this.onElementBlur);\n        this.onElementChange = this.onElementChange.bind(this);\n        this.element.addEventListener(CHANGE, this.onElementChange);\n        this.onElementPaste = this.onElementPaste.bind(this);\n        this.element.addEventListener(PASTE, this.onElementPaste);\n        this.onElementMouseWheel = this.onElementMouseWheel.bind(this);\n        this.element.addEventListener(MOUSE_SCROLL, this.onElementMouseWheel);\n        this.element.addEventListener(MOUSE_WHEEL, this.onElementMouseWheel);\n    }\n    unbindEvents() {\n        this.element.removeEventListener(DRAG_START, this.onElementDragStart);\n        this.element.removeEventListener(DROP, this.onElementDrop);\n        this.element.removeEventListener(TOUCH_START, this.onElementMouseDown);\n        this.element.removeEventListener(MOUSE_DOWN, this.onElementMouseDown);\n        this.element.removeEventListener(MOUSE_UP, this.onElementMouseUp);\n        this.element.removeEventListener(CLICK, this.onElementClick);\n        this.element.removeEventListener(INPUT, this.onElementInput);\n        this.element.removeEventListener(KEY_DOWN, this.onElementKeyDown);\n        this.element.removeEventListener(FOCUS, this.onElementFocus);\n        this.element.removeEventListener(BLUR, this.onElementBlur);\n        this.element.removeEventListener(CHANGE, this.onElementChange);\n        this.element.removeEventListener(PASTE, this.onElementPaste);\n        this.element.removeEventListener(MOUSE_SCROLL, this.onElementMouseWheel);\n        this.element.removeEventListener(MOUSE_WHEEL, this.onElementMouseWheel);\n    }\n    setOptions(options, refresh = false) {\n        this.options = deepExtend({}, this.options, options);\n        this.setDateObjectOptions();\n        if (refresh) {\n            this.unbindEvents();\n            this.init(this.element, this.options);\n        }\n    }\n    /**\n     * @hidden\n     */\n    setDateObjectOptions() {\n        if (this.dateObject) {\n            const newOptions = this.getDateObjectOptions();\n            this.dateObject.setOptions(newOptions);\n        }\n    }\n    /**\n     * @hidden\n     */\n    resetLocale() {\n        this.unbindEvents();\n        this.init(this.element, this.options);\n    }\n    /**\n     * @hidden\n     */\n    isInCaretMode() {\n        return this.interactionMode === DateInputInteractionMode.Caret;\n    }\n    focus() {\n        this.element.focus();\n        if (this.options.selectNearestSegmentOnFocus) {\n            this.selectNearestSegment(0);\n        }\n    }\n    /**\n     * @hidden\n     */\n    onElementDragStart(e) {\n        e.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    onElementDrop(e) {\n        e.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    onElementMouseDown() {\n        this.mouseDownStarted = true;\n        this.focusedPriorToMouseDown = this.isActive;\n    }\n    /**\n     * @hidden\n     */\n    onElementMouseUp(e) {\n        this.mouseDownStarted = false;\n        e.preventDefault();\n    }\n    /**\n     * @hidden\n     */\n    onElementClick(e) {\n        this.mouseDownStarted = false;\n        this.switchedPartOnPreviousKeyAction = false;\n        const selection = this.selection;\n        if (this.isInCaretMode()) {\n            // explicitly refresh the input element value\n            // caret mode can change the number of symbols in the element\n            // thus clicking on a segment can result in incorrect selection\n            this.forceUpdate();\n        }\n        if (e.detail === 3) {\n            // when 3 clicks occur, leave the native event to handle the change\n            // this results in selecting the whole element value\n        }\n        else {\n            if (this.isActive && this.options.selectNearestSegmentOnFocus) {\n                const selectionPresent = this.element.selectionStart !== this.element.selectionEnd;\n                const placeholderToggled = isPresent(this.options.placeholder) &&\n                    !this.dateObject.hasValue() &&\n                    !this.focusedPriorToMouseDown;\n                // focus first segment if the user hasn't selected something during mousedown and if the placeholder was just toggled\n                const selectFirstSegment = !selectionPresent && placeholderToggled;\n                const index = selectFirstSegment ? 0 : this.caret()[0];\n                this.selectNearestSegment(index);\n            }\n            else {\n                this.setSelection(this.selectionByIndex(selection.start));\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    onElementInput(e) {\n        this.triggerInput({ event: e });\n        if (!this.element || !this.dateObject) {\n            return;\n        }\n        const switchedPartOnPreviousKeyAction = this.switchedPartOnPreviousKeyAction;\n        if (this.isPasteInProgress) {\n            if (this.options.allowCaretMode) {\n                // pasting should leave the input with caret\n                // thus allow direct input instead of selection mode\n                this.resetSegmentValue = false;\n            }\n            this.updateOnPaste(e);\n            this.isPasteInProgress = false;\n            return;\n        }\n        const keyDownEvent = this.keyDownEvent || {};\n        const isBackspaceKey = keyDownEvent.keyCode === KeyCode.BACKSPACE || keyDownEvent.key === Key.BACKSPACE;\n        const isDeleteKey = keyDownEvent.keyCode === KeyCode.DELETE || keyDownEvent.key === Key.DELETE;\n        const originalInteractionMode = this.interactionMode;\n        if (this.options.allowCaretMode &&\n            originalInteractionMode !== DateInputInteractionMode.Caret &&\n            !isDeleteKey && !isBackspaceKey) {\n            this.resetSegmentValue = true;\n        }\n        if (this.options.allowCaretMode) {\n            this.interactionMode = DateInputInteractionMode.Caret;\n        }\n        else {\n            this.interactionMode = DateInputInteractionMode.Selection;\n        }\n        const hasCaret = this.isInCaretMode();\n        if (hasCaret && this.keyDownEvent.key === Key.SPACE) {\n            // do not allow custom \"holes\" in the date segments\n            this.restorePreviousInputEventState();\n            return;\n        }\n        const oldExistingDateValue = this.dateObject && this.dateObject.getValue();\n        const oldDateValue = this.dateObject ? this.dateObject.value : null;\n        const { text: currentText, format: currentFormat } = this.dateObject.getTextAndFormat();\n        this.currentFormat = currentFormat;\n        let oldText = \"\";\n        if (hasCaret) {\n            if (isBackspaceKey || isDeleteKey) {\n                oldText = this.previousElementValue;\n            }\n            else if (originalInteractionMode === DateInputInteractionMode.Caret) {\n                oldText = this.previousElementValue;\n            }\n            else {\n                oldText = currentText;\n            }\n        }\n        else {\n            oldText = currentText;\n        }\n        const newText = this.elementValue;\n        let diff = approximateStringMatching({\n            oldText: oldText,\n            newText: newText,\n            formatPattern: this.currentFormat,\n            selectionStart: this.selection.start,\n            isInCaretMode: hasCaret,\n            keyEvent: this.keyDownEvent\n        });\n        if (diff && diff.length && diff[0] && diff[0][1] !== Constants.formatSeparator) {\n            this.switchedPartOnPreviousKeyAction = false;\n        }\n        if (hasCaret && (!diff || diff.length === 0)) {\n            this.restorePreviousInputEventState();\n            return;\n        }\n        else if (hasCaret && diff.length === 1) {\n            if (!diff[0] || !diff[0][0]) {\n                this.restorePreviousInputEventState();\n                return;\n            }\n            else if (hasCaret && diff[0] &&\n                (diff[0][0] === Constants.formatSeparator || diff[0][1] === Constants.formatSeparator)) {\n                this.restorePreviousInputEventState();\n                return;\n            }\n        }\n        const navigationOnly = (diff.length === 1 && diff[0][1] === Constants.formatSeparator);\n        const parsePartsResults = [];\n        let switchPart = false;\n        let error = null;\n        if (!navigationOnly) {\n            for (let i = 0; i < diff.length; i++) {\n                const parsePartResult = this.dateObject.parsePart({\n                    symbol: diff[i][0],\n                    currentChar: diff[i][1],\n                    resetSegmentValue: this.resetSegmentValue,\n                    cycleSegmentValue: !this.isInCaretMode(),\n                    rawTextValue: this.element.value,\n                    isDeleting: isBackspaceKey || isDeleteKey,\n                    originalFormat: this.currentFormat\n                });\n                parsePartsResults.push(parsePartResult);\n                if (!parsePartResult.value) {\n                    error = { type: \"parse\" };\n                }\n                switchPart = parsePartResult.switchToNext;\n            }\n        }\n        if (!this.options.autoSwitchParts) {\n            switchPart = false;\n        }\n        this.resetSegmentValue = false;\n        const hasFixedFormat = this.options.format === this.currentFormat ||\n            // all not fixed formats are 1 symbol, e.g. \"d\"\n            (isPresent(this.options.format) && this.options.format.length > 1);\n        const lastParseResult = parsePartsResults[parsePartsResults.length - 1];\n        const lastParseResultHasNoValue = lastParseResult && !isPresent(lastParseResult.value);\n        const parsingFailedOnDelete = (hasCaret && (isBackspaceKey || isDeleteKey) && lastParseResultHasNoValue);\n        const resetPart = lastParseResult ? lastParseResult.resetPart : false;\n        const newExistingDateValue = this.dateObject.getValue();\n        const hasExistingDateValueChanged = !isEqual(oldExistingDateValue, newExistingDateValue);\n        const newDateValue = this.dateObject.value;\n        let symbolForSelection;\n        const currentSelection = this.selection;\n        if (hasCaret) {\n            const diffChar = diff && diff.length > 0 ? diff[0][0] : null;\n            let hasLeadingZero = this.dateObject.getLeadingZero()[diffChar];\n            if (diff.length && diff[0][0] !== Constants.formatSeparator) {\n                if (switchPart) {\n                    this.forceUpdateWithSelection();\n                    this.switchDateSegment(1);\n                }\n                else if (resetPart) {\n                    symbolForSelection = this.currentFormat[currentSelection.start];\n                    if (symbolForSelection) {\n                        this.forceUpdate();\n                        this.setSelection(this.selectionBySymbol(symbolForSelection));\n                    }\n                    else {\n                        this.restorePreviousInputEventState();\n                    }\n                }\n                else if (parsingFailedOnDelete) {\n                    this.forceUpdate();\n                    if (diff.length && diff[0][0] !== Constants.formatSeparator) {\n                        this.setSelection(this.selectionBySymbol(diff[0][0]));\n                    }\n                }\n                else if (lastParseResultHasNoValue) {\n                    if (e.data === \"0\" && hasLeadingZero) {\n                        // do not reset element value on a leading zero\n                        // wait for consecutive input to determine the value\n                    }\n                    else if (isPresent(oldExistingDateValue) && !isPresent(newExistingDateValue)) {\n                        this.restorePreviousInputEventState();\n                    }\n                    else if (!isPresent(oldExistingDateValue) && isPresent(newExistingDateValue)) {\n                        this.forceUpdateWithSelection();\n                    }\n                    else if (isPresent(oldExistingDateValue) && isPresent(newExistingDateValue)) {\n                        if (hasExistingDateValueChanged) {\n                            this.forceUpdateWithSelection();\n                        }\n                        else {\n                            this.restorePreviousInputEventState();\n                        }\n                    }\n                    else if (!isPresent(oldExistingDateValue) && !isPresent(newExistingDateValue)) {\n                        this.forceUpdateWithSelection();\n                    }\n                    else if (oldDateValue !== newDateValue) {\n                        // this can happen on auto correct when no valid value is parsed\n                    }\n                    else {\n                        this.restorePreviousInputEventState();\n                    }\n                }\n                else if (!lastParseResultHasNoValue) {\n                    // the user types a valid but incomplete date (e.g. year \"123\" with format \"yyyy\")\n                    // let them continue typing, but refresh for not fixed formats\n                    if (!hasFixedFormat) {\n                        this.forceUpdateWithSelection();\n                    }\n                }\n            }\n            else {\n                if (!this.options.autoSwitchParts && diff[0][1] === Constants.formatSeparator) {\n                    // do not change the selection when a separator is pressed\n                    // this should happen only if autoSwitchKeys contains the separator explicitly\n                }\n                else {\n                    this.setSelection(this.selectionBySymbol(diff[0][0]));\n                }\n            }\n        }\n        else if (!hasCaret) {\n            this.forceUpdate();\n            if (diff.length && diff[0][0] !== Constants.formatSeparator) {\n                this.setSelection(this.selectionBySymbol(diff[0][0]));\n            }\n            if (this.options.autoSwitchParts) {\n                if (navigationOnly) {\n                    this.resetSegmentValue = true;\n                    if (!switchedPartOnPreviousKeyAction) {\n                        this.switchDateSegment(1);\n                    }\n                    this.switchedPartOnPreviousKeyAction = true;\n                }\n                else if (switchPart) {\n                    this.switchDateSegment(1);\n                    this.switchedPartOnPreviousKeyAction = true;\n                }\n            }\n            else {\n                if (lastParseResult && lastParseResult.switchToNext) {\n                    // the value is complete and should be switched, but the \"autoSwitchParts\" option prevents this\n                    // ensure that the segment value can be reset on next input\n                    this.resetSegmentValue = true;\n                }\n                else if (navigationOnly) {\n                    this.resetSegmentValue = true;\n                    if (!switchedPartOnPreviousKeyAction) {\n                        this.switchDateSegment(1);\n                    }\n                    this.switchedPartOnPreviousKeyAction = true;\n                }\n            }\n            if (isBackspaceKey && this.options.selectPreviousSegmentOnBackspace) {\n                // kendo angular have this UX\n                this.switchDateSegment(-1);\n            }\n        }\n        this.tryTriggerValueChange({\n            oldValue: oldExistingDateValue,\n            event: e\n        });\n        this.triggerInputEnd({ event: e, error: error });\n        if (hasCaret) {\n            // a format like \"F\" can dynamically change the resolved format pattern based on the value, e.g.\n            // \"Tuesday, February 1, 2022 3:04:05 AM\" becomes\n            // \"Wednesday, February 2, 2022 3:04:05 AM\" giving a diff of 2 (\"Tuesday\".length - \"Wednesday\".length)\n            this.setTextAndFormat();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onElementFocus(e) {\n        if (this.triggerFocus({ event: e })) {\n            return;\n        }\n        this.isActive = true;\n        this.interactionMode = DateInputInteractionMode.None;\n        this.switchedPartOnPreviousKeyAction = false;\n        this.refreshElementValue();\n        if (!this.mouseDownStarted) {\n            this.caret(0, this.elementValue.length);\n        }\n        this.mouseDownStarted = false;\n        this.triggerFocusEnd({ event: e });\n    }\n    /**\n     * @hidden\n     */\n    onElementBlur(e) {\n        this.resetSegmentValue = true;\n        this.isActive = false;\n        if (this.triggerBlur({ event: e })) {\n            return;\n        }\n        if (this.options.autoFill) {\n            this.autoFill();\n        }\n        this.interactionMode = DateInputInteractionMode.None;\n        this.switchedPartOnPreviousKeyAction = false;\n        this.refreshElementValue();\n        this.triggerBlurEnd({ event: e });\n    }\n    /**\n     * @hidden\n     */\n    onElementChange(e) {\n        this.triggerChange({ event: e });\n    }\n    /**\n     * @hidden\n     */\n    onElementKeyDown(e) {\n        if (this.triggerKeyDown({ event: e })) {\n            return;\n        }\n        const { start, end } = this.selection;\n        this.keyDownEvent = e;\n        this.previousElementValue = this.element.value;\n        this.previousElementSelection = { start, end };\n        if (this.keyEventMatchesAutoSwitchKeys(e)) {\n            const isTabKey = e.keyCode === KeyCode.TAB;\n            if (isTabKey) {\n                const { start: selectionStart, end: selectionEnd } = this.selection;\n                if (e.shiftKey && isTabKey) {\n                    this.switchDateSegment(-1);\n                }\n                else {\n                    this.switchDateSegment(1);\n                }\n                if (selectionStart !== this.selection.start || selectionEnd !== this.selection.end) {\n                    // when the selection changes, prevent the default Tab behavior\n                    e.preventDefault();\n                    return;\n                }\n            }\n            else {\n                // do not allow the \"input\" event to be triggered\n                e.preventDefault();\n                this.switchDateSegment(1);\n                return;\n            }\n        }\n        const symbol = this.currentFormat[this.selection.start];\n        const step = this.getStepFromSymbol(symbol);\n        let shouldPreventDefault = false;\n        if (e.altKey || e.ctrlKey || e.metaKey || e.keyCode === KeyCode.TAB) {\n            return;\n        }\n        switch (e.keyCode) {\n            case KeyCode.ARROW_LEFT:\n                this.switchDateSegment(-1);\n                shouldPreventDefault = true;\n                this.switchedPartOnPreviousKeyAction = false;\n                break;\n            case KeyCode.ARROW_UP:\n                this.modifyDateSegmentValue(step, symbol, event);\n                shouldPreventDefault = true;\n                this.switchedPartOnPreviousKeyAction = false;\n                break;\n            case KeyCode.ARROW_RIGHT:\n                this.switchDateSegment(1);\n                shouldPreventDefault = true;\n                this.switchedPartOnPreviousKeyAction = false;\n                break;\n            case KeyCode.ARROW_DOWN:\n                this.modifyDateSegmentValue(-step, symbol, event);\n                shouldPreventDefault = true;\n                this.switchedPartOnPreviousKeyAction = false;\n                break;\n            case KeyCode.ENTER:\n                // todo: handle \"change\" event\n                break;\n            case KeyCode.HOME:\n                this.selectNearestSegment(0);\n                shouldPreventDefault = true;\n                this.switchedPartOnPreviousKeyAction = false;\n                this.resetSegmentValue = true;\n                break;\n            case KeyCode.END:\n                this.selectNearestSegment(this.elementValue.length);\n                shouldPreventDefault = true;\n                this.switchedPartOnPreviousKeyAction = false;\n                this.resetSegmentValue = true;\n                break;\n            default:\n                // allow the \"input\" event to handle the change\n                return;\n        }\n        if (shouldPreventDefault) {\n            e.preventDefault();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onElementPaste() {\n        this.isPasteInProgress = true;\n    }\n    /**\n     * @hidden\n     */\n    onElementMouseWheel(e) {\n        if (!this.options.enableMouseWheel || this.triggerMouseWheel({ event: e })) {\n            return;\n        }\n        if (!this.isActive) {\n            return;\n        }\n        const event = e;\n        if (event.shiftKey) {\n            this.switchDateSegment((event.wheelDelta || -event.detail) > 0 ? -1 : 1);\n        }\n        else {\n            this.modifyDateSegmentValue((event.wheelDelta || -event.detail) > 0 ? 1 : -1);\n        }\n        event.returnValue = false;\n        if (event.preventDefault) {\n            event.preventDefault();\n        }\n        if (event.stopPropagation) {\n            event.stopPropagation();\n        }\n    }\n    updateOnPaste(e) {\n        let value = this.intl.parseDate(this.elementValue, this.inputFormat) || this.value;\n        if (isPresent(value) && this.dateObject.shouldNormalizeCentury()) {\n            value = this.dateObject.normalizeCentury(value);\n        }\n        const oldDateObjectValue = this.dateObject && this.dateObject.getValue();\n        this.writeValue(value);\n        this.tryTriggerValueChange({\n            oldValue: oldDateObjectValue,\n            event: e\n        });\n    }\n    get elementValue() {\n        return (this.element || {}).value || '';\n    }\n    get inputFormat() {\n        if (!this.options.format) {\n            return Constants.defaultDateFormat;\n        }\n        if (typeof this.options.format === 'string') {\n            return this.options.format;\n        }\n        else {\n            return this.options.format.inputFormat;\n        }\n    }\n    get displayFormat() {\n        if (!this.options.format) {\n            return Constants.defaultDateFormat;\n        }\n        if (typeof this.options.format === 'string') {\n            return this.options.format;\n        }\n        else {\n            return this.options.format.displayFormat;\n        }\n    }\n    get selection() {\n        let returnValue = { start: 0, end: 0 };\n        if (this.element !== null && this.element.selectionStart !== undefined) {\n            returnValue = {\n                start: this.element.selectionStart,\n                end: this.element.selectionEnd\n            };\n        }\n        return returnValue;\n    }\n    setSelection(selection) {\n        if (this.element && document.activeElement === this.element) {\n            this.element.setSelectionRange(selection.start, selection.end);\n            if (selection.start !== selection.end) {\n                this.interactionMode = DateInputInteractionMode.Selection;\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    selectionBySymbol(symbol) {\n        let start = -1;\n        let end = 0;\n        for (let i = 0; i < this.currentFormat.length; i++) {\n            if (this.currentFormat[i] === symbol) {\n                end = i + 1;\n                if (start === -1) {\n                    start = i;\n                }\n            }\n        }\n        if (start < 0) {\n            start = 0;\n        }\n        if (!this.options.autoCorrectParts && this.currentFormat.length !== this.currentText.length) {\n            if (this.currentFormat.length < this.currentText.length) {\n                end += this.currentText.length - this.currentFormat.length;\n            }\n            else {\n                end = Math.max(0, end - (this.currentFormat.length - this.currentText.length));\n            }\n        }\n        return { start, end };\n    }\n    /**\n     * @hidden\n     */\n    selectionByIndex(index) {\n        let selection = { start: index, end: index };\n        for (let i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {\n            if (i < this.currentFormat.length && this.currentFormat[i] !== Constants.formatSeparator) {\n                selection = this.selectionBySymbol(this.currentFormat[i]);\n                break;\n            }\n            if (j >= 0 && this.currentFormat[j] !== Constants.formatSeparator) {\n                selection = this.selectionBySymbol(this.currentFormat[j]);\n                break;\n            }\n        }\n        return selection;\n    }\n    switchDateSegment(offset) {\n        const selection = this.selection;\n        if (this.isInCaretMode()) {\n            let start = selection.start;\n            const currentSymbol = this.currentFormat[start - 1];\n            let symbol = \"\";\n            let symbolCandidate = \"\";\n            if (offset < 0) {\n                for (let i = start + offset; i >= 0; i--) {\n                    symbolCandidate = this.currentFormat[i];\n                    if (symbolCandidate !== Constants.formatSeparator &&\n                        symbolCandidate !== currentSymbol) {\n                        start = i;\n                        symbol = symbolCandidate;\n                        break;\n                    }\n                }\n            }\n            else {\n                for (let i = start + offset; i < this.currentFormat.length; i++) {\n                    symbolCandidate = this.currentFormat[i];\n                    if (symbolCandidate !== Constants.formatSeparator &&\n                        symbolCandidate !== currentSymbol) {\n                        start = i;\n                        symbol = symbolCandidate;\n                        break;\n                    }\n                }\n            }\n            if (symbol) {\n                this.forceUpdate();\n                this.setSelection(this.selectionBySymbol(symbol));\n                this.interactionMode = DateInputInteractionMode.Selection;\n                return;\n            }\n        }\n        this.interactionMode = DateInputInteractionMode.None;\n        let { start: selectionStart, end: selectionEnd } = this.selection;\n        if (selectionStart < selectionEnd &&\n            this.currentFormat[selectionStart] !== this.currentFormat[selectionEnd - 1]) {\n            this.setSelection(this.selectionByIndex(offset > 0 ? selectionStart : selectionEnd - 1));\n            this.resetSegmentValue = true;\n            this.interactionMode = DateInputInteractionMode.None;\n            return;\n        }\n        const previousFormatSymbol = this.currentFormat[selectionStart];\n        let a = selectionStart + offset;\n        while (a > 0 && a < this.currentFormat.length) {\n            if (this.currentFormat[a] !== previousFormatSymbol &&\n                this.currentFormat[a] !== Constants.formatSeparator) {\n                break;\n            }\n            a += offset;\n        }\n        if (this.currentFormat[a] === Constants.formatSeparator) {\n            // no known symbol is found\n            return;\n        }\n        let b = a;\n        while (b >= 0 && b < this.currentFormat.length) {\n            if (this.currentFormat[b] !== this.currentFormat[a]) {\n                break;\n            }\n            b += offset;\n        }\n        if (a > b && (b + 1 !== selectionStart || a + 1 !== selectionEnd)) {\n            this.setSelection({ start: b + 1, end: a + 1 });\n            this.resetSegmentValue = true;\n        }\n        else if (a < b && (a !== selectionStart || b !== selectionEnd)) {\n            this.setSelection({ start: a, end: b });\n            this.resetSegmentValue = true;\n        }\n        this.interactionMode = DateInputInteractionMode.None;\n    }\n    modifyDateSegmentValue(offset, symbol = \"\", event = {}) {\n        if (!this.dateObject || this.options.readonly) {\n            return;\n        }\n        const oldValue = this.value;\n        let step = DEFAULT_SEGMENT_STEP;\n        const caret = this.caret();\n        symbol = symbol || this.currentFormat[caret[0]];\n        if (symbol === \"S\" && (!this.options.steps.millisecond || this.options.steps.millisecond === DEFAULT_SEGMENT_STEP)) {\n            const msDigits = millisecondDigitsInFormat(this.inputFormat);\n            step = millisecondStepFor(msDigits);\n        }\n        this.dateObject.modifyPart(symbol, step * offset);\n        this.tryTriggerValueChange({\n            oldValue: oldValue,\n            event: event\n        });\n        this.forceUpdate();\n        this.setSelection(this.selectionBySymbol(symbol));\n    }\n    /**\n     * @hidden\n     */\n    tryTriggerValueChange(args = { oldValue: null, event: {} }) {\n        if (!isEqual(this.value, args.oldValue)) {\n            return this.triggerValueChange(args);\n        }\n    }\n    /**\n     * @hidden\n     */\n    triggerValueChange(args = { oldValue: null, event: {} }) {\n        return this.trigger(VALUE_CHANGE, extend(args, {\n            value: this.value\n        }));\n    }\n    /**\n     * @hidden\n     */\n    triggerInput(args = { event: {} }) {\n        return this.trigger(INPUT, extend(args, {\n            value: this.value\n        }));\n    }\n    /**\n     * @hidden\n     */\n    triggerInputEnd(args = { event: {}, error: null }) {\n        return this.trigger(INPUT_END, extend(args, {\n            value: this.value\n        }));\n    }\n    /**\n     * @hidden\n     */\n    triggerFocus(args = { event: {} }) {\n        return this.trigger(FOCUS, extend({}, args));\n    }\n    /**\n     * @hidden\n     */\n    triggerFocusEnd(args = { event: {} }) {\n        return this.trigger(FOCUS_END, extend({}, args));\n    }\n    /**\n     * @hidden\n     */\n    triggerBlur(args = { event: {} }) {\n        return this.trigger(BLUR, extend({}, args));\n    }\n    /**\n     * @hidden\n     */\n    triggerBlurEnd(args = { event: {} }) {\n        return this.trigger(BLUR_END, extend({}, args));\n    }\n    /**\n     * @hidden\n     */\n    triggerChange(args = { event: {} }) {\n        return this.trigger(CHANGE, extend(args, {\n            value: this.value\n        }));\n    }\n    /**\n     * @hidden\n     */\n    triggerKeyDown(args = { event: {} }) {\n        return this.trigger(KEY_DOWN, extend({}, args));\n    }\n    /**\n     * @hidden\n     */\n    triggerMouseWheel(args = { event: {} }) {\n        return this.trigger(MOUSE_WHEEL, extend({}, args));\n    }\n    /**\n     * @hidden\n     */\n    forceUpdate() {\n        this.setTextAndFormat();\n        this.refreshElementValue();\n    }\n    /**\n     * @hidden\n     */\n    forceUpdateWithSelection() {\n        const { start, end } = this.selection;\n        const elementValueLength = this.elementValue.length;\n        this.forceUpdate();\n        const selectionOffset = this.elementValue.length - elementValueLength;\n        this.setSelection({\n            start: start + selectionOffset,\n            end: end + selectionOffset\n        });\n    }\n    /**\n     * @hidden\n     */\n    setTextAndFormat() {\n        const { text: currentText, format: currentFormat } = this.dateObject.getTextAndFormat();\n        this.currentFormat = currentFormat;\n        this.currentText = currentText;\n    }\n    /**\n     * @hidden\n     */\n    setElementValue(value) {\n        this.element.value = value;\n    }\n    /**\n     * @hidden\n     */\n    getStepFromSymbol(symbol) {\n        /* eslint-disable no-fallthrough */\n        switch (symbol) {\n            case \"S\":\n                return Number(this.options.steps.millisecond);\n            case \"s\":\n                return Number(this.options.steps.second);\n            case \"m\":\n                return Number(this.options.steps.minute);\n            // represents hour as value from 01 through 12\n            case \"h\":\n            // represents hour as value from 01 through 23\n            case \"H\":\n                return Number(this.options.steps.hour);\n            case \"M\":\n                return Number(this.options.steps.month);\n            // there is no 'D' format specifier for day\n            case \"d\":\n            // used for formats such as \"EEEE, MMMM d, yyyy\",\n            // where \"EEEE\" stands for full name of the day e.g. Monday\n            case \"E\":\n                return Number(this.options.steps.day);\n            // there is no 'Y' format specifier for year\n            case \"y\":\n                return Number(this.options.steps.year);\n            default:\n                return DEFAULT_SEGMENT_STEP;\n        }\n        /* eslint-enable no-fallthrough */\n    }\n    /**\n     * @hidden\n     */\n    restorePreviousInputEventState() {\n        this.restorePreviousElementValue();\n        this.restorePreviousElementSelection();\n    }\n    /**\n     * @hidden\n     */\n    restorePreviousElementValue() {\n        this.setElementValue(this.previousElementValue || '');\n    }\n    /**\n     * @hidden\n     */\n    restorePreviousElementSelection() {\n        const { start, end } = this.previousElementSelection;\n        this.setSelection({ start: start || 0, end: end || 0 });\n    }\n    writeValue(value) {\n        this.verifyValue(value);\n        this.dateObject = this.getDateObject(value);\n        this.refreshElementValue();\n    }\n    verifyValue(value) {\n        if (value && !isValidDate(value)) {\n            throw new Error(\"The 'value' should be a valid JavaScript Date instance.\");\n        }\n    }\n    refreshElementValue() {\n        const start = this.caret()[0];\n        const element = this.element;\n        const format = this.isActive ? this.inputFormat : this.displayFormat;\n        const { text: currentText, format: currentFormat } = this.dateObject.getTextAndFormat(format);\n        this.currentFormat = currentFormat;\n        this.currentText = currentText;\n        const hasPlaceholder = this.options.hasPlaceholder || isPresent(this.options.placeholder);\n        const showPlaceholder = !this.isActive &&\n            hasPlaceholder &&\n            !this.dateObject.hasValue();\n        if (hasPlaceholder && isPresent(this.options.placeholder)) {\n            element.placeholder = this.options.placeholder;\n        }\n        const newElementValue = showPlaceholder ? \"\" : currentText;\n        this.previousElementValue = this.elementValue;\n        this.setElementValue(newElementValue);\n        if (this.isActive && !this.options.allowCaretMode && this.options.selectNearestSegmentOnFocus) {\n            this.selectNearestSegment(start);\n        }\n    }\n    /**\n     * @hidden\n     */\n    caret(start, end = start) {\n        const isPosition = start !== undefined;\n        let returnValue = [start, start];\n        const element = this.element;\n        if (isPosition && (this.options.disabled || this.options.readonly)) {\n            return undefined;\n        }\n        try {\n            if (element.selectionStart !== undefined) {\n                if (isPosition) {\n                    if (isDocumentAvailable() && document.activeElement !== element) {\n                        element.focus();\n                    }\n                    element.setSelectionRange(start, end);\n                }\n                returnValue = [element.selectionStart, element.selectionEnd];\n            }\n        }\n        catch (e) {\n            returnValue = [];\n        }\n        return returnValue;\n    }\n    selectNearestSegment(index) {\n        // Finds the nearest (in both directions) known part.\n        for (let i = index, j = index - 1; i < this.currentFormat.length || j >= 0; i++, j--) {\n            if (i < this.currentFormat.length && this.currentFormat[i] !== \"_\") {\n                this.selectDateSegment(this.currentFormat[i]);\n                return;\n            }\n            if (j >= 0 && this.currentFormat[j] !== \"_\") {\n                this.selectDateSegment(this.currentFormat[j]);\n                return;\n            }\n        }\n    }\n    selectDateSegment(symbol) {\n        let begin = -1;\n        let end = 0;\n        for (let i = 0; i < this.currentFormat.length; i++) {\n            if (this.currentFormat[i] === symbol) {\n                end = i + 1;\n                if (begin === -1) {\n                    begin = i;\n                }\n            }\n        }\n        if (begin < 0) {\n            begin = 0;\n        }\n        this.caret(0, 0);\n        this.caret(begin, end);\n    }\n    /**\n     * @hidden\n     */\n    getDateObject(value) {\n        const { leadingZero } = (this.dateObject || {}) || null;\n        this.options.value = value;\n        const dateObject = this.createDateObject();\n        dateObject.setLeadingZero(this.isActive ? leadingZero : null);\n        return dateObject;\n    }\n    /* tslint:disable:align */\n    /**\n     * @hidden\n     */\n    createDateObject() {\n        const defaultOptions = this.getDateObjectOptions();\n        const dateObject = new DateObject(extend({}, defaultOptions));\n        return dateObject;\n    }\n    /**\n     * @hidden\n     */\n    getDateObjectOptions() {\n        const newOptions = {\n            intlService: this.options.intlService,\n            formatPlaceholder: this.options.formatPlaceholder ? this.options.formatPlaceholder : 'formatPattern',\n            format: this.inputFormat,\n            cycleTime: this.options.cycleTime,\n            twoDigitYearMax: this.options.twoDigitYearMax,\n            autoCorrectParts: this.options.autoCorrectParts,\n            value: this.options.value\n        };\n        return newOptions;\n    }\n    /* tslint:enable:align */\n    /**\n     * @hidden\n     */\n    keyEventMatchesAutoSwitchKeys(keyObject) {\n        const autoSwitchKeys = (this.options.autoSwitchKeys || [])\n            .map(x => x.toString().toLowerCase().trim());\n        if (autoSwitchKeys.indexOf(keyObject.keyCode.toString()) >= 0 ||\n            autoSwitchKeys.indexOf(keyObject.keyCode) >= 0 ||\n            autoSwitchKeys.indexOf(keyObject.key.toLowerCase().trim()) >= 0) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * @hidden\n     */\n    autoFill() {\n        let dateObject = this.dateObject, currentDate = new Date(), day, month, year, hours, minutes, seconds;\n        if (dateObject.date || dateObject.month || dateObject.year || dateObject.hours || dateObject.minutes || dateObject.seconds) {\n            year = dateObject.year ? dateObject.value.getFullYear() : currentDate.getFullYear(),\n                month = dateObject.month ? dateObject.value.getMonth() : currentDate.getMonth(),\n                day = dateObject.date ? dateObject.value.getDate() : currentDate.getDate(),\n                hours = dateObject.hours ? dateObject.value.getHours() : currentDate.getHours(),\n                minutes = dateObject.minutes ? dateObject.value.getMinutes() : currentDate.getMinutes(),\n                seconds = dateObject.seconds ? dateObject.value.getSeconds() : currentDate.getSeconds();\n            dateObject.setValue(new Date(year, month, day, hours, minutes, seconds));\n            this.refreshElementValue();\n            this.triggerChange();\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}