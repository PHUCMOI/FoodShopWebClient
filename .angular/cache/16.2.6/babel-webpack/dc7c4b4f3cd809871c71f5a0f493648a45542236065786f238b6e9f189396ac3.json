{"ast":null,"code":"import { isCompositeFilterDescriptor } from \"./filter-descriptor.interface\";\nimport { getter } from \"../accessor\";\nimport { isFunction, isPresent, isDate, isString, isBlank, isNumeric } from \"../utils\";\nconst logic = {\n  \"or\": {\n    concat: (acc, fn) => a => acc(a) || fn(a),\n    identity: () => false\n  },\n  \"and\": {\n    concat: (acc, fn) => a => acc(a) && fn(a),\n    identity: () => true\n  }\n};\nconst operatorsMap = {\n  contains: (a, b) => (a || \"\").indexOf(b) >= 0,\n  doesnotcontain: (a, b) => (a || \"\").indexOf(b) === -1,\n  doesnotendwith: (a, b) => (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) < 0,\n  doesnotstartwith: (a, b) => (a || \"\").lastIndexOf(b, 0) === -1,\n  endswith: (a, b) => (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) >= 0,\n  eq: (a, b) => a === b,\n  gt: (a, b) => a > b,\n  gte: (a, b) => a >= b,\n  isempty: a => a === '',\n  isnotempty: a => a !== '',\n  isnotnull: a => isPresent(a),\n  isnull: a => isBlank(a),\n  lt: (a, b) => a < b,\n  lte: (a, b) => a <= b,\n  neq: (a, b) => a != b,\n  startswith: (a, b) => (a || \"\").lastIndexOf(b, 0) === 0\n};\nconst dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\nconst convertValue = (value, ignoreCase) => {\n  if (value != null && isString(value)) {\n    const date = dateRegExp.exec(value);\n    if (date) {\n      return new Date(+date[1]).getTime();\n    } else if (ignoreCase) {\n      return value.toLowerCase();\n    }\n  } else if (value != null && isDate(value)) {\n    return value.getTime();\n  }\n  return value;\n};\nconst typedGetter = (prop, value, ignoreCase) => {\n  if (!isPresent(value)) {\n    return prop;\n  }\n  let acc = prop;\n  if (isString(value)) {\n    const date = dateRegExp.exec(value);\n    if (date) {\n      value = new Date(+date[1]);\n    } else {\n      acc = a => {\n        const x = prop(a);\n        if (typeof x === 'string' && ignoreCase) {\n          return x.toLowerCase();\n        } else {\n          return isNumeric(x) ? x + \"\" : x;\n        }\n      };\n    }\n  }\n  if (isDate(value)) {\n    return a => {\n      const x = acc(a);\n      return isDate(x) ? x.getTime() : x;\n    };\n  }\n  return acc;\n};\nconst transformFilter = ({\n  field,\n  ignoreCase,\n  value,\n  operator\n}) => {\n  field = !isPresent(field) ? a => a : field;\n  ignoreCase = isPresent(ignoreCase) ? ignoreCase : true;\n  const itemProp = typedGetter(isFunction(field) ? field : getter(field, true), value, ignoreCase);\n  value = convertValue(value, ignoreCase);\n  const op = isFunction(operator) ? operator : operatorsMap[operator];\n  return a => op(itemProp(a), value, ignoreCase);\n};\n/**\n * @hidden\n */\nexport const transformCompositeFilter = filter => {\n  const combiner = logic[filter.logic];\n  return filter.filters.filter(isPresent).map(x => isCompositeFilterDescriptor(x) ? transformCompositeFilter(x) : transformFilter(x)).reduce(combiner.concat, combiner.identity);\n};","map":{"version":3,"names":["isCompositeFilterDescriptor","getter","isFunction","isPresent","isDate","isString","isBlank","isNumeric","logic","concat","acc","fn","a","identity","operatorsMap","contains","b","indexOf","doesnotcontain","doesnotendwith","length","doesnotstartwith","lastIndexOf","endswith","eq","gt","gte","isempty","isnotempty","isnotnull","isnull","lt","lte","neq","startswith","dateRegExp","convertValue","value","ignoreCase","date","exec","Date","getTime","toLowerCase","typedGetter","prop","x","transformFilter","field","operator","itemProp","op","transformCompositeFilter","filter","combiner","filters","map","reduce"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-data-query/dist/es2015/filtering/filter-no-eval.js"],"sourcesContent":["import { isCompositeFilterDescriptor } from \"./filter-descriptor.interface\";\nimport { getter } from \"../accessor\";\nimport { isFunction, isPresent, isDate, isString, isBlank, isNumeric } from \"../utils\";\nconst logic = {\n    \"or\": {\n        concat: (acc, fn) => a => acc(a) || fn(a),\n        identity: () => false\n    },\n    \"and\": {\n        concat: (acc, fn) => a => acc(a) && fn(a),\n        identity: () => true\n    }\n};\nconst operatorsMap = {\n    contains: (a, b) => (a || \"\").indexOf(b) >= 0,\n    doesnotcontain: (a, b) => (a || \"\").indexOf(b) === -1,\n    doesnotendwith: (a, b) => (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) < 0,\n    doesnotstartwith: (a, b) => (a || \"\").lastIndexOf(b, 0) === -1,\n    endswith: (a, b) => (a || \"\").indexOf(b, (a || \"\").length - (b || \"\").length) >= 0,\n    eq: (a, b) => a === b,\n    gt: (a, b) => a > b,\n    gte: (a, b) => a >= b,\n    isempty: (a) => a === '',\n    isnotempty: (a) => a !== '',\n    isnotnull: (a) => isPresent(a),\n    isnull: (a) => isBlank(a),\n    lt: (a, b) => a < b,\n    lte: (a, b) => a <= b,\n    neq: (a, b) => a != b,\n    startswith: (a, b) => (a || \"\").lastIndexOf(b, 0) === 0\n};\nconst dateRegExp = /^\\/Date\\((.*?)\\)\\/$/;\nconst convertValue = (value, ignoreCase) => {\n    if (value != null && isString(value)) {\n        const date = dateRegExp.exec(value);\n        if (date) {\n            return new Date(+date[1]).getTime();\n        }\n        else if (ignoreCase) {\n            return value.toLowerCase();\n        }\n    }\n    else if (value != null && isDate(value)) {\n        return value.getTime();\n    }\n    return value;\n};\nconst typedGetter = (prop, value, ignoreCase) => {\n    if (!isPresent(value)) {\n        return prop;\n    }\n    let acc = prop;\n    if (isString(value)) {\n        const date = dateRegExp.exec(value);\n        if (date) {\n            value = new Date(+date[1]);\n        }\n        else {\n            acc = a => {\n                const x = prop(a);\n                if (typeof x === 'string' && ignoreCase) {\n                    return x.toLowerCase();\n                }\n                else {\n                    return isNumeric(x) ? x + \"\" : x;\n                }\n            };\n        }\n    }\n    if (isDate(value)) {\n        return a => {\n            const x = acc(a);\n            return isDate(x) ? x.getTime() : x;\n        };\n    }\n    return acc;\n};\nconst transformFilter = ({ field, ignoreCase, value, operator }) => {\n    field = !isPresent(field) ? a => a : field;\n    ignoreCase = isPresent(ignoreCase) ? ignoreCase : true;\n    const itemProp = typedGetter(isFunction(field) ? field : getter(field, true), value, ignoreCase);\n    value = convertValue(value, ignoreCase);\n    const op = isFunction(operator) ? operator : operatorsMap[operator];\n    return a => op(itemProp(a), value, ignoreCase);\n};\n/**\n * @hidden\n */\nexport const transformCompositeFilter = (filter) => {\n    const combiner = logic[filter.logic];\n    return filter.filters\n        .filter(isPresent)\n        .map(x => isCompositeFilterDescriptor(x) ? transformCompositeFilter(x) : transformFilter(x))\n        .reduce(combiner.concat, combiner.identity);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}