{"ast":null,"code":"import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { deepExtend, defined } from '../../common';\nimport { X, Y } from '../../common/constants';\nimport LinearPointer from './linear-pointer';\nimport BarLinearPointerAnimation from './bar-linear-pointer-animation';\nconst {\n  Group,\n  Path\n} = drawing;\nclass BarLinearPointer extends LinearPointer {\n  constructor(scale, options) {\n    super(scale, options);\n    if (!defined(this.options.size)) {\n      this.options.size = this.scale.options.majorTicks.size * 0.3;\n    }\n  }\n  pointerShape(value) {\n    const {\n      scale,\n      options\n    } = this;\n    const {\n      mirror,\n      vertical\n    } = scale.options;\n    const dir = mirror === vertical ? -1 : 1;\n    const size = options.size * dir;\n    const minSlot = scale.getSlot(scale.options.min);\n    const slot = scale.getSlot(value);\n    const axis = vertical ? Y : X;\n    const sizeAxis = vertical ? X : Y;\n    const margin = this._margin() * dir;\n    const p1 = new geo.Point();\n    p1[axis] = minSlot[axis + \"1\"];\n    p1[sizeAxis] = minSlot[sizeAxis + \"1\"];\n    const p2 = new geo.Point();\n    p2[axis] = slot[axis + \"1\"];\n    p2[sizeAxis] = slot[sizeAxis + \"1\"];\n    if (vertical) {\n      p1.translate(margin, 0);\n      p2.translate(margin, 0);\n    } else {\n      p1.translate(0, margin);\n      p2.translate(0, margin);\n    }\n    const p3 = p2.clone();\n    const p4 = p1.clone();\n    if (vertical) {\n      p3.translate(size, 0);\n      p4.translate(size, 0);\n    } else {\n      p3.translate(0, size);\n      p4.translate(0, size);\n    }\n    return [p1, p2, p3, p4];\n  }\n  repaint() {\n    const {\n      scale,\n      options\n    } = this;\n    const shape = this.pointerShape(options.value);\n    const pointerPath = this.pointerPath;\n    const oldShape = this.pointerShape(options._oldValue);\n    pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();\n    const animation = new BarLinearPointerAnimation(pointerPath, deepExtend(options.animation, {\n      reverse: scale.options.reverse,\n      vertical: scale.options.vertical,\n      oldPoints: [oldShape[1], oldShape[2]],\n      newPoints: [shape[1], shape[2]]\n    }));\n    if (options.animation.transitions === false) {\n      animation.options.duration = 0;\n    }\n    animation.setup();\n    animation.play();\n  }\n  render() {\n    const group = new Group();\n    const elementOptions = this.getElementOptions();\n    if (this.options.track.visible) {\n      group.append(this.renderTrack());\n    }\n    const pointer = this.pointerPath = new Path({\n      stroke: elementOptions.stroke,\n      fill: elementOptions.fill\n    });\n    group.append(pointer);\n    this.elements = group;\n    return group;\n  }\n  renderTrack() {\n    const trackOptions = this.options.track;\n    const border = trackOptions.border || {};\n    const trackBox = this.trackBox.clone().pad(border.width || 0);\n    return new Path.fromRect(trackBox.toRect(), {\n      fill: {\n        color: trackOptions.color,\n        opacity: trackOptions.opacity\n      },\n      stroke: {\n        color: border.width ? border.color || trackOptions.color : \"\",\n        width: border.width,\n        dashType: border.dashType\n      }\n    });\n  }\n}\nexport default BarLinearPointer;","map":{"version":3,"names":["geometry","geo","drawing","deepExtend","defined","X","Y","LinearPointer","BarLinearPointerAnimation","Group","Path","BarLinearPointer","constructor","scale","options","size","majorTicks","pointerShape","value","mirror","vertical","dir","minSlot","getSlot","min","slot","axis","sizeAxis","margin","_margin","p1","Point","p2","translate","p3","clone","p4","repaint","shape","pointerPath","oldShape","_oldValue","moveTo","lineTo","close","animation","reverse","oldPoints","newPoints","transitions","duration","setup","play","render","group","elementOptions","getElementOptions","track","visible","append","renderTrack","pointer","stroke","fill","elements","trackOptions","border","trackBox","pad","width","fromRect","toRect","color","opacity","dashType"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/gauges/linear/bar-linear-pointer.js"],"sourcesContent":["import { geometry as geo, drawing } from '@progress/kendo-drawing';\nimport { deepExtend, defined } from '../../common';\nimport { X, Y } from '../../common/constants';\nimport LinearPointer from './linear-pointer';\nimport BarLinearPointerAnimation from './bar-linear-pointer-animation';\n\nconst { Group, Path } = drawing;\n\nclass BarLinearPointer extends LinearPointer {\n    constructor(scale, options) {\n        super(scale, options);\n\n        if (!defined(this.options.size)) {\n            this.options.size = this.scale.options.majorTicks.size * 0.3;\n        }\n    }\n\n    pointerShape(value) {\n        const { scale, options } = this;\n        const { mirror, vertical } = scale.options;\n        const dir = mirror === vertical ? -1 : 1;\n        const size = options.size * dir;\n        const minSlot = scale.getSlot(scale.options.min);\n        const slot = scale.getSlot(value);\n        const axis = vertical ? Y : X;\n        const sizeAxis = vertical ? X : Y;\n        const margin = this._margin() * dir;\n\n        const p1 = new geo.Point();\n        p1[axis] = minSlot[axis + \"1\"];\n        p1[sizeAxis] = minSlot[sizeAxis + \"1\"];\n\n        const p2 = new geo.Point();\n        p2[axis] = slot[axis + \"1\"];\n        p2[sizeAxis] = slot[sizeAxis + \"1\"];\n\n        if (vertical) {\n            p1.translate(margin, 0);\n            p2.translate(margin, 0);\n        } else {\n            p1.translate(0, margin);\n            p2.translate(0, margin);\n        }\n\n        const p3 = p2.clone();\n        const p4 = p1.clone();\n\n        if (vertical) {\n            p3.translate(size, 0);\n            p4.translate(size, 0);\n        } else {\n            p3.translate(0, size);\n            p4.translate(0, size);\n        }\n\n        return [ p1, p2, p3, p4 ];\n    }\n\n    repaint() {\n        const { scale, options } = this;\n        const shape = this.pointerShape(options.value);\n        const pointerPath = this.pointerPath;\n        const oldShape = this.pointerShape(options._oldValue);\n\n        pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();\n\n        const animation = new BarLinearPointerAnimation(pointerPath, deepExtend(options.animation, {\n            reverse: scale.options.reverse,\n            vertical: scale.options.vertical,\n            oldPoints: [ oldShape[1], oldShape[2] ],\n            newPoints: [ shape[1], shape[2] ]\n        }));\n\n        if (options.animation.transitions === false) {\n            animation.options.duration = 0;\n        }\n\n        animation.setup();\n        animation.play();\n    }\n\n    render() {\n        const group = new Group();\n        const elementOptions = this.getElementOptions();\n\n        if (this.options.track.visible) {\n            group.append(this.renderTrack());\n        }\n\n        const pointer = this.pointerPath = new Path({\n            stroke: elementOptions.stroke,\n            fill: elementOptions.fill\n        });\n\n        group.append(pointer);\n\n        this.elements = group;\n\n        return group;\n    }\n\n    renderTrack() {\n        const trackOptions = this.options.track;\n        const border = trackOptions.border || {};\n        const trackBox = this.trackBox.clone().pad(border.width || 0);\n\n        return new Path.fromRect(trackBox.toRect(), {\n            fill: {\n                color: trackOptions.color,\n                opacity: trackOptions.opacity\n            },\n            stroke: {\n                color: border.width ? border.color || trackOptions.color : \"\",\n                width: border.width,\n                dashType: border.dashType\n            }\n        });\n    }\n}\n\nexport default BarLinearPointer;"],"mappings":"AAAA,SAASA,QAAQ,IAAIC,GAAG,EAAEC,OAAO,QAAQ,yBAAyB;AAClE,SAASC,UAAU,EAAEC,OAAO,QAAQ,cAAc;AAClD,SAASC,CAAC,EAAEC,CAAC,QAAQ,wBAAwB;AAC7C,OAAOC,aAAa,MAAM,kBAAkB;AAC5C,OAAOC,yBAAyB,MAAM,gCAAgC;AAEtE,MAAM;EAAEC,KAAK;EAAEC;AAAK,CAAC,GAAGR,OAAO;AAE/B,MAAMS,gBAAgB,SAASJ,aAAa,CAAC;EACzCK,WAAWA,CAACC,KAAK,EAAEC,OAAO,EAAE;IACxB,KAAK,CAACD,KAAK,EAAEC,OAAO,CAAC;IAErB,IAAI,CAACV,OAAO,CAAC,IAAI,CAACU,OAAO,CAACC,IAAI,CAAC,EAAE;MAC7B,IAAI,CAACD,OAAO,CAACC,IAAI,GAAG,IAAI,CAACF,KAAK,CAACC,OAAO,CAACE,UAAU,CAACD,IAAI,GAAG,GAAG;IAChE;EACJ;EAEAE,YAAYA,CAACC,KAAK,EAAE;IAChB,MAAM;MAAEL,KAAK;MAAEC;IAAQ,CAAC,GAAG,IAAI;IAC/B,MAAM;MAAEK,MAAM;MAAEC;IAAS,CAAC,GAAGP,KAAK,CAACC,OAAO;IAC1C,MAAMO,GAAG,GAAGF,MAAM,KAAKC,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC;IACxC,MAAML,IAAI,GAAGD,OAAO,CAACC,IAAI,GAAGM,GAAG;IAC/B,MAAMC,OAAO,GAAGT,KAAK,CAACU,OAAO,CAACV,KAAK,CAACC,OAAO,CAACU,GAAG,CAAC;IAChD,MAAMC,IAAI,GAAGZ,KAAK,CAACU,OAAO,CAACL,KAAK,CAAC;IACjC,MAAMQ,IAAI,GAAGN,QAAQ,GAAGd,CAAC,GAAGD,CAAC;IAC7B,MAAMsB,QAAQ,GAAGP,QAAQ,GAAGf,CAAC,GAAGC,CAAC;IACjC,MAAMsB,MAAM,GAAG,IAAI,CAACC,OAAO,CAAC,CAAC,GAAGR,GAAG;IAEnC,MAAMS,EAAE,GAAG,IAAI7B,GAAG,CAAC8B,KAAK,CAAC,CAAC;IAC1BD,EAAE,CAACJ,IAAI,CAAC,GAAGJ,OAAO,CAACI,IAAI,GAAG,GAAG,CAAC;IAC9BI,EAAE,CAACH,QAAQ,CAAC,GAAGL,OAAO,CAACK,QAAQ,GAAG,GAAG,CAAC;IAEtC,MAAMK,EAAE,GAAG,IAAI/B,GAAG,CAAC8B,KAAK,CAAC,CAAC;IAC1BC,EAAE,CAACN,IAAI,CAAC,GAAGD,IAAI,CAACC,IAAI,GAAG,GAAG,CAAC;IAC3BM,EAAE,CAACL,QAAQ,CAAC,GAAGF,IAAI,CAACE,QAAQ,GAAG,GAAG,CAAC;IAEnC,IAAIP,QAAQ,EAAE;MACVU,EAAE,CAACG,SAAS,CAACL,MAAM,EAAE,CAAC,CAAC;MACvBI,EAAE,CAACC,SAAS,CAACL,MAAM,EAAE,CAAC,CAAC;IAC3B,CAAC,MAAM;MACHE,EAAE,CAACG,SAAS,CAAC,CAAC,EAAEL,MAAM,CAAC;MACvBI,EAAE,CAACC,SAAS,CAAC,CAAC,EAAEL,MAAM,CAAC;IAC3B;IAEA,MAAMM,EAAE,GAAGF,EAAE,CAACG,KAAK,CAAC,CAAC;IACrB,MAAMC,EAAE,GAAGN,EAAE,CAACK,KAAK,CAAC,CAAC;IAErB,IAAIf,QAAQ,EAAE;MACVc,EAAE,CAACD,SAAS,CAAClB,IAAI,EAAE,CAAC,CAAC;MACrBqB,EAAE,CAACH,SAAS,CAAClB,IAAI,EAAE,CAAC,CAAC;IACzB,CAAC,MAAM;MACHmB,EAAE,CAACD,SAAS,CAAC,CAAC,EAAElB,IAAI,CAAC;MACrBqB,EAAE,CAACH,SAAS,CAAC,CAAC,EAAElB,IAAI,CAAC;IACzB;IAEA,OAAO,CAAEe,EAAE,EAAEE,EAAE,EAAEE,EAAE,EAAEE,EAAE,CAAE;EAC7B;EAEAC,OAAOA,CAAA,EAAG;IACN,MAAM;MAAExB,KAAK;MAAEC;IAAQ,CAAC,GAAG,IAAI;IAC/B,MAAMwB,KAAK,GAAG,IAAI,CAACrB,YAAY,CAACH,OAAO,CAACI,KAAK,CAAC;IAC9C,MAAMqB,WAAW,GAAG,IAAI,CAACA,WAAW;IACpC,MAAMC,QAAQ,GAAG,IAAI,CAACvB,YAAY,CAACH,OAAO,CAAC2B,SAAS,CAAC;IAErDF,WAAW,CAACG,MAAM,CAACJ,KAAK,CAAC,CAAC,CAAC,CAAC,CAACK,MAAM,CAACL,KAAK,CAAC,CAAC,CAAC,CAAC,CAACK,MAAM,CAACL,KAAK,CAAC,CAAC,CAAC,CAAC,CAACK,MAAM,CAACL,KAAK,CAAC,CAAC,CAAC,CAAC,CAACM,KAAK,CAAC,CAAC;IAEvF,MAAMC,SAAS,GAAG,IAAIrC,yBAAyB,CAAC+B,WAAW,EAAEpC,UAAU,CAACW,OAAO,CAAC+B,SAAS,EAAE;MACvFC,OAAO,EAAEjC,KAAK,CAACC,OAAO,CAACgC,OAAO;MAC9B1B,QAAQ,EAAEP,KAAK,CAACC,OAAO,CAACM,QAAQ;MAChC2B,SAAS,EAAE,CAAEP,QAAQ,CAAC,CAAC,CAAC,EAAEA,QAAQ,CAAC,CAAC,CAAC,CAAE;MACvCQ,SAAS,EAAE,CAAEV,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC;IACnC,CAAC,CAAC,CAAC;IAEH,IAAIxB,OAAO,CAAC+B,SAAS,CAACI,WAAW,KAAK,KAAK,EAAE;MACzCJ,SAAS,CAAC/B,OAAO,CAACoC,QAAQ,GAAG,CAAC;IAClC;IAEAL,SAAS,CAACM,KAAK,CAAC,CAAC;IACjBN,SAAS,CAACO,IAAI,CAAC,CAAC;EACpB;EAEAC,MAAMA,CAAA,EAAG;IACL,MAAMC,KAAK,GAAG,IAAI7C,KAAK,CAAC,CAAC;IACzB,MAAM8C,cAAc,GAAG,IAAI,CAACC,iBAAiB,CAAC,CAAC;IAE/C,IAAI,IAAI,CAAC1C,OAAO,CAAC2C,KAAK,CAACC,OAAO,EAAE;MAC5BJ,KAAK,CAACK,MAAM,CAAC,IAAI,CAACC,WAAW,CAAC,CAAC,CAAC;IACpC;IAEA,MAAMC,OAAO,GAAG,IAAI,CAACtB,WAAW,GAAG,IAAI7B,IAAI,CAAC;MACxCoD,MAAM,EAAEP,cAAc,CAACO,MAAM;MAC7BC,IAAI,EAAER,cAAc,CAACQ;IACzB,CAAC,CAAC;IAEFT,KAAK,CAACK,MAAM,CAACE,OAAO,CAAC;IAErB,IAAI,CAACG,QAAQ,GAAGV,KAAK;IAErB,OAAOA,KAAK;EAChB;EAEAM,WAAWA,CAAA,EAAG;IACV,MAAMK,YAAY,GAAG,IAAI,CAACnD,OAAO,CAAC2C,KAAK;IACvC,MAAMS,MAAM,GAAGD,YAAY,CAACC,MAAM,IAAI,CAAC,CAAC;IACxC,MAAMC,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAAChC,KAAK,CAAC,CAAC,CAACiC,GAAG,CAACF,MAAM,CAACG,KAAK,IAAI,CAAC,CAAC;IAE7D,OAAO,IAAI3D,IAAI,CAAC4D,QAAQ,CAACH,QAAQ,CAACI,MAAM,CAAC,CAAC,EAAE;MACxCR,IAAI,EAAE;QACFS,KAAK,EAAEP,YAAY,CAACO,KAAK;QACzBC,OAAO,EAAER,YAAY,CAACQ;MAC1B,CAAC;MACDX,MAAM,EAAE;QACJU,KAAK,EAAEN,MAAM,CAACG,KAAK,GAAGH,MAAM,CAACM,KAAK,IAAIP,YAAY,CAACO,KAAK,GAAG,EAAE;QAC7DH,KAAK,EAAEH,MAAM,CAACG,KAAK;QACnBK,QAAQ,EAAER,MAAM,CAACQ;MACrB;IACJ,CAAC,CAAC;EACN;AACJ;AAEA,eAAe/D,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}