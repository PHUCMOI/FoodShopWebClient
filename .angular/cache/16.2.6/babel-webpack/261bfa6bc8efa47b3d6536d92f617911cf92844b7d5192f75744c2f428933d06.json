{"ast":null,"code":"import QuadRoot from './quad-root';\nimport QuadNode from './quad-node';\nimport { Rect } from '../geometry';\nimport { Class } from '../common';\nimport { append } from '../util';\nconst ROOT_SIZE = 3000;\nconst LEVEL_STEP = 10000;\nconst MAX_LEVEL = 75;\nclass ShapesQuadTree extends Class {\n  constructor() {\n    super();\n    this.initRoots();\n  }\n  initRoots() {\n    this.rootMap = {};\n    this.root = new QuadRoot();\n    this.rootElements = [];\n  }\n  clear() {\n    const rootElements = this.rootElements;\n    for (let idx = 0; idx < rootElements.length; idx++) {\n      this.remove(rootElements[idx]);\n    }\n    this.initRoots();\n  }\n  pointShape(point) {\n    const sectorRoot = (this.rootMap[Math.floor(point.x / ROOT_SIZE)] || {})[Math.floor(point.y / ROOT_SIZE)];\n    let result = this.root.pointShapes(point);\n    if (sectorRoot) {\n      result = result.concat(sectorRoot.pointShapes(point));\n    }\n    this.assignZindex(result);\n    result.sort(zIndexComparer);\n    for (let idx = 0; idx < result.length; idx++) {\n      if (result[idx].containsPoint(point)) {\n        return result[idx];\n      }\n    }\n  }\n  assignZindex(elements) {\n    for (let idx = 0; idx < elements.length; idx++) {\n      let element = elements[idx];\n      let zIndex = 0;\n      let levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);\n      let parents = [];\n      while (element) {\n        parents.push(element);\n        element = element.parent;\n      }\n      while (parents.length) {\n        element = parents.pop();\n        zIndex += ((element.parent ? element.parent.children : this.rootElements).indexOf(element) + 1) * levelWeight;\n        levelWeight /= LEVEL_STEP;\n      }\n      elements[idx]._zIndex = zIndex;\n    }\n  }\n  optionsChange(e) {\n    if (e.field === \"transform\" || e.field === \"stroke.width\") {\n      this.bboxChange(e.element);\n    }\n  }\n  geometryChange(e) {\n    this.bboxChange(e.element);\n  }\n  bboxChange(element) {\n    if (element.nodeType === \"Group\") {\n      for (let idx = 0; idx < element.children.length; idx++) {\n        this.bboxChange(element.children[idx]);\n      }\n    } else {\n      if (element._quadNode) {\n        element._quadNode.remove(element);\n      }\n      this._insertShape(element);\n    }\n  }\n  add(elements) {\n    const elementsArray = Array.isArray(elements) ? elements.slice(0) : [elements];\n    append(this.rootElements, elementsArray);\n    this._insert(elementsArray);\n  }\n  childrenChange(e) {\n    if (e.action === \"remove\") {\n      for (let idx = 0; idx < e.items.length; idx++) {\n        this.remove(e.items[idx]);\n      }\n    } else {\n      this._insert(Array.prototype.slice.call(e.items, 0));\n    }\n  }\n  _insert(elements) {\n    let element;\n    while (elements.length > 0) {\n      element = elements.pop();\n      element.addObserver(this);\n      if (element.nodeType === \"Group\") {\n        append(elements, element.children);\n      } else {\n        this._insertShape(element);\n      }\n    }\n  }\n  _insertShape(shape) {\n    const bbox = shape.bbox();\n    if (bbox) {\n      const sectors = this.getSectors(bbox);\n      const x = sectors[0][0];\n      const y = sectors[1][0];\n      if (this.inRoot(sectors)) {\n        this.root.insert(shape, bbox);\n      } else {\n        const rootMap = this.rootMap;\n        if (!rootMap[x]) {\n          rootMap[x] = {};\n        }\n        if (!rootMap[x][y]) {\n          rootMap[x][y] = new QuadNode(new Rect([x * ROOT_SIZE, y * ROOT_SIZE], [ROOT_SIZE, ROOT_SIZE]));\n        }\n        rootMap[x][y].insert(shape, bbox);\n      }\n    }\n  }\n  remove(element) {\n    element.removeObserver(this);\n    if (element.nodeType === \"Group\") {\n      const children = element.children;\n      for (let idx = 0; idx < children.length; idx++) {\n        this.remove(children[idx]);\n      }\n    } else if (element._quadNode) {\n      element._quadNode.remove(element);\n      delete element._quadNode;\n    }\n  }\n  inRoot(sectors) {\n    return sectors[0].length > 1 || sectors[1].length > 1;\n  }\n  getSectors(rect) {\n    const bottomRight = rect.bottomRight();\n    const bottomX = Math.floor(bottomRight.x / ROOT_SIZE);\n    const bottomY = Math.floor(bottomRight.y / ROOT_SIZE);\n    const sectors = [[], []];\n    for (let x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {\n      sectors[0].push(x);\n    }\n    for (let y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {\n      sectors[1].push(y);\n    }\n    return sectors;\n  }\n}\nfunction zIndexComparer(x1, x2) {\n  if (x1._zIndex < x2._zIndex) {\n    return 1;\n  }\n  if (x1._zIndex > x2._zIndex) {\n    return -1;\n  }\n  return 0;\n}\nexport default ShapesQuadTree;","map":{"version":3,"names":["QuadRoot","QuadNode","Rect","Class","append","ROOT_SIZE","LEVEL_STEP","MAX_LEVEL","ShapesQuadTree","constructor","initRoots","rootMap","root","rootElements","clear","idx","length","remove","pointShape","point","sectorRoot","Math","floor","x","y","result","pointShapes","concat","assignZindex","sort","zIndexComparer","containsPoint","elements","element","zIndex","levelWeight","pow","parents","push","parent","pop","children","indexOf","_zIndex","optionsChange","e","field","bboxChange","geometryChange","nodeType","_quadNode","_insertShape","add","elementsArray","Array","isArray","slice","_insert","childrenChange","action","items","prototype","call","addObserver","shape","bbox","sectors","getSectors","inRoot","insert","removeObserver","rect","bottomRight","bottomX","bottomY","origin","x1","x2"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-drawing/dist/es2015/search/shapes-quad-tree.js"],"sourcesContent":["import QuadRoot from './quad-root';\nimport QuadNode from './quad-node';\nimport { Rect } from '../geometry';\nimport { Class } from '../common';\nimport { append } from '../util';\n\nconst ROOT_SIZE = 3000;\nconst LEVEL_STEP = 10000;\nconst MAX_LEVEL = 75;\n\nclass ShapesQuadTree extends Class {\n\n    constructor() {\n        super();\n\n        this.initRoots();\n    }\n\n    initRoots() {\n        this.rootMap = {};\n        this.root = new QuadRoot();\n        this.rootElements = [];\n    }\n\n    clear() {\n        const rootElements = this.rootElements;\n        for (let idx = 0; idx < rootElements.length; idx++) {\n            this.remove(rootElements[idx]);\n        }\n        this.initRoots();\n    }\n\n    pointShape(point) {\n        const sectorRoot = ( this.rootMap[ Math.floor( point.x / ROOT_SIZE ) ] || {} )[ Math.floor( point.y / ROOT_SIZE ) ];\n        let result = this.root.pointShapes(point);\n\n        if (sectorRoot) {\n            result = result.concat(sectorRoot.pointShapes(point));\n        }\n\n        this.assignZindex(result);\n\n        result.sort(zIndexComparer);\n        for (let idx = 0; idx < result.length; idx++) {\n            if (result[idx].containsPoint(point)) {\n                return result[idx];\n            }\n        }\n    }\n\n    assignZindex(elements) {\n        for (let idx = 0; idx < elements.length; idx++) {\n            let element = elements[idx];\n            let zIndex = 0;\n            let levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);\n            let parents = [];\n\n            while (element) {\n                parents.push(element);\n                element = element.parent;\n            }\n\n            while (parents.length) {\n                element = parents.pop();\n                zIndex += ((element.parent ? element.parent.children : this.rootElements).indexOf(element) + 1) * levelWeight;\n                levelWeight /= LEVEL_STEP;\n            }\n\n            elements[idx]._zIndex = zIndex;\n        }\n    }\n\n    optionsChange(e) {\n        if (e.field === \"transform\" || e.field === \"stroke.width\") {\n            this.bboxChange(e.element);\n        }\n    }\n\n    geometryChange(e) {\n        this.bboxChange(e.element);\n    }\n\n    bboxChange(element) {\n        if (element.nodeType === \"Group\") {\n            for (let idx = 0; idx < element.children.length; idx++) {\n                this.bboxChange(element.children[idx]);\n            }\n        } else {\n            if (element._quadNode) {\n                element._quadNode.remove(element);\n            }\n            this._insertShape(element);\n        }\n    }\n\n    add(elements) {\n        const elementsArray = Array.isArray(elements) ? elements.slice(0) : [ elements ];\n\n        append(this.rootElements, elementsArray);\n        this._insert(elementsArray);\n    }\n\n    childrenChange(e) {\n        if (e.action === \"remove\") {\n            for (let idx = 0; idx < e.items.length; idx++) {\n                this.remove(e.items[idx]);\n            }\n        } else {\n            this._insert(Array.prototype.slice.call(e.items, 0));\n        }\n    }\n\n    _insert(elements) {\n        let element;\n\n        while (elements.length > 0) {\n            element = elements.pop();\n            element.addObserver(this);\n            if (element.nodeType === \"Group\") {\n                append(elements, element.children);\n            } else {\n                this._insertShape(element);\n            }\n        }\n    }\n\n    _insertShape(shape) {\n        const bbox = shape.bbox();\n        if (bbox) {\n            const sectors = this.getSectors(bbox);\n            const x = sectors[0][0];\n            const y = sectors[1][0];\n\n            if (this.inRoot(sectors)) {\n                this.root.insert(shape, bbox);\n            } else {\n                const rootMap = this.rootMap;\n                if (!rootMap[x]) {\n                    rootMap[x] = {};\n                }\n\n                if (!rootMap[x][y]) {\n                    rootMap[x][y] = new QuadNode(\n                        new Rect([ x * ROOT_SIZE, y * ROOT_SIZE ], [ ROOT_SIZE, ROOT_SIZE ])\n                    );\n                }\n\n                rootMap[x][y].insert(shape, bbox);\n            }\n        }\n    }\n\n    remove(element) {\n        element.removeObserver(this);\n\n        if (element.nodeType === \"Group\") {\n            const children = element.children;\n            for (let idx = 0; idx < children.length; idx++) {\n                this.remove(children[idx]);\n            }\n        } else if (element._quadNode) {\n            element._quadNode.remove(element);\n            delete element._quadNode;\n        }\n    }\n\n    inRoot(sectors) {\n        return sectors[0].length > 1 || sectors[1].length > 1;\n    }\n\n    getSectors(rect) {\n        const bottomRight = rect.bottomRight();\n        const bottomX = Math.floor(bottomRight.x / ROOT_SIZE);\n        const bottomY = Math.floor(bottomRight.y / ROOT_SIZE);\n        const sectors = [ [], [] ];\n        for (let x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {\n            sectors[0].push(x);\n        }\n        for (let y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {\n            sectors[1].push(y);\n        }\n        return sectors;\n    }\n}\n\nfunction zIndexComparer(x1, x2) {\n    if (x1._zIndex < x2._zIndex) {\n        return 1;\n    }\n    if (x1._zIndex > x2._zIndex) {\n        return -1;\n    }\n\n    return 0;\n}\n\nexport default ShapesQuadTree;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}