{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport { ChartElement, Box } from '../../core';\nimport Crosshair from '../crosshair/crosshair';\nimport Pane from '../pane';\nimport { hasValue } from '../utils';\nimport SeriesBinder from '../series-binder';\nimport { WHITE, BLACK, X, Y, COORD_PRECISION, TOP, BOTTOM, LEFT, RIGHT, START, END, INHERIT } from '../../common/constants';\nimport { append, deepExtend, defined, getSpacing, getTemplate, inArray, isFunction, isString, limitValue, round, setDefaultOptions, last } from '../../common';\nimport { TRENDLINE_SERIES } from '../constants';\nclass PlotAreaBase extends ChartElement {\n  constructor(series, options, chartService) {\n    super(options);\n    this.initFields(series, options);\n    this.series = series;\n    this.initSeries();\n    this.charts = [];\n    this.options.legend = this.options.legend || {};\n    this.options.legend.items = [];\n    this.axes = [];\n    this.crosshairs = [];\n    this.chartService = chartService;\n    this.originalOptions = options;\n    this.originalSeries = series;\n    this._bindCache = new WeakMap();\n    this.createPanes();\n    this.render();\n    this.createCrosshairs();\n  }\n  initFields() {}\n  initSeries() {\n    const series = this.series;\n    for (let i = 0; i < series.length; i++) {\n      series[i].index = i;\n    }\n  }\n  bindPoint(series, pointIx, item) {\n    let cached = this._bindCache.get(series);\n    if (!cached) {\n      cached = [];\n      this._bindCache.set(series, cached);\n    }\n    let data = cached[pointIx];\n    if (!data) {\n      data = cached[pointIx] = SeriesBinder.current.bindPoint(series, pointIx, item);\n    }\n    return data;\n  }\n  createPanes() {\n    const titleOptions = this.options.title || {};\n    const paneDefaults = this.options.paneDefaults;\n    const paneOptions = this.options.panes || [];\n    const panesLength = Math.max(paneOptions.length, 1);\n    const panes = [];\n    const defaults = deepExtend({\n      title: {\n        color: titleOptions.color\n      }\n    }, paneDefaults);\n    for (let i = 0; i < panesLength; i++) {\n      const options = deepExtend({}, defaults, paneOptions[i]);\n      if (isString(options.title)) {\n        options.title = deepExtend({\n          text: options.title\n        }, defaults.title);\n      }\n      const currentPane = new Pane(options);\n      currentPane.paneIndex = i;\n      panes.push(currentPane);\n      this.append(currentPane);\n    }\n    this.panes = panes;\n  }\n  crosshairOptions(axis) {\n    return axis.options.crosshair;\n  }\n  createCrosshairs(panes = this.panes) {\n    for (let i = 0; i < panes.length; i++) {\n      const pane = panes[i];\n      for (let j = 0; j < pane.axes.length; j++) {\n        const axis = pane.axes[j];\n        const options = this.crosshairOptions(axis);\n        if (options && options.visible) {\n          const currentCrosshair = new Crosshair(this.chartService, axis, options);\n          this.crosshairs.push(currentCrosshair);\n          pane.content.append(currentCrosshair);\n        }\n      }\n    }\n  }\n  removeCrosshairs(pane) {\n    const crosshairs = this.crosshairs;\n    const axes = pane.axes;\n    for (let i = crosshairs.length - 1; i >= 0; i--) {\n      for (let j = 0; j < axes.length; j++) {\n        if (crosshairs[i].axis === axes[j]) {\n          crosshairs.splice(i, 1);\n          break;\n        }\n      }\n    }\n  }\n  hideCrosshairs() {\n    const crosshairs = this.crosshairs;\n    for (let idx = 0; idx < crosshairs.length; idx++) {\n      crosshairs[idx].hide();\n    }\n  }\n  findPane(name) {\n    const panes = this.panes;\n    let matchingPane;\n    for (let i = 0; i < panes.length; i++) {\n      if (panes[i].options.name === name) {\n        matchingPane = panes[i];\n        break;\n      }\n    }\n    return matchingPane || panes[0];\n  }\n  findPointPane(point) {\n    const panes = this.panes;\n    let matchingPane;\n    for (let i = 0; i < panes.length; i++) {\n      if (panes[i].box.containsPoint(point)) {\n        matchingPane = panes[i];\n        break;\n      }\n    }\n    return matchingPane;\n  }\n  appendAxis(axis) {\n    const pane = this.findPane(axis.options.pane);\n    pane.appendAxis(axis);\n    this.axes.push(axis);\n    axis.plotArea = this;\n  }\n  removeAxis(axisToRemove) {\n    const filteredAxes = [];\n    for (let i = 0; i < this.axes.length; i++) {\n      const axis = this.axes[i];\n      if (axisToRemove !== axis) {\n        filteredAxes.push(axis);\n      } else {\n        axis.destroy();\n      }\n    }\n    this.axes = filteredAxes;\n  }\n  appendChart(chart, pane) {\n    this.charts.push(chart);\n    if (pane) {\n      pane.appendChart(chart);\n    } else {\n      this.append(chart);\n    }\n  }\n  removeChart(chartToRemove) {\n    const filteredCharts = [];\n    for (let i = 0; i < this.charts.length; i++) {\n      const chart = this.charts[i];\n      if (chart !== chartToRemove) {\n        filteredCharts.push(chart);\n      } else {\n        chart.destroy();\n      }\n    }\n    this.charts = filteredCharts;\n  }\n  addToLegend(series) {\n    const count = series.length;\n    const legend = this.options.legend;\n    const labels = legend.labels || {};\n    const inactiveItems = legend.inactiveItems || {};\n    const inactiveItemsLabels = inactiveItems.labels || {};\n    const data = [];\n    for (let i = 0; i < count; i++) {\n      const currentSeries = series[i];\n      const seriesVisible = currentSeries.visible !== false;\n      if (currentSeries.visibleInLegend === false) {\n        continue;\n      }\n      let text = currentSeries.name;\n      const labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);\n      if (labelTemplate) {\n        text = labelTemplate({\n          text: hasValue(text) ? text : \"\",\n          series: currentSeries\n        });\n      }\n      const defaults = currentSeries._defaults;\n      let color = currentSeries.color;\n      if (isFunction(color) && defaults) {\n        color = defaults.color;\n      }\n      let itemLabelOptions, markerColor;\n      if (seriesVisible) {\n        itemLabelOptions = {};\n        markerColor = color;\n      } else {\n        itemLabelOptions = {\n          color: inactiveItemsLabels.color,\n          font: inactiveItemsLabels.font\n        };\n        markerColor = inactiveItems.markers.color;\n      }\n      if (hasValue(text) && text !== \"\") {\n        data.push({\n          text: text,\n          labels: itemLabelOptions,\n          markerColor: markerColor,\n          series: currentSeries,\n          active: seriesVisible\n        });\n      }\n    }\n    append(legend.items, data);\n  }\n  groupAxes(panes) {\n    const xAxes = [];\n    const yAxes = [];\n    for (let paneIx = 0; paneIx < panes.length; paneIx++) {\n      const paneAxes = panes[paneIx].axes;\n      for (let axisIx = 0; axisIx < paneAxes.length; axisIx++) {\n        const axis = paneAxes[axisIx];\n        if (axis.options.vertical) {\n          yAxes.push(axis);\n        } else {\n          xAxes.push(axis);\n        }\n      }\n    }\n    return {\n      x: xAxes,\n      y: yAxes,\n      any: xAxes.concat(yAxes)\n    };\n  }\n  groupSeriesByPane() {\n    const series = this.series;\n    const seriesByPane = {};\n    for (let i = 0; i < series.length; i++) {\n      const currentSeries = series[i];\n      const pane = this.seriesPaneName(currentSeries);\n      if (seriesByPane[pane]) {\n        seriesByPane[pane].push(currentSeries);\n      } else {\n        seriesByPane[pane] = [currentSeries];\n      }\n    }\n    return seriesByPane;\n  }\n  filterVisibleSeries(series) {\n    const result = [];\n    for (let i = 0; i < series.length; i++) {\n      const currentSeries = series[i];\n      if (currentSeries.visible !== false) {\n        result.push(currentSeries);\n      }\n    }\n    return result;\n  }\n  reflow(targetBox) {\n    const options = this.options.plotArea;\n    const panes = this.panes;\n    const margin = getSpacing(options.margin);\n    this.box = targetBox.clone().unpad(margin);\n    this.reflowPanes();\n    this.detachLabels();\n    this.reflowAxes(panes);\n    this.reflowCharts(panes);\n  }\n  redraw(panes) {\n    const panesArray = [].concat(panes);\n    this.initSeries();\n\n    //prevents leak during partial redraws. the cached gradients observers retain reference to the destroyed elements.\n    const root = this.getRoot();\n    if (root) {\n      root.cleanGradients();\n    }\n    for (let i = 0; i < panesArray.length; i++) {\n      this.removeCrosshairs(panesArray[i]);\n      panesArray[i].empty();\n    }\n    this._bindCache = new WeakMap();\n    this.render(panesArray);\n    this.detachLabels();\n    this.reflowAxes(this.panes);\n    this.reflowCharts(panesArray);\n    this.createCrosshairs(panesArray);\n    for (let i = 0; i < panesArray.length; i++) {\n      panesArray[i].refresh();\n    }\n  }\n  axisCrossingValues(axis, crossingAxes) {\n    const options = axis.options;\n    const crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);\n    const valuesToAdd = crossingAxes.length - crossingValues.length;\n    const defaultValue = crossingValues[0] || 0;\n    for (let i = 0; i < valuesToAdd; i++) {\n      crossingValues.push(defaultValue);\n    }\n    return crossingValues;\n  }\n  alignAxisTo(axis, targetAxis, crossingValue, targetCrossingValue) {\n    const slot = axis.getSlot(crossingValue, crossingValue, true);\n    const slotEdge = axis.options.reverse ? 2 : 1;\n    const targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);\n    const targetEdge = targetAxis.options.reverse ? 2 : 1;\n    const axisBox = axis.box.translate(targetSlot[X + targetEdge] - slot[X + slotEdge], targetSlot[Y + targetEdge] - slot[Y + slotEdge]);\n    if (axis.pane !== targetAxis.pane) {\n      axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);\n    }\n    axis.reflow(axisBox);\n  }\n  alignAxes(xAxes, yAxes) {\n    const xAnchor = xAxes[0];\n    const yAnchor = yAxes[0];\n    const xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);\n    const yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);\n    const leftAnchors = {};\n    const rightAnchors = {};\n    const topAnchors = {};\n    const bottomAnchors = {};\n    for (let i = 0; i < yAxes.length; i++) {\n      const axis = yAxes[i];\n      const pane = axis.pane;\n      const paneId = pane.id;\n      const visible = axis.options.visible !== false;\n\n      // Locate pane anchor, if any, and use its axisCrossingValues\n      const anchor = paneAnchor(xAxes, pane) || xAnchor;\n      let anchorCrossings = xAnchorCrossings;\n      if (anchor !== xAnchor) {\n        anchorCrossings = this.axisCrossingValues(anchor, yAxes);\n      }\n      this.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\n      if (axis.options._overlap) {\n        continue;\n      }\n      if (round(axis.lineBox().x1) === round(anchor.lineBox().x1)) {\n        // Push the axis to the left the previous y-axis so they don't overlap\n        if (leftAnchors[paneId]) {\n          axis.reflow(axis.box.alignTo(leftAnchors[paneId].box, LEFT).translate(-axis.options.margin, 0));\n        }\n        if (visible) {\n          leftAnchors[paneId] = axis;\n        }\n      }\n      if (round(axis.lineBox().x2) === round(anchor.lineBox().x2)) {\n        // Flip the labels on the right if we're at the right end of the pane\n        if (!axis._mirrored) {\n          axis.options.labels.mirror = !axis.options.labels.mirror;\n          axis._mirrored = true;\n        }\n        this.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\n\n        // Push the axis to the right the previous y-axis so they don't overlap\n        if (rightAnchors[paneId]) {\n          axis.reflow(axis.box.alignTo(rightAnchors[paneId].box, RIGHT).translate(axis.options.margin, 0));\n        }\n        if (visible) {\n          rightAnchors[paneId] = axis;\n        }\n      }\n      if (i !== 0 && yAnchor.pane === axis.pane) {\n        axis.alignTo(yAnchor);\n        axis.reflow(axis.box);\n      }\n    }\n    for (let i = 0; i < xAxes.length; i++) {\n      const axis = xAxes[i];\n      const pane = axis.pane;\n      const paneId = pane.id;\n      const visible = axis.options.visible !== false;\n\n      // Locate pane anchor and use its axisCrossingValues\n      const anchor = paneAnchor(yAxes, pane) || yAnchor;\n      let anchorCrossings = yAnchorCrossings;\n      if (anchor !== yAnchor) {\n        anchorCrossings = this.axisCrossingValues(anchor, xAxes);\n      }\n      this.alignAxisTo(axis, anchor, xAnchorCrossings[i], anchorCrossings[i]);\n      if (axis.options._overlap) {\n        continue;\n      }\n      if (round(axis.lineBox().y1) === round(anchor.lineBox().y1)) {\n        // Flip the labels on top if we're at the top of the pane\n        if (!axis._mirrored) {\n          axis.options.labels.mirror = !axis.options.labels.mirror;\n          axis._mirrored = true;\n        }\n        this.alignAxisTo(axis, anchor, xAnchorCrossings[i], anchorCrossings[i]);\n\n        // Push the axis above the previous x-axis so they don't overlap\n        if (topAnchors[paneId]) {\n          axis.reflow(axis.box.alignTo(topAnchors[paneId].box, TOP).translate(0, -axis.options.margin));\n        }\n        if (visible) {\n          topAnchors[paneId] = axis;\n        }\n      }\n      if (round(axis.lineBox().y2, COORD_PRECISION) === round(anchor.lineBox().y2, COORD_PRECISION)) {\n        // Push the axis below the previous x-axis so they don't overlap\n        if (bottomAnchors[paneId]) {\n          axis.reflow(axis.box.alignTo(bottomAnchors[paneId].box, BOTTOM).translate(0, axis.options.margin));\n        }\n        if (visible) {\n          bottomAnchors[paneId] = axis;\n        }\n      }\n      if (i !== 0) {\n        axis.alignTo(xAnchor);\n        axis.reflow(axis.box);\n      }\n    }\n  }\n  shrinkAxisWidth(panes) {\n    const axes = this.groupAxes(panes).any;\n    const axisBox = axisGroupBox(axes);\n    let overflowX = 0;\n    for (let i = 0; i < panes.length; i++) {\n      const currentPane = panes[i];\n      if (currentPane.axes.length > 0) {\n        overflowX = Math.max(overflowX, axisBox.width() - currentPane.contentBox.width());\n      }\n    }\n    if (overflowX !== 0) {\n      for (let i = 0; i < axes.length; i++) {\n        const currentAxis = axes[i];\n        if (!currentAxis.options.vertical) {\n          currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));\n        }\n      }\n    }\n  }\n  shrinkAxisHeight(panes) {\n    let shrinked;\n    for (let i = 0; i < panes.length; i++) {\n      const currentPane = panes[i];\n      const axes = currentPane.axes;\n      const overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());\n      if (overflowY !== 0) {\n        for (let j = 0; j < axes.length; j++) {\n          const currentAxis = axes[j];\n          if (currentAxis.options.vertical) {\n            currentAxis.reflow(currentAxis.box.shrink(0, overflowY));\n          }\n        }\n        shrinked = true;\n      }\n    }\n    return shrinked;\n  }\n  fitAxes(panes) {\n    const axes = this.groupAxes(panes).any;\n    let offsetX = 0;\n    for (let i = 0; i < panes.length; i++) {\n      const currentPane = panes[i];\n      const paneAxes = currentPane.axes;\n      const paneBox = currentPane.contentBox;\n      if (paneAxes.length > 0) {\n        const axisBox = axisGroupBox(paneAxes);\n        // OffsetY is calculated and applied per pane\n        const offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);\n\n        // OffsetX is calculated and applied globally\n        offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);\n        for (let j = 0; j < paneAxes.length; j++) {\n          const currentAxis = paneAxes[j];\n          currentAxis.reflow(currentAxis.box.translate(0, offsetY));\n        }\n      }\n    }\n    for (let i = 0; i < axes.length; i++) {\n      const currentAxis = axes[i];\n      currentAxis.reflow(currentAxis.box.translate(offsetX, 0));\n    }\n  }\n  reflowAxes(panes) {\n    const axes = this.groupAxes(panes);\n    for (let i = 0; i < panes.length; i++) {\n      this.reflowPaneAxes(panes[i]);\n    }\n    if (axes.x.length > 0 && axes.y.length > 0) {\n      this.alignAxes(axes.x, axes.y);\n      this.shrinkAxisWidth(panes);\n      this.autoRotateAxisLabels(axes);\n      this.alignAxes(axes.x, axes.y);\n      if (this.shrinkAxisWidth(panes)) {\n        this.alignAxes(axes.x, axes.y);\n      }\n      this.shrinkAxisHeight(panes);\n      this.alignAxes(axes.x, axes.y);\n      if (this.shrinkAxisHeight(panes)) {\n        this.alignAxes(axes.x, axes.y);\n      }\n      this.fitAxes(panes);\n    }\n  }\n  autoRotateAxisLabels(groupedAxes) {\n    const {\n      panes\n    } = this;\n    const axes = allPaneAxes(panes);\n    let rotated;\n    for (let idx = 0; idx < axes.length; idx++) {\n      const axis = axes[idx];\n      if (axis.autoRotateLabels()) {\n        rotated = true;\n      }\n    }\n    if (rotated) {\n      for (let idx = 0; idx < panes.length; idx++) {\n        this.reflowPaneAxes(panes[idx]);\n      }\n      if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {\n        this.alignAxes(groupedAxes.x, groupedAxes.y);\n        this.shrinkAxisWidth(panes);\n      }\n    }\n  }\n  reflowPaneAxes(pane) {\n    const axes = pane.axes;\n    const length = axes.length;\n    if (length > 0) {\n      for (let i = 0; i < length; i++) {\n        axes[i].reflow(pane.contentBox);\n      }\n    }\n  }\n  reflowCharts(panes) {\n    const charts = this.charts;\n    const count = charts.length;\n    const box = this.box;\n    for (let i = 0; i < count; i++) {\n      const chartPane = charts[i].pane;\n      if (!chartPane || inArray(chartPane, panes)) {\n        charts[i].reflow(box);\n      }\n    }\n  }\n  reflowPanes() {\n    const {\n      box,\n      panes\n    } = this;\n    const panesLength = panes.length;\n    let remainingHeight = box.height();\n    let remainingPanes = panesLength;\n    let autoHeightPanes = 0;\n    let top = box.y1;\n    for (let i = 0; i < panesLength; i++) {\n      const currentPane = panes[i];\n      const height = currentPane.options.height;\n      currentPane.options.width = box.width();\n      if (!currentPane.options.height) {\n        autoHeightPanes++;\n      } else {\n        if (height.indexOf && height.indexOf(\"%\")) {\n          const percents = parseInt(height, 10) / 100;\n          currentPane.options.height = percents * box.height();\n        }\n        currentPane.reflow(box.clone());\n        remainingHeight -= currentPane.options.height;\n      }\n    }\n    for (let i = 0; i < panesLength; i++) {\n      const currentPane = panes[i];\n      if (!currentPane.options.height) {\n        currentPane.options.height = remainingHeight / autoHeightPanes;\n      }\n    }\n    for (let i = 0; i < panesLength; i++) {\n      const currentPane = panes[i];\n      const paneBox = box.clone().move(box.x1, top);\n      currentPane.reflow(paneBox);\n      remainingPanes--;\n      top += currentPane.options.height;\n    }\n  }\n  backgroundBox() {\n    const axes = this.axes;\n    const axesCount = axes.length;\n    let box;\n    for (let i = 0; i < axesCount; i++) {\n      const axisA = axes[i];\n      for (let j = 0; j < axesCount; j++) {\n        const axisB = axes[j];\n        if (axisA.options.vertical !== axisB.options.vertical) {\n          const lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());\n          if (!box) {\n            box = lineBox;\n          } else {\n            box = box.wrap(lineBox);\n          }\n        }\n      }\n    }\n    return box || this.box;\n  }\n  chartsBoxes() {\n    const panes = this.panes;\n    const boxes = [];\n    for (let idx = 0; idx < panes.length; idx++) {\n      boxes.push(panes[idx].chartsBox());\n    }\n    return boxes;\n  }\n  addBackgroundPaths(multipath) {\n    const boxes = this.chartsBoxes();\n    for (let idx = 0; idx < boxes.length; idx++) {\n      multipath.paths.push(draw.Path.fromRect(boxes[idx].toRect()));\n    }\n  }\n  backgroundContainsPoint(point) {\n    const boxes = this.chartsBoxes();\n    for (let idx = 0; idx < boxes.length; idx++) {\n      if (boxes[idx].containsPoint(point)) {\n        return true;\n      }\n    }\n  }\n  createVisual() {\n    super.createVisual();\n    const options = this.options.plotArea;\n    let {\n      opacity,\n      background,\n      border = {}\n    } = options;\n    if (isTransparent(background)) {\n      background = WHITE;\n      opacity = 0;\n    }\n    const bg = this._bgVisual = new draw.MultiPath({\n      fill: {\n        color: background,\n        opacity: opacity\n      },\n      stroke: {\n        color: border.width ? border.color : \"\",\n        width: border.width,\n        dashType: border.dashType\n      },\n      zIndex: -1\n    });\n    this.addBackgroundPaths(bg);\n    this.appendVisual(bg);\n  }\n  pointsByCategoryIndex(categoryIndex) {\n    const charts = this.charts;\n    const result = [];\n    if (categoryIndex !== null) {\n      for (let i = 0; i < charts.length; i++) {\n        const chart = charts[i];\n        if (chart.pane.options.name === \"_navigator\") {\n          continue;\n        }\n        const points = charts[i].categoryPoints[categoryIndex];\n        if (points && points.length) {\n          for (let j = 0; j < points.length; j++) {\n            const point = points[j];\n            if (point && defined(point.value) && point.value !== null) {\n              result.push(point);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }\n  pointsBySeriesIndex(seriesIndex) {\n    return this.filterPoints(function (point) {\n      return point.series.index === seriesIndex;\n    });\n  }\n  pointsBySeriesName(name) {\n    return this.filterPoints(function (point) {\n      return point.series.name === name;\n    });\n  }\n  filterPoints(callback) {\n    const charts = this.charts;\n    const result = [];\n    for (let i = 0; i < charts.length; i++) {\n      const chart = charts[i];\n      const points = chart.points;\n      for (let j = 0; j < points.length; j++) {\n        const point = points[j];\n        if (point && point.visible !== false && callback(point)) {\n          result.push(point);\n        }\n      }\n    }\n    return result;\n  }\n  findPoint(callback) {\n    const charts = this.charts;\n    for (let i = 0; i < charts.length; i++) {\n      const chart = charts[i];\n      const points = chart.points;\n      for (let j = 0; j < points.length; j++) {\n        const point = points[j];\n        if (point && point.visible !== false && callback(point)) {\n          return point;\n        }\n      }\n    }\n  }\n  paneByPoint(point) {\n    const panes = this.panes;\n    for (let i = 0; i < panes.length; i++) {\n      const pane = panes[i];\n      if (pane.box.containsPoint(point)) {\n        return pane;\n      }\n    }\n  }\n  detachLabels() {\n    const axes = this.groupAxes(this.panes);\n    const xAxes = axes.x;\n    const yAxes = axes.y;\n    this.detachAxisGroupLabels(yAxes, xAxes);\n    this.detachAxisGroupLabels(xAxes, yAxes);\n  }\n  detachAxisGroupLabels(axes, crossingAxes) {\n    let labelAxisCount = 0;\n    for (let i = 0; i < axes.length; i++) {\n      const axis = axes[i];\n      const pane = axis.pane;\n      const anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];\n      const axisIndex = i + labelAxisCount;\n      const labelAxis = this.createLabelAxis(axis, axisIndex, anchor);\n      if (labelAxis) {\n        labelAxisCount++;\n        const pos = pane.axes.indexOf(axis) + labelAxisCount;\n        pane.appendAxisAt(labelAxis, pos);\n      }\n    }\n  }\n  createLabelAxis(axis, axisIndex, anchor) {\n    const labelOptions = axis.options.labels;\n    const position = labelOptions.position;\n    const onAxis = position !== END && position !== START;\n    const visible = labelOptions.visible;\n    if (onAxis || visible === false) {\n      return null;\n    }\n    const allAxes = this.groupAxes(this.panes);\n    const crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;\n    const anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);\n    const end = position === END;\n    const range = anchor.range();\n    const edge = end ? range.max : range.min;\n    const crossingValue = limitValue(anchorCrossings[axisIndex], range.min, range.max);\n    if (crossingValue - edge === 0) {\n      return null;\n    }\n    anchorCrossings.splice(axisIndex + 1, 0, edge);\n    anchor.options.axisCrossingValues = anchorCrossings;\n    const labelAxis = axis.clone();\n    axis.clear();\n    labelAxis.options.name = undefined;\n    labelAxis.options.line.visible = false;\n    labelAxis.options.crosshair = undefined;\n    labelAxis.options.notes = undefined;\n    labelAxis.options.plotBands = undefined;\n    return labelAxis;\n  }\n  isTrendline(series) {\n    return series && inArray(series.type, TRENDLINE_SERIES);\n  }\n  trendlineFactory() {/* abstract */}\n  createTrendlineSeries() {\n    const modifiedSeries = [];\n    this.series = this.series.map(series => {\n      if (!this.isTrendline(series)) {\n        return series;\n      }\n      const forSeries = this.seriesByName(series.for);\n      if (!forSeries) {\n        throw new Error('Invalid Configuration: Unable to locate linked series ' + `\"${series.for}\" for trendline \"${series.name}\".`);\n      }\n      const valueFields = SeriesBinder.current.valueFields(forSeries);\n      const field = last(valueFields); // Use the last field for multi-field series\n\n      const trendlineSeries = this.trendlineFactory(Object.assign({}, {\n        field\n      }, series), forSeries);\n      if (trendlineSeries) {\n        if (forSeries.visible === false) {\n          trendlineSeries.visible = false;\n        }\n        if (trendlineSeries.color === INHERIT) {\n          trendlineSeries.color = forSeries.color;\n        }\n        modifiedSeries.push(trendlineSeries);\n      }\n      return trendlineSeries;\n    }).filter(series => series !== null);\n    return modifiedSeries;\n  }\n  seriesByName(name) {\n    return this.series.find(series => series.name === name);\n  }\n}\nfunction isSingleAxis(axis) {\n  return !axis.pane.axes.some(a => a.options.vertical === axis.options.vertical && a !== axis && a.options.visible !== false);\n}\nfunction axisGroupBox(axes) {\n  const length = axes.length;\n  let box;\n  for (let i = 0; i < length; i++) {\n    const axis = axes[i];\n    const visible = axis.options.visible !== false;\n    if (visible || isSingleAxis(axis)) {\n      const axisBox = visible ? axis.contentBox() : axis.lineBox();\n      if (!box) {\n        box = axisBox.clone();\n      } else {\n        box.wrap(axisBox);\n      }\n    }\n  }\n  return box || new Box();\n}\nfunction paneAnchor(axes, pane) {\n  for (let i = 0; i < axes.length; i++) {\n    const anchor = axes[i];\n    if (anchor && anchor.pane === pane) {\n      return anchor;\n    }\n  }\n}\nfunction isTransparent(color) {\n  return color === \"\" || color === null || color === \"none\" || color === \"transparent\" || !defined(color);\n}\nconst allPaneAxes = panes => panes.reduce((acc, pane) => acc.concat(pane.axes), []);\nsetDefaultOptions(PlotAreaBase, {\n  series: [],\n  plotArea: {\n    margin: {}\n  },\n  background: \"\",\n  border: {\n    color: BLACK,\n    width: 0\n  },\n  paneDefaults: {\n    title: {}\n  },\n  legend: {\n    inactiveItems: {\n      labels: {\n        color: \"#919191\"\n      },\n      markers: {\n        color: \"#919191\"\n      }\n    }\n  }\n});\nexport default PlotAreaBase;","map":{"version":3,"names":["drawing","draw","ChartElement","Box","Crosshair","Pane","hasValue","SeriesBinder","WHITE","BLACK","X","Y","COORD_PRECISION","TOP","BOTTOM","LEFT","RIGHT","START","END","INHERIT","append","deepExtend","defined","getSpacing","getTemplate","inArray","isFunction","isString","limitValue","round","setDefaultOptions","last","TRENDLINE_SERIES","PlotAreaBase","constructor","series","options","chartService","initFields","initSeries","charts","legend","items","axes","crosshairs","originalOptions","originalSeries","_bindCache","WeakMap","createPanes","render","createCrosshairs","i","length","index","bindPoint","pointIx","item","cached","get","set","data","current","titleOptions","title","paneDefaults","paneOptions","panes","panesLength","Math","max","defaults","color","text","currentPane","paneIndex","push","crosshairOptions","axis","crosshair","pane","j","visible","currentCrosshair","content","removeCrosshairs","splice","hideCrosshairs","idx","hide","findPane","name","matchingPane","findPointPane","point","box","containsPoint","appendAxis","plotArea","removeAxis","axisToRemove","filteredAxes","destroy","appendChart","chart","removeChart","chartToRemove","filteredCharts","addToLegend","count","labels","inactiveItems","inactiveItemsLabels","currentSeries","seriesVisible","visibleInLegend","labelTemplate","_defaults","itemLabelOptions","markerColor","font","markers","active","groupAxes","xAxes","yAxes","paneIx","paneAxes","axisIx","vertical","x","y","any","concat","groupSeriesByPane","seriesByPane","seriesPaneName","filterVisibleSeries","result","reflow","targetBox","margin","clone","unpad","reflowPanes","detachLabels","reflowAxes","reflowCharts","redraw","panesArray","root","getRoot","cleanGradients","empty","refresh","axisCrossingValues","crossingAxes","crossingValues","axisCrossingValue","valuesToAdd","defaultValue","alignAxisTo","targetAxis","crossingValue","targetCrossingValue","slot","getSlot","slotEdge","reverse","targetSlot","targetEdge","axisBox","translate","y1","alignAxes","xAnchor","yAnchor","xAnchorCrossings","yAnchorCrossings","leftAnchors","rightAnchors","topAnchors","bottomAnchors","paneId","id","anchor","paneAnchor","anchorCrossings","_overlap","lineBox","x1","alignTo","x2","_mirrored","mirror","y2","shrinkAxisWidth","axisGroupBox","overflowX","width","contentBox","currentAxis","shrink","shrinkAxisHeight","shrinked","overflowY","height","fitAxes","offsetX","paneBox","offsetY","reflowPaneAxes","autoRotateAxisLabels","groupedAxes","allPaneAxes","rotated","autoRotateLabels","chartPane","remainingHeight","remainingPanes","autoHeightPanes","top","indexOf","percents","parseInt","move","backgroundBox","axesCount","axisA","axisB","wrap","chartsBoxes","boxes","chartsBox","addBackgroundPaths","multipath","paths","Path","fromRect","toRect","backgroundContainsPoint","createVisual","opacity","background","border","isTransparent","bg","_bgVisual","MultiPath","fill","stroke","dashType","zIndex","appendVisual","pointsByCategoryIndex","categoryIndex","points","categoryPoints","value","pointsBySeriesIndex","seriesIndex","filterPoints","pointsBySeriesName","callback","findPoint","paneByPoint","detachAxisGroupLabels","labelAxisCount","axisIndex","labelAxis","createLabelAxis","pos","appendAxisAt","labelOptions","position","onAxis","allAxes","end","range","edge","min","clear","undefined","line","notes","plotBands","isTrendline","type","trendlineFactory","createTrendlineSeries","modifiedSeries","map","forSeries","seriesByName","for","Error","valueFields","field","trendlineSeries","Object","assign","filter","find","isSingleAxis","some","a","reduce","acc"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/plotarea/plotarea-base.js"],"sourcesContent":["import { drawing as draw } from '@progress/kendo-drawing';\n\nimport { ChartElement, Box } from '../../core';\nimport Crosshair from '../crosshair/crosshair';\nimport Pane from '../pane';\nimport { hasValue } from '../utils';\nimport SeriesBinder from '../series-binder';\n\nimport { WHITE, BLACK, X, Y, COORD_PRECISION, TOP, BOTTOM, LEFT, RIGHT, START, END, INHERIT } from '../../common/constants';\nimport { append, deepExtend, defined, getSpacing, getTemplate, inArray, isFunction, isString, limitValue, round, setDefaultOptions, last } from '../../common';\nimport { TRENDLINE_SERIES } from '../constants';\n\nclass PlotAreaBase extends ChartElement {\n    constructor(series, options, chartService) {\n        super(options);\n\n        this.initFields(series, options);\n        this.series = series;\n        this.initSeries();\n        this.charts = [];\n        this.options.legend = this.options.legend || {};\n        this.options.legend.items = [];\n        this.axes = [];\n        this.crosshairs = [];\n        this.chartService = chartService;\n        this.originalOptions = options;\n        this.originalSeries = series;\n        this._bindCache = new WeakMap();\n\n        this.createPanes();\n        this.render();\n        this.createCrosshairs();\n    }\n\n    initFields() { }\n\n    initSeries() {\n        const series = this.series;\n\n        for (let i = 0; i < series.length; i++) {\n            series[i].index = i;\n        }\n    }\n\n    bindPoint(series, pointIx, item) {\n        let cached = this._bindCache.get(series);\n        if (!cached) {\n            cached = [];\n            this._bindCache.set(series, cached);\n        }\n\n        let data = cached[pointIx];\n        if (!data) {\n            data = cached[pointIx] = SeriesBinder.current.bindPoint(series, pointIx, item);\n        }\n\n        return data;\n    }\n\n    createPanes() {\n        const titleOptions = this.options.title || {};\n        const paneDefaults = this.options.paneDefaults;\n        const paneOptions = this.options.panes || [];\n        const panesLength = Math.max(paneOptions.length, 1);\n        const panes = [];\n\n        const defaults = deepExtend({\n            title: {\n                color: titleOptions.color\n            }\n        }, paneDefaults);\n\n        for (let i = 0; i < panesLength; i++) {\n            const options = deepExtend({}, defaults, paneOptions[i]);\n            if (isString(options.title)) {\n                options.title = deepExtend({ text: options.title }, defaults.title);\n            }\n\n            const currentPane = new Pane(options);\n            currentPane.paneIndex = i;\n\n            panes.push(currentPane);\n            this.append(currentPane);\n        }\n\n        this.panes = panes;\n    }\n\n    crosshairOptions(axis) {\n        return axis.options.crosshair;\n    }\n\n    createCrosshairs(panes = this.panes) {\n        for (let i = 0; i < panes.length; i++) {\n            const pane = panes[i];\n            for (let j = 0; j < pane.axes.length; j++) {\n                const axis = pane.axes[j];\n                const options = this.crosshairOptions(axis);\n                if (options && options.visible) {\n                    const currentCrosshair = new Crosshair(this.chartService, axis, options);\n\n                    this.crosshairs.push(currentCrosshair);\n                    pane.content.append(currentCrosshair);\n                }\n            }\n        }\n    }\n\n    removeCrosshairs(pane) {\n        const crosshairs = this.crosshairs;\n        const axes = pane.axes;\n\n        for (let i = crosshairs.length - 1; i >= 0; i--) {\n            for (let j = 0; j < axes.length; j++) {\n                if (crosshairs[i].axis === axes[j]) {\n                    crosshairs.splice(i, 1);\n                    break;\n                }\n            }\n        }\n    }\n\n    hideCrosshairs() {\n        const crosshairs = this.crosshairs;\n        for (let idx = 0; idx < crosshairs.length; idx++) {\n            crosshairs[idx].hide();\n        }\n    }\n\n    findPane(name) {\n        const panes = this.panes;\n        let matchingPane;\n\n        for (let i = 0; i < panes.length; i++) {\n            if (panes[i].options.name === name) {\n                matchingPane = panes[i];\n                break;\n            }\n        }\n\n        return matchingPane || panes[0];\n    }\n\n    findPointPane(point) {\n        const panes = this.panes;\n        let matchingPane;\n\n        for (let i = 0; i < panes.length; i++) {\n            if (panes[i].box.containsPoint(point)) {\n                matchingPane = panes[i];\n                break;\n            }\n        }\n\n        return matchingPane;\n    }\n\n    appendAxis(axis) {\n        const pane = this.findPane(axis.options.pane);\n\n        pane.appendAxis(axis);\n        this.axes.push(axis);\n        axis.plotArea = this;\n    }\n\n    removeAxis(axisToRemove) {\n        const filteredAxes = [];\n\n        for (let i = 0; i < this.axes.length; i++) {\n            const axis = this.axes[i];\n            if (axisToRemove !== axis) {\n                filteredAxes.push(axis);\n            } else {\n                axis.destroy();\n            }\n        }\n\n        this.axes = filteredAxes;\n    }\n\n    appendChart(chart, pane) {\n        this.charts.push(chart);\n        if (pane) {\n            pane.appendChart(chart);\n        } else {\n            this.append(chart);\n        }\n    }\n\n    removeChart(chartToRemove) {\n        const filteredCharts = [];\n\n        for (let i = 0; i < this.charts.length; i++) {\n            const chart = this.charts[i];\n            if (chart !== chartToRemove) {\n                filteredCharts.push(chart);\n            } else {\n                chart.destroy();\n            }\n        }\n\n        this.charts = filteredCharts;\n    }\n\n    addToLegend(series) {\n        const count = series.length;\n        const legend = this.options.legend;\n        const labels = legend.labels || {};\n        const inactiveItems = legend.inactiveItems || {};\n        const inactiveItemsLabels = inactiveItems.labels || {};\n        const data = [];\n\n        for (let i = 0; i < count; i++) {\n            const currentSeries = series[i];\n            const seriesVisible = currentSeries.visible !== false;\n            if (currentSeries.visibleInLegend === false) {\n                continue;\n            }\n\n            let text = currentSeries.name;\n            const labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);\n            if (labelTemplate) {\n                text = labelTemplate({\n                    text: hasValue(text) ? text : \"\",\n                    series: currentSeries\n                });\n            }\n\n            const defaults = currentSeries._defaults;\n            let color = currentSeries.color;\n            if (isFunction(color) && defaults) {\n                color = defaults.color;\n            }\n\n            let itemLabelOptions, markerColor;\n            if (seriesVisible) {\n                itemLabelOptions = {};\n                markerColor = color;\n            } else {\n                itemLabelOptions = {\n                    color: inactiveItemsLabels.color,\n                    font: inactiveItemsLabels.font\n                };\n                markerColor = inactiveItems.markers.color;\n            }\n\n            if (hasValue(text) && text !== \"\") {\n                data.push({\n                    text: text,\n                    labels: itemLabelOptions,\n                    markerColor: markerColor,\n                    series: currentSeries,\n                    active: seriesVisible\n                });\n            }\n        }\n\n        append(legend.items, data);\n    }\n\n    groupAxes(panes) {\n        const xAxes = [];\n        const yAxes = [];\n\n        for (let paneIx = 0; paneIx < panes.length; paneIx++) {\n            const paneAxes = panes[paneIx].axes;\n            for (let axisIx = 0; axisIx < paneAxes.length; axisIx++) {\n                const axis = paneAxes[axisIx];\n                if (axis.options.vertical) {\n                    yAxes.push(axis);\n                } else {\n                    xAxes.push(axis);\n                }\n            }\n        }\n\n        return { x: xAxes, y: yAxes, any: xAxes.concat(yAxes) };\n    }\n\n    groupSeriesByPane() {\n        const series = this.series;\n        const seriesByPane = {};\n\n        for (let i = 0; i < series.length; i++) {\n            const currentSeries = series[i];\n            const pane = this.seriesPaneName(currentSeries);\n\n            if (seriesByPane[pane]) {\n                seriesByPane[pane].push(currentSeries);\n            } else {\n                seriesByPane[pane] = [ currentSeries ];\n            }\n        }\n\n        return seriesByPane;\n    }\n\n    filterVisibleSeries(series) {\n        const result = [];\n\n        for (let i = 0; i < series.length; i++) {\n            const currentSeries = series[i];\n            if (currentSeries.visible !== false) {\n                result.push(currentSeries);\n            }\n        }\n\n        return result;\n    }\n\n    reflow(targetBox) {\n        const options = this.options.plotArea;\n        const panes = this.panes;\n        const margin = getSpacing(options.margin);\n\n        this.box = targetBox.clone().unpad(margin);\n        this.reflowPanes();\n\n        this.detachLabels();\n        this.reflowAxes(panes);\n        this.reflowCharts(panes);\n    }\n\n    redraw(panes) {\n        const panesArray = [].concat(panes);\n        this.initSeries();\n\n        //prevents leak during partial redraws. the cached gradients observers retain reference to the destroyed elements.\n        const root = this.getRoot();\n        if (root) {\n            root.cleanGradients();\n        }\n\n        for (let i = 0; i < panesArray.length; i++) {\n            this.removeCrosshairs(panesArray[i]);\n            panesArray[i].empty();\n        }\n\n        this._bindCache = new WeakMap();\n\n        this.render(panesArray);\n        this.detachLabels();\n        this.reflowAxes(this.panes);\n        this.reflowCharts(panesArray);\n\n        this.createCrosshairs(panesArray);\n\n        for (let i = 0; i < panesArray.length; i++) {\n            panesArray[i].refresh();\n        }\n    }\n\n    axisCrossingValues(axis, crossingAxes) {\n        const options = axis.options;\n        const crossingValues = [].concat(\n            options.axisCrossingValues || options.axisCrossingValue\n        );\n        const valuesToAdd = crossingAxes.length - crossingValues.length;\n        const defaultValue = crossingValues[0] || 0;\n\n        for (let i = 0; i < valuesToAdd; i++) {\n            crossingValues.push(defaultValue);\n        }\n\n        return crossingValues;\n    }\n\n    alignAxisTo(axis, targetAxis, crossingValue, targetCrossingValue) {\n        const slot = axis.getSlot(crossingValue, crossingValue, true);\n        const slotEdge = axis.options.reverse ? 2 : 1;\n        const targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);\n        const targetEdge = targetAxis.options.reverse ? 2 : 1;\n        const axisBox = axis.box.translate(\n            targetSlot[X + targetEdge] - slot[X + slotEdge],\n            targetSlot[Y + targetEdge] - slot[Y + slotEdge]\n        );\n\n        if (axis.pane !== targetAxis.pane) {\n            axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);\n        }\n\n        axis.reflow(axisBox);\n    }\n\n    alignAxes(xAxes, yAxes) {\n        const xAnchor = xAxes[0];\n        const yAnchor = yAxes[0];\n        const xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);\n        const yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);\n        const leftAnchors = {};\n        const rightAnchors = {};\n        const topAnchors = {};\n        const bottomAnchors = {};\n\n        for (let i = 0; i < yAxes.length; i++) {\n            const axis = yAxes[i];\n            const pane = axis.pane;\n            const paneId = pane.id;\n            const visible = axis.options.visible !== false;\n\n            // Locate pane anchor, if any, and use its axisCrossingValues\n            const anchor = paneAnchor(xAxes, pane) || xAnchor;\n            let anchorCrossings = xAnchorCrossings;\n\n            if (anchor !== xAnchor) {\n                anchorCrossings = this.axisCrossingValues(anchor, yAxes);\n            }\n\n            this.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\n\n            if (axis.options._overlap) {\n                continue;\n            }\n\n            if (round(axis.lineBox().x1) === round(anchor.lineBox().x1)) {\n                // Push the axis to the left the previous y-axis so they don't overlap\n                if (leftAnchors[paneId]) {\n                    axis.reflow(axis.box\n                        .alignTo(leftAnchors[paneId].box, LEFT)\n                        .translate(-axis.options.margin, 0)\n                    );\n                }\n\n                if (visible) {\n                    leftAnchors[paneId] = axis;\n                }\n            }\n\n            if (round(axis.lineBox().x2) === round(anchor.lineBox().x2)) {\n                // Flip the labels on the right if we're at the right end of the pane\n                if (!axis._mirrored) {\n                    axis.options.labels.mirror = !axis.options.labels.mirror;\n                    axis._mirrored = true;\n                }\n\n                this.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);\n\n                // Push the axis to the right the previous y-axis so they don't overlap\n                if (rightAnchors[paneId]) {\n                    axis.reflow(axis.box\n                        .alignTo(rightAnchors[paneId].box, RIGHT)\n                        .translate(axis.options.margin, 0)\n                    );\n                }\n\n                if (visible) {\n                    rightAnchors[paneId] = axis;\n                }\n            }\n\n            if (i !== 0 && yAnchor.pane === axis.pane) {\n                axis.alignTo(yAnchor);\n                axis.reflow(axis.box);\n            }\n        }\n\n        for (let i = 0; i < xAxes.length; i++) {\n            const axis = xAxes[i];\n            const pane = axis.pane;\n            const paneId = pane.id;\n            const visible = axis.options.visible !== false;\n\n            // Locate pane anchor and use its axisCrossingValues\n            const anchor = paneAnchor(yAxes, pane) || yAnchor;\n            let anchorCrossings = yAnchorCrossings;\n            if (anchor !== yAnchor) {\n                anchorCrossings = this.axisCrossingValues(anchor, xAxes);\n            }\n\n            this.alignAxisTo(axis, anchor, xAnchorCrossings[i], anchorCrossings[i]);\n\n            if (axis.options._overlap) {\n                continue;\n            }\n\n            if (round(axis.lineBox().y1) === round(anchor.lineBox().y1)) {\n                // Flip the labels on top if we're at the top of the pane\n                if (!axis._mirrored) {\n                    axis.options.labels.mirror = !axis.options.labels.mirror;\n                    axis._mirrored = true;\n                }\n                this.alignAxisTo(axis, anchor, xAnchorCrossings[i], anchorCrossings[i]);\n\n                // Push the axis above the previous x-axis so they don't overlap\n                if (topAnchors[paneId]) {\n                    axis.reflow(axis.box\n                        .alignTo(topAnchors[paneId].box, TOP)\n                        .translate(0, -axis.options.margin)\n                    );\n                }\n\n                if (visible) {\n                    topAnchors[paneId] = axis;\n                }\n            }\n\n            if (round(axis.lineBox().y2, COORD_PRECISION) === round(anchor.lineBox().y2, COORD_PRECISION)) {\n                // Push the axis below the previous x-axis so they don't overlap\n                if (bottomAnchors[paneId]) {\n                    axis.reflow(axis.box\n                        .alignTo(bottomAnchors[paneId].box, BOTTOM)\n                        .translate(0, axis.options.margin)\n                    );\n                }\n\n                if (visible) {\n                    bottomAnchors[paneId] = axis;\n                }\n            }\n\n            if (i !== 0) {\n                axis.alignTo(xAnchor);\n                axis.reflow(axis.box);\n            }\n        }\n    }\n\n    shrinkAxisWidth(panes) {\n        const axes = this.groupAxes(panes).any;\n        const axisBox = axisGroupBox(axes);\n        let overflowX = 0;\n\n        for (let i = 0; i < panes.length; i++) {\n            const currentPane = panes[i];\n\n            if (currentPane.axes.length > 0) {\n                overflowX = Math.max(\n                    overflowX,\n                    axisBox.width() - currentPane.contentBox.width()\n                );\n            }\n        }\n\n        if (overflowX !== 0) {\n            for (let i = 0; i < axes.length; i++) {\n                const currentAxis = axes[i];\n\n                if (!currentAxis.options.vertical) {\n                    currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));\n                }\n            }\n        }\n    }\n\n    shrinkAxisHeight(panes) {\n        let shrinked;\n\n        for (let i = 0; i < panes.length; i++) {\n            const currentPane = panes[i];\n            const axes = currentPane.axes;\n            const overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());\n\n            if (overflowY !== 0) {\n                for (let j = 0; j < axes.length; j++) {\n                    const currentAxis = axes[j];\n\n                    if (currentAxis.options.vertical) {\n                        currentAxis.reflow(\n                            currentAxis.box.shrink(0, overflowY)\n                        );\n                    }\n                }\n                shrinked = true;\n            }\n        }\n\n        return shrinked;\n    }\n\n    fitAxes(panes) {\n        const axes = this.groupAxes(panes).any;\n        let offsetX = 0;\n\n        for (let i = 0; i < panes.length; i++) {\n            const currentPane = panes[i];\n            const paneAxes = currentPane.axes;\n            const paneBox = currentPane.contentBox;\n\n            if (paneAxes.length > 0) {\n                const axisBox = axisGroupBox(paneAxes);\n                // OffsetY is calculated and applied per pane\n                const offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);\n\n                // OffsetX is calculated and applied globally\n                offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);\n\n\n                for (let j = 0; j < paneAxes.length; j++) {\n                    const currentAxis = paneAxes[j];\n\n                    currentAxis.reflow(\n                        currentAxis.box.translate(0, offsetY)\n                    );\n                }\n            }\n        }\n\n        for (let i = 0; i < axes.length; i++) {\n            const currentAxis = axes[i];\n\n            currentAxis.reflow(\n                currentAxis.box.translate(offsetX, 0)\n            );\n        }\n    }\n\n    reflowAxes(panes) {\n        const axes = this.groupAxes(panes);\n\n        for (let i = 0; i < panes.length; i++) {\n            this.reflowPaneAxes(panes[i]);\n        }\n\n        if (axes.x.length > 0 && axes.y.length > 0) {\n            this.alignAxes(axes.x, axes.y);\n            this.shrinkAxisWidth(panes);\n\n            this.autoRotateAxisLabels(axes);\n\n            this.alignAxes(axes.x, axes.y);\n            if (this.shrinkAxisWidth(panes)) {\n                this.alignAxes(axes.x, axes.y);\n            }\n\n            this.shrinkAxisHeight(panes);\n            this.alignAxes(axes.x, axes.y);\n\n            if (this.shrinkAxisHeight(panes)) {\n                this.alignAxes(axes.x, axes.y);\n            }\n\n            this.fitAxes(panes);\n        }\n    }\n\n    autoRotateAxisLabels(groupedAxes) {\n        const { panes } = this;\n        const axes = allPaneAxes(panes);\n        let rotated;\n\n        for (let idx = 0; idx < axes.length; idx++) {\n            const axis = axes[idx];\n            if (axis.autoRotateLabels()) {\n                rotated = true;\n            }\n        }\n\n        if (rotated) {\n            for (let idx = 0; idx < panes.length; idx++) {\n                this.reflowPaneAxes(panes[idx]);\n            }\n\n            if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {\n                this.alignAxes(groupedAxes.x, groupedAxes.y);\n                this.shrinkAxisWidth(panes);\n            }\n        }\n    }\n\n    reflowPaneAxes(pane) {\n        const axes = pane.axes;\n        const length = axes.length;\n\n        if (length > 0) {\n            for (let i = 0; i < length; i++) {\n                axes[i].reflow(pane.contentBox);\n            }\n        }\n    }\n\n    reflowCharts(panes) {\n        const charts = this.charts;\n        const count = charts.length;\n        const box = this.box;\n\n        for (let i = 0; i < count; i++) {\n            const chartPane = charts[i].pane;\n            if (!chartPane || inArray(chartPane, panes)) {\n                charts[i].reflow(box);\n            }\n        }\n    }\n\n    reflowPanes() {\n        const { box, panes } = this;\n        const panesLength = panes.length;\n        let remainingHeight = box.height();\n        let remainingPanes = panesLength;\n        let autoHeightPanes = 0;\n        let top = box.y1;\n\n        for (let i = 0; i < panesLength; i++) {\n            const currentPane = panes[i];\n            const height = currentPane.options.height;\n\n            currentPane.options.width = box.width();\n\n            if (!currentPane.options.height) {\n                autoHeightPanes++;\n            } else {\n                if (height.indexOf && height.indexOf(\"%\")) {\n                    const percents = parseInt(height, 10) / 100;\n                    currentPane.options.height = percents * box.height();\n                }\n\n                currentPane.reflow(box.clone());\n\n                remainingHeight -= currentPane.options.height;\n            }\n        }\n\n        for (let i = 0; i < panesLength; i++) {\n            const currentPane = panes[i];\n\n            if (!currentPane.options.height) {\n                currentPane.options.height = remainingHeight / autoHeightPanes;\n            }\n        }\n\n        for (let i = 0; i < panesLength; i++) {\n            const currentPane = panes[i];\n            const paneBox = box\n                .clone()\n                .move(box.x1, top);\n\n            currentPane.reflow(paneBox);\n\n            remainingPanes--;\n            top += currentPane.options.height;\n        }\n    }\n\n    backgroundBox() {\n        const axes = this.axes;\n        const axesCount = axes.length;\n        let box;\n\n        for (let i = 0; i < axesCount; i++) {\n            const axisA = axes[i];\n\n            for (let j = 0; j < axesCount; j++) {\n                const axisB = axes[j];\n\n                if (axisA.options.vertical !== axisB.options.vertical) {\n                    const lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());\n\n                    if (!box) {\n                        box = lineBox;\n                    } else {\n                        box = box.wrap(lineBox);\n                    }\n                }\n            }\n        }\n\n        return box || this.box;\n    }\n\n    chartsBoxes() {\n        const panes = this.panes;\n        const boxes = [];\n\n        for (let idx = 0; idx < panes.length; idx++) {\n            boxes.push(panes[idx].chartsBox());\n        }\n\n        return boxes;\n    }\n\n    addBackgroundPaths(multipath) {\n        const boxes = this.chartsBoxes();\n        for (let idx = 0; idx < boxes.length; idx++) {\n            multipath.paths.push(draw.Path.fromRect(boxes[idx].toRect()));\n        }\n    }\n\n    backgroundContainsPoint(point) {\n        const boxes = this.chartsBoxes();\n        for (let idx = 0; idx < boxes.length; idx++) {\n            if (boxes[idx].containsPoint(point)) {\n                return true;\n            }\n        }\n    }\n\n    createVisual() {\n        super.createVisual();\n\n        const options = this.options.plotArea;\n        let { opacity, background, border = {} } = options;\n        if (isTransparent(background)) {\n            background = WHITE;\n            opacity = 0;\n        }\n\n        const bg = this._bgVisual = new draw.MultiPath({\n            fill: {\n                color: background,\n                opacity: opacity\n            },\n            stroke: {\n                color: border.width ? border.color : \"\",\n                width: border.width,\n                dashType: border.dashType\n            },\n            zIndex: -1\n        });\n\n        this.addBackgroundPaths(bg);\n\n        this.appendVisual(bg);\n    }\n\n    pointsByCategoryIndex(categoryIndex) {\n        const charts = this.charts;\n        const result = [];\n\n        if (categoryIndex !== null) {\n            for (let i = 0; i < charts.length; i++) {\n                const chart = charts[i];\n                if (chart.pane.options.name === \"_navigator\") {\n                    continue;\n                }\n\n                const points = charts[i].categoryPoints[categoryIndex];\n                if (points && points.length) {\n                    for (let j = 0; j < points.length; j++) {\n                        const point = points[j];\n                        if (point && defined(point.value) && point.value !== null) {\n                            result.push(point);\n                        }\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    pointsBySeriesIndex(seriesIndex) {\n        return this.filterPoints(function(point) {\n            return point.series.index === seriesIndex;\n        });\n    }\n\n    pointsBySeriesName(name) {\n        return this.filterPoints(function(point) {\n            return point.series.name === name;\n        });\n    }\n\n    filterPoints(callback) {\n        const charts = this.charts;\n        const result = [];\n\n        for (let i = 0; i < charts.length; i++) {\n            const chart = charts[i];\n            const points = chart.points;\n            for (let j = 0; j < points.length; j++) {\n                const point = points[j];\n                if (point && point.visible !== false && callback(point)) {\n                    result.push(point);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    findPoint(callback) {\n        const charts = this.charts;\n\n        for (let i = 0; i < charts.length; i++) {\n            const chart = charts[i];\n            const points = chart.points;\n            for (let j = 0; j < points.length; j++) {\n                const point = points[j];\n                if (point && point.visible !== false && callback(point)) {\n                    return point;\n                }\n            }\n        }\n    }\n\n    paneByPoint(point) {\n        const panes = this.panes;\n\n        for (let i = 0; i < panes.length; i++) {\n            const pane = panes[i];\n            if (pane.box.containsPoint(point)) {\n                return pane;\n            }\n        }\n    }\n\n    detachLabels() {\n        const axes = this.groupAxes(this.panes);\n        const xAxes = axes.x;\n        const yAxes = axes.y;\n\n        this.detachAxisGroupLabels(yAxes, xAxes);\n        this.detachAxisGroupLabels(xAxes, yAxes);\n    }\n\n    detachAxisGroupLabels(axes, crossingAxes) {\n        let labelAxisCount = 0;\n\n        for (let i = 0; i < axes.length; i++) {\n            const axis = axes[i];\n            const pane = axis.pane;\n            const anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];\n            const axisIndex = i + labelAxisCount;\n            const labelAxis = this.createLabelAxis(axis, axisIndex, anchor);\n\n            if (labelAxis) {\n                labelAxisCount++;\n\n                const pos = pane.axes.indexOf(axis) + labelAxisCount;\n                pane.appendAxisAt(labelAxis, pos);\n            }\n        }\n    }\n\n    createLabelAxis(axis, axisIndex, anchor) {\n        const labelOptions = axis.options.labels;\n        const position = labelOptions.position;\n        const onAxis = position !== END && position !== START;\n        const visible = labelOptions.visible;\n\n        if (onAxis || visible === false) {\n            return null;\n        }\n\n        const allAxes = this.groupAxes(this.panes);\n        const crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;\n        const anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);\n        const end = position === END;\n        const range = anchor.range();\n        const edge = end ? range.max : range.min;\n        const crossingValue = limitValue(anchorCrossings[axisIndex], range.min, range.max);\n\n        if (crossingValue - edge === 0) {\n            return null;\n        }\n\n        anchorCrossings.splice(axisIndex + 1, 0, edge);\n        anchor.options.axisCrossingValues = anchorCrossings;\n\n        const labelAxis = axis.clone();\n        axis.clear();\n\n        labelAxis.options.name = undefined;\n        labelAxis.options.line.visible = false;\n\n        labelAxis.options.crosshair = undefined;\n        labelAxis.options.notes = undefined;\n        labelAxis.options.plotBands = undefined;\n\n        return labelAxis;\n    }\n\n    isTrendline(series) {\n        return series && inArray(series.type, TRENDLINE_SERIES);\n    }\n\n    trendlineFactory() { /* abstract */ }\n\n    createTrendlineSeries() {\n        const modifiedSeries = [];\n\n        this.series = this.series.map(series => {\n            if (!this.isTrendline(series)) {\n                return series;\n            }\n\n            const forSeries = this.seriesByName(series.for);\n            if (!forSeries) {\n                throw new Error('Invalid Configuration: Unable to locate linked series ' +\n                    `\"${series.for}\" for trendline \"${series.name}\".`);\n            }\n\n            const valueFields = SeriesBinder.current.valueFields(forSeries);\n            const field = last(valueFields); // Use the last field for multi-field series\n\n            const trendlineSeries = this.trendlineFactory(Object.assign({}, {field}, series), forSeries);\n            if (trendlineSeries) {\n                if (forSeries.visible === false) {\n                    trendlineSeries.visible = false;\n                }\n\n                if (trendlineSeries.color === INHERIT) {\n                    trendlineSeries.color = forSeries.color;\n                }\n\n                modifiedSeries.push(trendlineSeries);\n            }\n\n            return trendlineSeries;\n        }).filter(series => series !== null);\n\n        return modifiedSeries;\n    }\n\n    seriesByName(name) {\n        return this.series.find(series => series.name === name);\n    }\n}\n\nfunction isSingleAxis(axis) {\n    return !axis.pane.axes.some((a) =>\n        a.options.vertical === axis.options.vertical && a !== axis && a.options.visible !== false\n    );\n}\n\nfunction axisGroupBox(axes) {\n    const length = axes.length;\n    let box;\n\n    for (let i = 0; i < length; i++) {\n        const axis = axes[i];\n        const visible = axis.options.visible !== false;\n        if (visible || isSingleAxis(axis)) {\n            const axisBox = visible ? axis.contentBox() : axis.lineBox();\n\n            if (!box) {\n                box = axisBox.clone();\n            } else {\n                box.wrap(axisBox);\n            }\n        }\n    }\n\n    return box || new Box();\n}\n\nfunction paneAnchor(axes, pane) {\n    for (let i = 0; i < axes.length; i++) {\n        const anchor = axes[i];\n        if (anchor && anchor.pane === pane) {\n            return anchor;\n        }\n    }\n}\n\nfunction isTransparent(color) {\n    return color === \"\" || color === null || color === \"none\" || color === \"transparent\" || !defined(color);\n}\n\nconst allPaneAxes = (panes) => panes.reduce((acc, pane) => acc.concat(pane.axes), []);\n\nsetDefaultOptions(PlotAreaBase, {\n    series: [],\n    plotArea: {\n        margin: {}\n    },\n    background: \"\",\n    border: {\n        color: BLACK,\n        width: 0\n    },\n    paneDefaults: {\n        title: {}\n    },\n    legend: {\n        inactiveItems: {\n            labels: {\n                color: \"#919191\"\n            },\n            markers: {\n                color: \"#919191\"\n            }\n        }\n    }\n});\n\nexport default PlotAreaBase;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}