{"ast":null,"code":"import BaseTooltip from '../tooltip/base-tooltip';\nimport { HIDE_TOOLTIP } from '../constants';\nimport { TOP, BOTTOM, LEFT, RIGHT, CENTER, DATE } from '../../common/constants';\nimport { setDefaultOptions } from '../../common';\nclass CrosshairTooltip extends BaseTooltip {\n  constructor(chartService, crosshair, options) {\n    super(chartService, options);\n    this.crosshair = crosshair;\n    this.formatService = chartService.format;\n    this.initAxisName();\n  }\n  initAxisName() {\n    const axis = this.crosshair.axis;\n    const plotArea = axis.plotArea;\n    let name;\n    if (plotArea.categoryAxis) {\n      name = axis.getCategory ? \"categoryAxis\" : \"valueAxis\";\n    } else {\n      name = axis.options.vertical ? \"yAxis\" : \"xAxis\";\n    }\n    this.axisName = name;\n  }\n  showAt(point) {\n    const {\n      crosshair: {\n        axis\n      },\n      options\n    } = this;\n    let value = axis[options.stickyMode ? \"getCategory\" : \"getValue\"](point);\n    let formattedValue = value;\n    if (options.format) {\n      formattedValue = this.formatService.auto(options.format, value);\n    } else if (axis.options.type === DATE) {\n      formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value);\n    }\n    this.show({\n      point: point,\n      anchor: this.getAnchor(),\n      crosshair: this.crosshair,\n      value: formattedValue,\n      axisName: this.axisName,\n      axisIndex: this.crosshair.axis.axisIndex\n    }, this.options);\n  }\n  hide() {\n    this.chartService.notify(HIDE_TOOLTIP, {\n      crosshair: this.crosshair,\n      axisName: this.axisName,\n      axisIndex: this.crosshair.axis.axisIndex\n    });\n  }\n  getAnchor() {\n    const {\n      crosshair,\n      options: {\n        position,\n        padding\n      }\n    } = this;\n    const vertical = !crosshair.axis.options.vertical;\n    const lineBox = crosshair.line.bbox();\n    let horizontalAlign, verticalAlign, point;\n    if (vertical) {\n      horizontalAlign = CENTER;\n      if (position === BOTTOM) {\n        verticalAlign = TOP;\n        point = lineBox.bottomLeft().translate(0, padding);\n      } else {\n        verticalAlign = BOTTOM;\n        point = lineBox.topLeft().translate(0, -padding);\n      }\n    } else {\n      verticalAlign = CENTER;\n      if (position === LEFT) {\n        horizontalAlign = RIGHT;\n        point = lineBox.topLeft().translate(-padding, 0);\n      } else {\n        horizontalAlign = LEFT;\n        point = lineBox.topRight().translate(padding, 0);\n      }\n    }\n    return {\n      point: point,\n      align: {\n        horizontal: horizontalAlign,\n        vertical: verticalAlign\n      }\n    };\n  }\n}\nsetDefaultOptions(CrosshairTooltip, {\n  padding: 10\n});\nexport default CrosshairTooltip;","map":{"version":3,"names":["BaseTooltip","HIDE_TOOLTIP","TOP","BOTTOM","LEFT","RIGHT","CENTER","DATE","setDefaultOptions","CrosshairTooltip","constructor","chartService","crosshair","options","formatService","format","initAxisName","axis","plotArea","name","categoryAxis","getCategory","vertical","axisName","showAt","point","value","stickyMode","formattedValue","auto","type","labels","dateFormats","baseUnit","show","anchor","getAnchor","axisIndex","hide","notify","position","padding","lineBox","line","bbox","horizontalAlign","verticalAlign","bottomLeft","translate","topLeft","topRight","align","horizontal"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/crosshair/crosshair-tooltip.js"],"sourcesContent":["import BaseTooltip from '../tooltip/base-tooltip';\n\nimport { HIDE_TOOLTIP } from '../constants';\nimport { TOP, BOTTOM, LEFT, RIGHT, CENTER, DATE } from '../../common/constants';\nimport { setDefaultOptions } from '../../common';\n\nclass CrosshairTooltip extends BaseTooltip {\n    constructor(chartService, crosshair, options) {\n        super(chartService, options);\n\n        this.crosshair = crosshair;\n        this.formatService = chartService.format;\n        this.initAxisName();\n    }\n\n    initAxisName() {\n        const axis = this.crosshair.axis;\n        const plotArea = axis.plotArea;\n        let name;\n        if (plotArea.categoryAxis) {\n            name = axis.getCategory ? \"categoryAxis\" : \"valueAxis\";\n        } else {\n            name = axis.options.vertical ? \"yAxis\" : \"xAxis\";\n        }\n        this.axisName = name;\n    }\n\n    showAt(point) {\n        const { crosshair: { axis }, options } = this;\n        let value = axis[options.stickyMode ? \"getCategory\" : \"getValue\"](point);\n        let formattedValue = value;\n\n        if (options.format) {\n            formattedValue = this.formatService.auto(options.format, value);\n        } else if (axis.options.type === DATE) {\n            formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value);\n        }\n\n        this.show({\n            point: point,\n            anchor: this.getAnchor(),\n            crosshair: this.crosshair,\n            value: formattedValue,\n            axisName: this.axisName,\n            axisIndex: this.crosshair.axis.axisIndex\n        }, this.options);\n    }\n\n    hide() {\n        this.chartService.notify(HIDE_TOOLTIP, {\n            crosshair: this.crosshair,\n            axisName: this.axisName,\n            axisIndex: this.crosshair.axis.axisIndex\n        });\n    }\n\n    getAnchor() {\n        const { crosshair, options: { position, padding } } = this;\n        const vertical = !crosshair.axis.options.vertical;\n        const lineBox = crosshair.line.bbox();\n        let horizontalAlign, verticalAlign, point;\n\n        if (vertical) {\n            horizontalAlign = CENTER;\n            if (position === BOTTOM) {\n                verticalAlign = TOP;\n                point = lineBox.bottomLeft().translate(0, padding);\n            } else {\n                verticalAlign = BOTTOM;\n                point = lineBox.topLeft().translate(0, -padding);\n            }\n        } else {\n            verticalAlign = CENTER;\n            if (position === LEFT) {\n                horizontalAlign = RIGHT;\n                point = lineBox.topLeft().translate(-padding, 0);\n            } else {\n                horizontalAlign = LEFT;\n                point = lineBox.topRight().translate(padding, 0);\n            }\n        }\n\n        return {\n            point: point,\n            align: {\n                horizontal: horizontalAlign,\n                vertical: verticalAlign\n            }\n        };\n    }\n}\n\nsetDefaultOptions(CrosshairTooltip, {\n    padding: 10\n});\n\nexport default CrosshairTooltip;\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}