{"ast":null,"code":"import HasObservers from '../core/has-observers';\nimport { deg, rad, round } from '../util';\nimport withAccessors from '../mixins/with-accessors';\nimport closeOrLess from './math/close-or-less';\nimport lineIntersection from './math/line-intersection';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\nimport { PRECISION } from './constants';\nimport Point from './point';\nimport Rect from './rect';\nimport transform from './transform';\nconst MAX_INTERVAL = 45;\nconst pow = Math.pow;\nconst accessors = [\"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\"];\nclass Arc extends withAccessors(HasObservers, accessors) {\n  constructor(center = new Point(), options = {}) {\n    super();\n    this.setCenter(center);\n    this.radiusX = options.radiusX;\n    this.radiusY = options.radiusY || options.radiusX;\n    this.startAngle = options.startAngle;\n    this.endAngle = options.endAngle;\n    this.anticlockwise = options.anticlockwise || false;\n    this.xRotation = options.xRotation;\n  }\n  clone() {\n    return new Arc(this.center, {\n      radiusX: this.radiusX,\n      radiusY: this.radiusY,\n      startAngle: this.startAngle,\n      endAngle: this.endAngle,\n      anticlockwise: this.anticlockwise\n    });\n  }\n  setCenter(value) {\n    this._observerField(\"center\", Point.create(value));\n    this.geometryChange();\n    return this;\n  }\n  getCenter() {\n    return this.center;\n  }\n  pointAt(angle) {\n    const center = this.center;\n    const radian = rad(angle);\n    return new Point(center.x + this.radiusX * Math.cos(radian), center.y + this.radiusY * Math.sin(radian));\n  }\n  curvePoints() {\n    const startAngle = this.startAngle;\n    const dir = this.anticlockwise ? -1 : 1;\n    const curvePoints = [this.pointAt(startAngle)];\n    const interval = this._arcInterval();\n    const intervalAngle = interval.endAngle - interval.startAngle;\n    const subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n    const subIntervalAngle = intervalAngle / subIntervalsCount;\n    let currentAngle = startAngle;\n    let transformation;\n    if (this.xRotation) {\n      transformation = transform().rotate(this.xRotation, this.center);\n    }\n    for (let i = 1; i <= subIntervalsCount; i++) {\n      const nextAngle = currentAngle + dir * subIntervalAngle;\n      const points = this._intervalCurvePoints(currentAngle, nextAngle, transformation);\n      curvePoints.push(points.cp1, points.cp2, points.p2);\n      currentAngle = nextAngle;\n    }\n    return curvePoints;\n  }\n  bbox(matrix) {\n    const interval = this._arcInterval();\n    const startAngle = interval.startAngle;\n    const endAngle = interval.endAngle;\n    const extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n    const extremeX = deg(extremeAngles.x);\n    const extremeY = deg(extremeAngles.y);\n    const endPoint = this.pointAt(endAngle).transformCopy(matrix);\n    let currentAngleX = bboxStartAngle(extremeX, startAngle);\n    let currentAngleY = bboxStartAngle(extremeY, startAngle);\n    let currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n    let minPoint = Point.min(currentPoint, endPoint);\n    let maxPoint = Point.max(currentPoint, endPoint);\n    while (currentAngleX < endAngle || currentAngleY < endAngle) {\n      let currentPointX;\n      if (currentAngleX < endAngle) {\n        currentPointX = this.pointAt(currentAngleX).transformCopy(matrix);\n        currentAngleX += 90;\n      }\n      let currentPointY;\n      if (currentAngleY < endAngle) {\n        currentPointY = this.pointAt(currentAngleY).transformCopy(matrix);\n        currentAngleY += 90;\n      }\n      currentPoint = new Point(currentPointX.x, currentPointY.y);\n      minPoint = Point.min(minPoint, currentPoint);\n      maxPoint = Point.max(maxPoint, currentPoint);\n    }\n    return Rect.fromPoints(minPoint, maxPoint);\n  }\n  _arcInterval() {\n    let {\n      startAngle,\n      endAngle,\n      anticlockwise\n    } = this;\n    if (anticlockwise) {\n      let oldStart = startAngle;\n      startAngle = endAngle;\n      endAngle = oldStart;\n    }\n    if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {\n      endAngle += 360;\n    }\n    return {\n      startAngle: startAngle,\n      endAngle: endAngle\n    };\n  }\n  _intervalCurvePoints(startAngle, endAngle, transformation) {\n    const p1 = this.pointAt(startAngle);\n    const p2 = this.pointAt(endAngle);\n    const p1Derivative = this._derivativeAt(startAngle);\n    const p2Derivative = this._derivativeAt(endAngle);\n    const t = (rad(endAngle) - rad(startAngle)) / 3;\n    const cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n    const cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n    if (transformation) {\n      p1.transform(transformation);\n      p2.transform(transformation);\n      cp1.transform(transformation);\n      cp2.transform(transformation);\n    }\n    return {\n      p1: p1,\n      cp1: cp1,\n      cp2: cp2,\n      p2: p2\n    };\n  }\n  _derivativeAt(angle) {\n    const radian = rad(angle);\n    return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n  }\n  containsPoint(point) {\n    const interval = this._arcInterval();\n    const intervalAngle = interval.endAngle - interval.startAngle;\n    const {\n      center,\n      radiusX,\n      radiusY\n    } = this;\n    const distance = center.distanceTo(point);\n    const angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n    const pointRadius = radiusX * radiusY / Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));\n    const startPoint = this.pointAt(this.startAngle).round(PRECISION);\n    const endPoint = this.pointAt(this.endAngle).round(PRECISION);\n    const intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n    let containsPoint;\n    if (intervalAngle < 180) {\n      containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n    } else {\n      let angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n      if (angle !== 360) {\n        angle = (360 + angle) % 360;\n      }\n      let inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n      containsPoint = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection || intersection.equals(point));\n    }\n    return containsPoint;\n  }\n  _isOnPath(point, width) {\n    const interval = this._arcInterval();\n    const center = this.center;\n    let angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n    if (angle !== 360) {\n      angle = (360 + angle) % 360;\n    }\n    const inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n    return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n  }\n  static fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {\n    // eslint-disable-line max-params\n    const arcParameters = normalizeArcParameters({\n      x1: start.x,\n      y1: start.y,\n      x2: end.x,\n      y2: end.y,\n      rx: rx,\n      ry: ry,\n      largeArc: largeArc,\n      swipe: swipe,\n      rotation: rotation\n    });\n    return new Arc(arcParameters.center, {\n      startAngle: arcParameters.startAngle,\n      endAngle: arcParameters.endAngle,\n      radiusX: arcParameters.radiusX,\n      radiusY: arcParameters.radiusY,\n      xRotation: arcParameters.xRotation,\n      anticlockwise: swipe === 0\n    });\n  }\n}\nfunction calculateAngle(cx, cy, rx, ry, x, y) {\n  const cos = round((x - cx) / rx, 3);\n  const sin = round((y - cy) / ry, 3);\n  return round(deg(Math.atan2(sin, cos)));\n}\nfunction normalizeArcParameters(parameters) {\n  let {\n    x1,\n    y1,\n    x2,\n    y2,\n    rx,\n    ry,\n    largeArc,\n    swipe,\n    rotation = 0\n  } = parameters;\n  const radians = rad(rotation);\n  const cosine = Math.cos(radians);\n  const sine = Math.sin(radians);\n  const xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n  const yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n  const sign = largeArc !== swipe ? 1 : -1;\n  const xt2 = Math.pow(xT, 2);\n  const yt2 = Math.pow(yT, 2);\n  let rx2 = Math.pow(rx, 2);\n  let ry2 = Math.pow(ry, 2);\n  let delta = xt2 / rx2 + yt2 / ry2;\n  if (delta > 1) {\n    delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n    rx = delta * rx;\n    rx2 = Math.pow(rx, 2);\n    ry = delta * ry;\n    ry2 = Math.pow(ry, 2);\n  }\n  let constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));\n  // due to rounding errors the value could become NaN even after radii correction\n  if (isNaN(constT)) {\n    constT = 0;\n  }\n  const cxT = constT * (rx * yT) / ry;\n  const cyT = -constT * (ry * xT) / rx;\n  const cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n  const cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n  const uX = (xT - cxT) / rx;\n  const uY = (yT - cyT) / ry;\n  const vX = -(xT + cxT) / rx;\n  const vY = -(yT + cyT) / ry;\n  const startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n  const angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n  let angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n  if (!swipe && angle > 0) {\n    angle -= 360;\n  }\n  if (swipe && angle < 0) {\n    angle += 360;\n  }\n  let endAngle = startAngle + angle;\n  const signEndAngle = endAngle >= 0 ? 1 : -1;\n  endAngle = Math.abs(endAngle) % 360 * signEndAngle;\n  return {\n    center: new Point(cx, cy),\n    startAngle: startAngle,\n    endAngle: endAngle,\n    radiusX: rx,\n    radiusY: ry,\n    xRotation: rotation\n  };\n}\nfunction bboxStartAngle(angle, start) {\n  let startAngle = angle;\n  while (startAngle < start) {\n    startAngle += 90;\n  }\n  return startAngle;\n}\nexport default Arc;","map":{"version":3,"names":["HasObservers","deg","rad","round","withAccessors","closeOrLess","lineIntersection","ellipseExtremeAngles","PRECISION","Point","Rect","transform","MAX_INTERVAL","pow","Math","accessors","Arc","constructor","center","options","setCenter","radiusX","radiusY","startAngle","endAngle","anticlockwise","xRotation","clone","value","_observerField","create","geometryChange","getCenter","pointAt","angle","radian","x","cos","y","sin","curvePoints","dir","interval","_arcInterval","intervalAngle","subIntervalsCount","ceil","subIntervalAngle","currentAngle","transformation","rotate","i","nextAngle","points","_intervalCurvePoints","push","cp1","cp2","p2","bbox","matrix","extremeAngles","extremeX","extremeY","endPoint","transformCopy","currentAngleX","bboxStartAngle","currentAngleY","currentPoint","minPoint","min","maxPoint","max","currentPointX","currentPointY","fromPoints","oldStart","p1","p1Derivative","_derivativeAt","p2Derivative","t","containsPoint","point","distance","distanceTo","angleRad","atan2","pointRadius","sqrt","startPoint","intersection","calculateAngle","inAngleRange","equals","_isOnPath","width","start","end","rx","ry","largeArc","swipe","rotation","arcParameters","normalizeArcParameters","x1","y1","x2","y2","cx","cy","parameters","radians","cosine","sine","xT","yT","sign","xt2","yt2","rx2","ry2","delta","constT","isNaN","cxT","cyT","uX","uY","vX","vY","acos","angleCosine","signEndAngle","abs"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-drawing/dist/es2015/geometry/arc.js"],"sourcesContent":["import HasObservers from '../core/has-observers';\nimport { deg, rad, round } from '../util';\nimport withAccessors from '../mixins/with-accessors';\n\nimport closeOrLess from './math/close-or-less';\nimport lineIntersection from './math/line-intersection';\nimport ellipseExtremeAngles from './math/ellipse-extreme-angles';\n\nimport { PRECISION } from './constants';\nimport Point from './point';\nimport Rect from './rect';\nimport transform from './transform';\n\n\nconst MAX_INTERVAL = 45;\nconst pow = Math.pow;\nconst accessors = [ \"radiusX\", \"radiusY\", \"startAngle\", \"endAngle\", \"anticlockwise\" ];\n\nclass Arc extends withAccessors(HasObservers, accessors) {\n    constructor(center = new Point(), options = {}) {\n        super();\n\n        this.setCenter(center);\n\n        this.radiusX = options.radiusX;\n        this.radiusY = options.radiusY || options.radiusX;\n        this.startAngle = options.startAngle;\n        this.endAngle = options.endAngle;\n        this.anticlockwise = options.anticlockwise || false;\n        this.xRotation = options.xRotation;\n    }\n\n    clone() {\n        return new Arc(this.center, {\n            radiusX: this.radiusX,\n            radiusY: this.radiusY,\n            startAngle: this.startAngle,\n            endAngle: this.endAngle,\n            anticlockwise: this.anticlockwise\n        });\n    }\n\n    setCenter(value) {\n        this._observerField(\"center\", Point.create(value));\n        this.geometryChange();\n        return this;\n    }\n\n    getCenter() {\n        return this.center;\n    }\n\n    pointAt(angle) {\n        const center = this.center;\n        const radian = rad(angle);\n\n        return new Point(\n            center.x + this.radiusX * Math.cos(radian),\n            center.y + this.radiusY * Math.sin(radian)\n        );\n    }\n\n    curvePoints() {\n        const startAngle = this.startAngle;\n        const dir = this.anticlockwise ? -1 : 1;\n        const curvePoints = [ this.pointAt(startAngle) ];\n        const interval = this._arcInterval();\n        const intervalAngle = interval.endAngle - interval.startAngle;\n        const subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);\n        const subIntervalAngle = intervalAngle / subIntervalsCount;\n        let currentAngle = startAngle;\n        let transformation;\n        if (this.xRotation) {\n            transformation = transform().rotate(this.xRotation, this.center);\n        }\n\n        for (let i = 1; i <= subIntervalsCount; i++) {\n            const nextAngle = currentAngle + dir * subIntervalAngle;\n            const points = this._intervalCurvePoints(currentAngle, nextAngle, transformation);\n\n            curvePoints.push(points.cp1, points.cp2, points.p2);\n            currentAngle = nextAngle;\n        }\n\n        return curvePoints;\n    }\n\n    bbox(matrix) {\n        const interval = this._arcInterval();\n        const startAngle = interval.startAngle;\n        const endAngle = interval.endAngle;\n        const extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);\n        const extremeX = deg(extremeAngles.x);\n        const extremeY = deg(extremeAngles.y);\n        const endPoint = this.pointAt(endAngle).transformCopy(matrix);\n        let currentAngleX = bboxStartAngle(extremeX, startAngle);\n        let currentAngleY = bboxStartAngle(extremeY, startAngle);\n        let currentPoint = this.pointAt(startAngle).transformCopy(matrix);\n        let minPoint = Point.min(currentPoint, endPoint);\n        let maxPoint = Point.max(currentPoint, endPoint);\n\n        while (currentAngleX < endAngle || currentAngleY < endAngle) {\n            let currentPointX;\n            if (currentAngleX < endAngle) {\n                currentPointX = this.pointAt(currentAngleX).transformCopy(matrix);\n                currentAngleX += 90;\n            }\n\n            let currentPointY;\n            if (currentAngleY < endAngle) {\n                currentPointY = this.pointAt(currentAngleY).transformCopy(matrix);\n                currentAngleY += 90;\n            }\n\n            currentPoint = new Point(currentPointX.x, currentPointY.y);\n            minPoint = Point.min(minPoint, currentPoint);\n            maxPoint = Point.max(maxPoint, currentPoint);\n        }\n\n        return Rect.fromPoints(minPoint, maxPoint);\n    }\n\n    _arcInterval() {\n        let { startAngle, endAngle, anticlockwise } = this;\n\n        if (anticlockwise) {\n            let oldStart = startAngle;\n            startAngle = endAngle;\n            endAngle = oldStart;\n        }\n\n        if (startAngle > endAngle || (anticlockwise && startAngle === endAngle)) {\n            endAngle += 360;\n        }\n\n        return {\n            startAngle: startAngle,\n            endAngle: endAngle\n        };\n    }\n\n    _intervalCurvePoints(startAngle, endAngle, transformation) {\n        const p1 = this.pointAt(startAngle);\n        const p2 = this.pointAt(endAngle);\n        const p1Derivative = this._derivativeAt(startAngle);\n        const p2Derivative = this._derivativeAt(endAngle);\n        const t = (rad(endAngle) - rad(startAngle)) / 3;\n        const cp1 = new Point(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);\n        const cp2 = new Point(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);\n        if (transformation) {\n            p1.transform(transformation);\n            p2.transform(transformation);\n            cp1.transform(transformation);\n            cp2.transform(transformation);\n        }\n\n        return {\n            p1: p1,\n            cp1: cp1,\n            cp2: cp2,\n            p2: p2\n        };\n    }\n\n    _derivativeAt(angle) {\n        const radian = rad(angle);\n\n        return new Point(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));\n    }\n\n    containsPoint(point) {\n        const interval = this._arcInterval();\n        const intervalAngle = interval.endAngle - interval.startAngle;\n        const { center, radiusX, radiusY } = this;\n        const distance = center.distanceTo(point);\n        const angleRad = Math.atan2(point.y - center.y, point.x - center.x);\n        const pointRadius = (radiusX * radiusY) /\n            Math.sqrt(pow(radiusX, 2) * pow(Math.sin(angleRad), 2) + pow(radiusY, 2) * pow(Math.cos(angleRad), 2));\n        const startPoint = this.pointAt(this.startAngle).round(PRECISION);\n        const endPoint = this.pointAt(this.endAngle).round(PRECISION);\n        const intersection = lineIntersection(center, point.round(PRECISION), startPoint, endPoint);\n        let containsPoint;\n\n        if (intervalAngle < 180) {\n            containsPoint = intersection && closeOrLess(center.distanceTo(intersection), distance) && closeOrLess(distance, pointRadius);\n        } else {\n            let angle = calculateAngle(center.x, center.y, radiusX, radiusY, point.x, point.y);\n            if (angle !== 360) {\n                angle = (360 + angle) % 360;\n            }\n\n            let inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n            containsPoint = (inAngleRange && closeOrLess(distance, pointRadius)) || (!inAngleRange && (!intersection || intersection.equals(point)));\n        }\n        return containsPoint;\n    }\n\n    _isOnPath(point, width) {\n        const interval = this._arcInterval();\n        const center = this.center;\n        let angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point.x, point.y);\n        if (angle !== 360) {\n            angle = (360 + angle) % 360;\n        }\n\n        const inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;\n\n        return inAngleRange && this.pointAt(angle).distanceTo(point) <= width;\n    }\n\n    static fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {// eslint-disable-line max-params\n        const arcParameters = normalizeArcParameters({\n            x1: start.x,\n            y1: start.y,\n            x2: end.x,\n            y2: end.y,\n            rx: rx,\n            ry: ry,\n            largeArc: largeArc,\n            swipe: swipe,\n            rotation: rotation\n        });\n\n        return new Arc(arcParameters.center, {\n            startAngle: arcParameters.startAngle,\n            endAngle: arcParameters.endAngle,\n            radiusX: arcParameters.radiusX,\n            radiusY: arcParameters.radiusY,\n            xRotation: arcParameters.xRotation,\n            anticlockwise: swipe === 0\n        });\n    }\n}\n\nfunction calculateAngle(cx, cy, rx, ry, x, y) {\n    const cos = round((x - cx) / rx, 3);\n    const sin = round((y - cy) / ry, 3);\n\n    return round(deg(Math.atan2(sin, cos)));\n}\n\nfunction normalizeArcParameters(parameters) {\n    let { x1, y1, x2, y2, rx, ry, largeArc, swipe, rotation = 0 } = parameters;\n\n    const radians = rad(rotation);\n    const cosine = Math.cos(radians);\n    const sine = Math.sin(radians);\n\n    const xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;\n    const yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;\n\n    const sign = largeArc !== swipe ? 1 : -1;\n\n    const xt2 = Math.pow(xT, 2);\n    const yt2 = Math.pow(yT, 2);\n    let rx2 = Math.pow(rx, 2);\n    let ry2 = Math.pow(ry, 2);\n\n    let delta = xt2 / rx2 + yt2 / ry2;\n\n    if (delta > 1) {\n        delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);\n        rx = delta * rx;\n        rx2 = Math.pow(rx, 2);\n\n        ry = delta * ry;\n        ry2 = Math.pow(ry, 2);\n    }\n\n    let constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));\n    // due to rounding errors the value could become NaN even after radii correction\n    if (isNaN(constT)) {\n        constT = 0;\n    }\n\n    const cxT = constT * (rx * yT) / ry;\n    const cyT = - constT * (ry * xT) / rx;\n\n    const cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;\n    const cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;\n\n\n    const uX = (xT - cxT) / rx;\n    const uY = (yT - cyT) / ry;\n    const vX = -(xT + cxT) / rx;\n    const vY = -(yT + cyT) / ry;\n\n    const startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));\n\n    const angleCosine = round((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);\n    let angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));\n\n    if (!swipe && angle > 0) {\n        angle -= 360;\n    }\n\n    if (swipe && angle < 0) {\n        angle += 360;\n    }\n    let endAngle = startAngle + angle;\n    const signEndAngle = endAngle >= 0 ? 1 : -1;\n    endAngle = (Math.abs(endAngle) % 360) * signEndAngle;\n\n    return {\n        center: new Point(cx, cy),\n        startAngle: startAngle,\n        endAngle: endAngle,\n        radiusX: rx,\n        radiusY: ry,\n        xRotation: rotation\n    };\n}\n\nfunction bboxStartAngle(angle, start) {\n    let startAngle = angle;\n\n    while (startAngle < start) {\n        startAngle += 90;\n    }\n\n    return startAngle;\n}\n\nexport default Arc;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}