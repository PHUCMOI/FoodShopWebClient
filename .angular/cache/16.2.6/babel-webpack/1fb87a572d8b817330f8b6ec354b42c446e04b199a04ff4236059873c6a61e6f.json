{"ast":null,"code":"import { Point, Segment } from '../../geometry';\nimport { last, round } from '../../util';\nconst WEIGHT = 0.333;\nconst EXTREMUM_ALLOWED_DEVIATION = 0.01;\nconst X = \"x\";\nconst Y = \"y\";\nexport function pointsToCurve(pointsIn, closed) {\n  const points = pointsIn.slice(0);\n  const segments = [];\n  let length = points.length;\n  if (length > 2) {\n    removeDuplicates(0, points);\n    length = points.length;\n  }\n  if (length < 2 || length === 2 && points[0].equals(points[1])) {\n    return segments;\n  }\n  let p0 = points[0];\n  let p1 = points[1];\n  let p2 = points[2];\n  segments.push(new Segment(p0));\n  while (p0.equals(points[length - 1])) {\n    closed = true;\n    points.pop();\n    length--;\n  }\n  if (length === 2) {\n    const tangent = getTangent(p0, p1, X, Y);\n    last(segments).controlOut(firstControlPoint(tangent, p0, p1, X, Y));\n    segments.push(new Segment(p1, secondControlPoint(tangent, p0, p1, X, Y)));\n    return segments;\n  }\n  let initialControlPoint, lastControlPoint;\n  if (closed) {\n    p0 = points[length - 1];\n    p1 = points[0];\n    p2 = points[1];\n    const controlPoints = getControlPoints(p0, p1, p2);\n    initialControlPoint = controlPoints[1];\n    lastControlPoint = controlPoints[0];\n  } else {\n    const tangent = getTangent(p0, p1, X, Y);\n    initialControlPoint = firstControlPoint(tangent, p0, p1, X, Y);\n  }\n  let cp0 = initialControlPoint;\n  for (let idx = 0; idx <= length - 3; idx++) {\n    removeDuplicates(idx, points);\n    length = points.length;\n    if (idx + 3 <= length) {\n      p0 = points[idx];\n      p1 = points[idx + 1];\n      p2 = points[idx + 2];\n      const controlPoints = getControlPoints(p0, p1, p2);\n      last(segments).controlOut(cp0);\n      cp0 = controlPoints[1];\n      const cp1 = controlPoints[0];\n      segments.push(new Segment(p1, cp1));\n    }\n  }\n  if (closed) {\n    p0 = points[length - 2];\n    p1 = points[length - 1];\n    p2 = points[0];\n    const controlPoints = getControlPoints(p0, p1, p2);\n    last(segments).controlOut(cp0);\n    segments.push(new Segment(p1, controlPoints[0]));\n    last(segments).controlOut(controlPoints[1]);\n    segments.push(new Segment(p2, lastControlPoint));\n  } else {\n    const tangent = getTangent(p1, p2, X, Y);\n    last(segments).controlOut(cp0);\n    segments.push(new Segment(p2, secondControlPoint(tangent, p1, p2, X, Y)));\n  }\n  return segments;\n}\nexport function pointsToClosedCurve(pointsIn) {\n  return pointsToCurve(pointsIn, true);\n}\nexport function removeDuplicates(idx, points) {\n  while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n    points.splice(idx + 1, 1);\n  }\n}\nexport function invertAxis(p0, p1, p2) {\n  let invertAxis = false;\n  if (p0.x === p1.x) {\n    invertAxis = true;\n  } else if (p1.x === p2.x) {\n    if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {\n      invertAxis = true;\n    }\n  } else {\n    const fn = lineFunction(p0, p1);\n    const y2 = calculateFunction(fn, p2.x);\n    if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {\n      invertAxis = true;\n    }\n  }\n  return invertAxis;\n}\nexport function isLine(p0, p1, p2) {\n  const fn = lineFunction(p0, p1);\n  const y2 = calculateFunction(fn, p2.x);\n  return p0.x === p1.x && p1.x === p2.x || round(y2, 1) === round(p2.y, 1);\n}\nexport function lineFunction(p1, p2) {\n  const a = (p2.y - p1.y) / (p2.x - p1.x);\n  const b = p1.y - a * p1.x;\n  return [b, a];\n}\nexport function getControlPoints(p0, p1, p2) {\n  let xField = X;\n  let yField = Y;\n  let restrict = false;\n  let switchOrientation = false;\n  let tangent;\n  if (isLine(p0, p1, p2)) {\n    tangent = getTangent(p0, p1, X, Y);\n  } else {\n    const monotonic = {\n      x: isMonotonicByField(p0, p1, p2, X),\n      y: isMonotonicByField(p0, p1, p2, Y)\n    };\n    if (monotonic.x && monotonic.y) {\n      tangent = getTangent(p0, p2, X, Y);\n      restrict = true;\n    } else {\n      if (invertAxis(p0, p1, p2)) {\n        xField = Y;\n        yField = X;\n      }\n      if (monotonic[xField]) {\n        tangent = 0;\n      } else {\n        let sign;\n        if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {\n          sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n        } else {\n          sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n        }\n        tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n        switchOrientation = true;\n      }\n    }\n  }\n  const secondCP = secondControlPoint(tangent, p0, p1, xField, yField);\n  if (switchOrientation) {\n    const oldXField = xField;\n    xField = yField;\n    yField = oldXField;\n  }\n  const firstCP = firstControlPoint(tangent, p1, p2, xField, yField);\n  if (restrict) {\n    restrictControlPoint(p0, p1, secondCP, tangent);\n    restrictControlPoint(p1, p2, firstCP, tangent);\n  }\n  return [secondCP, firstCP];\n}\nexport function restrictControlPoint(p1, p2, cp, tangent) {\n  if (p1.y < p2.y) {\n    if (p2.y < cp.y) {\n      cp.x = p1.x + (p2.y - p1.y) / tangent;\n      cp.y = p2.y;\n    } else if (cp.y < p1.y) {\n      cp.x = p2.x - (p2.y - p1.y) / tangent;\n      cp.y = p1.y;\n    }\n  } else {\n    if (cp.y < p2.y) {\n      cp.x = p1.x - (p1.y - p2.y) / tangent;\n      cp.y = p2.y;\n    } else if (p1.y < cp.y) {\n      cp.x = p2.x + (p1.y - p2.y) / tangent;\n      cp.y = p1.y;\n    }\n  }\n}\nexport function getTangent(p0, p1, xField, yField) {\n  const x = p1[xField] - p0[xField];\n  const y = p1[yField] - p0[yField];\n  let tangent;\n  if (x === 0) {\n    tangent = 0;\n  } else {\n    tangent = y / x;\n  }\n  return tangent;\n}\nexport function isMonotonicByField(p0, p1, p2, field) {\n  return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];\n}\nexport function firstControlPoint(tangent, p0, p3, xField, yField) {\n  const t1 = p0[xField];\n  const t2 = p3[xField];\n  const distance = (t2 - t1) * WEIGHT;\n  return point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n}\nexport function secondControlPoint(tangent, p0, p3, xField, yField) {\n  const t1 = p0[xField];\n  const t2 = p3[xField];\n  const distance = (t2 - t1) * WEIGHT;\n  return point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n}\nexport function point(xValue, yValue, xField, yField) {\n  const controlPoint = new Point();\n  controlPoint[xField] = xValue;\n  controlPoint[yField] = yValue;\n  return controlPoint;\n}\nexport function calculateFunction(fn, x) {\n  const length = fn.length;\n  let result = 0;\n  for (let i = 0; i < length; i++) {\n    result += Math.pow(x, i) * fn[i];\n  }\n  return result;\n}\nexport function numberSign(value) {\n  return value <= 0 ? -1 : 1;\n}","map":{"version":3,"names":["Point","Segment","last","round","WEIGHT","EXTREMUM_ALLOWED_DEVIATION","X","Y","pointsToCurve","pointsIn","closed","points","slice","segments","length","removeDuplicates","equals","p0","p1","p2","push","pop","tangent","getTangent","controlOut","firstControlPoint","secondControlPoint","initialControlPoint","lastControlPoint","controlPoints","getControlPoints","cp0","idx","cp1","pointsToClosedCurve","splice","invertAxis","x","y","fn","lineFunction","y2","calculateFunction","isLine","a","b","xField","yField","restrict","switchOrientation","monotonic","isMonotonicByField","sign","numberSign","secondCP","oldXField","firstCP","restrictControlPoint","cp","field","p3","t1","t2","distance","point","xValue","yValue","controlPoint","result","i","Math","pow","value"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-drawing/dist/es2015/shapes/utils/points-to-curve.js"],"sourcesContent":["import { Point, Segment } from '../../geometry';\nimport { last, round } from '../../util';\n\nconst WEIGHT = 0.333;\nconst EXTREMUM_ALLOWED_DEVIATION = 0.01;\nconst X = \"x\";\nconst Y = \"y\";\n\nexport function pointsToCurve(pointsIn, closed) {\n    const points = pointsIn.slice(0);\n    const segments = [];\n    let length = points.length;\n\n    if (length > 2) {\n        removeDuplicates(0, points);\n        length = points.length;\n    }\n\n    if (length < 2 || (length === 2 && points[0].equals(points[1]))) {\n        return segments;\n    }\n\n    let p0 = points[0];\n    let p1 = points[1];\n    let p2 = points[2];\n\n    segments.push(new Segment(p0));\n\n    while (p0.equals(points[length - 1])) {\n        closed = true;\n        points.pop();\n        length--;\n    }\n\n    if (length === 2) {\n        const tangent = getTangent(p0,p1, X, Y);\n\n        last(segments).controlOut(\n            firstControlPoint(tangent, p0, p1, X, Y)\n        );\n\n        segments.push(new Segment(\n            p1,\n            secondControlPoint(tangent, p0, p1, X, Y)\n        ));\n\n        return segments;\n    }\n\n    let initialControlPoint, lastControlPoint;\n\n    if (closed) {\n        p0 = points[length - 1]; p1 = points[0]; p2 = points[1];\n        const controlPoints = getControlPoints(p0, p1, p2);\n        initialControlPoint = controlPoints[1];\n        lastControlPoint = controlPoints[0];\n    } else {\n        const tangent = getTangent(p0, p1, X,Y);\n        initialControlPoint = firstControlPoint(tangent, p0, p1, X, Y);\n    }\n\n    let cp0 = initialControlPoint;\n    for (let idx = 0; idx <= length - 3; idx++) {\n        removeDuplicates(idx, points);\n        length = points.length;\n        if (idx + 3 <= length) {\n            p0 = points[idx]; p1 = points[idx + 1]; p2 = points[idx + 2];\n            const controlPoints = getControlPoints(p0,p1,p2);\n\n            last(segments).controlOut(cp0);\n            cp0 = controlPoints[1];\n\n            const cp1 = controlPoints[0];\n            segments.push(new Segment(p1, cp1));\n        }\n    }\n\n    if (closed) {\n        p0 = points[length - 2]; p1 = points[length - 1]; p2 = points[0];\n        const controlPoints = getControlPoints(p0, p1, p2);\n\n        last(segments).controlOut(cp0);\n        segments.push(new Segment(\n            p1,\n            controlPoints[0]\n        ));\n\n        last(segments).controlOut(controlPoints[1]);\n        segments.push(new Segment(\n            p2,\n            lastControlPoint\n        ));\n    } else {\n        const tangent = getTangent(p1, p2, X, Y);\n\n        last(segments).controlOut(cp0);\n        segments.push(new Segment(\n            p2,\n            secondControlPoint(tangent, p1, p2, X, Y)\n        ));\n    }\n\n    return segments;\n}\n\nexport function pointsToClosedCurve(pointsIn) {\n    return pointsToCurve(pointsIn, true);\n}\n\nexport function removeDuplicates(idx, points) {\n    while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n        points.splice(idx + 1, 1);\n    }\n}\n\nexport function invertAxis(p0, p1, p2) {\n    let invertAxis = false;\n\n    if (p0.x === p1.x) {\n        invertAxis = true;\n    } else if (p1.x === p2.x) {\n        if ((p1.y < p2.y && p0.y <= p1.y) || (p2.y < p1.y && p1.y <= p0.y)) {\n            invertAxis = true;\n        }\n    } else {\n        const fn = lineFunction(p0,p1);\n        const y2 = calculateFunction(fn, p2.x);\n        if (!(p0.y <= p1.y && p2.y <= y2) &&\n            !(p1.y <= p0.y && p2.y >= y2)) {\n            invertAxis = true;\n        }\n    }\n\n    return invertAxis;\n}\n\nexport function isLine(p0, p1, p2) {\n    const fn = lineFunction(p0, p1);\n    const y2 = calculateFunction(fn, p2.x);\n\n    return (p0.x === p1.x && p1.x === p2.x) || round(y2, 1) === round(p2.y, 1);\n}\n\nexport function lineFunction(p1, p2) {\n    const a = (p2.y - p1.y) / (p2.x - p1.x);\n    const b = p1.y - a * p1.x;\n\n    return [ b, a ];\n}\n\nexport function getControlPoints(p0, p1, p2) {\n    let xField = X;\n    let yField = Y;\n    let restrict = false;\n    let switchOrientation = false;\n    let tangent;\n\n    if (isLine(p0, p1, p2)) {\n        tangent = getTangent(p0, p1, X, Y);\n    } else {\n        const monotonic = {\n            x: isMonotonicByField(p0, p1, p2, X),\n            y: isMonotonicByField(p0, p1, p2, Y)\n        };\n\n        if (monotonic.x && monotonic.y) {\n            tangent = getTangent(p0, p2, X, Y);\n            restrict = true;\n        } else {\n            if (invertAxis(p0, p1, p2)) {\n                xField = Y;\n                yField = X;\n            }\n\n            if (monotonic[xField]) {\n                tangent = 0;\n            } else {\n                let sign;\n                if ((p2[yField] < p0[yField] && p0[yField] <= p1[yField]) ||\n                    (p0[yField] < p2[yField] && p1[yField] <= p0[yField])) {\n                    sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n                } else {\n                    sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n                }\n\n                tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n                switchOrientation = true;\n            }\n        }\n    }\n\n    const secondCP = secondControlPoint(tangent, p0, p1, xField, yField);\n\n    if (switchOrientation) {\n        const oldXField = xField;\n        xField = yField;\n        yField = oldXField;\n    }\n\n    const firstCP = firstControlPoint(tangent, p1, p2, xField, yField);\n\n    if (restrict) {\n        restrictControlPoint(p0, p1, secondCP, tangent);\n        restrictControlPoint(p1, p2, firstCP, tangent);\n    }\n\n    return [ secondCP, firstCP ];\n}\n\nexport function restrictControlPoint(p1, p2, cp, tangent) {\n    if (p1.y < p2.y) {\n        if (p2.y < cp.y) {\n            cp.x = p1.x + (p2.y - p1.y) / tangent;\n            cp.y = p2.y;\n        } else if (cp.y < p1.y) {\n            cp.x = p2.x - (p2.y - p1.y) / tangent;\n            cp.y = p1.y;\n        }\n    } else {\n        if (cp.y < p2.y) {\n            cp.x = p1.x - (p1.y - p2.y) / tangent;\n            cp.y = p2.y;\n        } else if (p1.y < cp.y) {\n            cp.x = p2.x + (p1.y - p2.y) / tangent;\n            cp.y = p1.y;\n        }\n    }\n}\n\nexport function getTangent(p0, p1, xField, yField) {\n    const x = p1[xField] - p0[xField];\n    const y = p1[yField] - p0[yField];\n    let tangent;\n\n    if (x === 0) {\n        tangent = 0;\n    } else {\n        tangent = y / x;\n    }\n\n    return tangent;\n}\n\nexport function isMonotonicByField(p0, p1, p2, field) {\n    return (p2[field] > p1[field] && p1[field] > p0[field]) ||\n                (p2[field] < p1[field] && p1[field] < p0[field]);\n}\n\nexport function firstControlPoint(tangent, p0, p3, xField, yField) {\n    const t1 = p0[xField];\n    const t2 = p3[xField];\n    const distance = (t2 - t1) * WEIGHT;\n\n    return point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n}\n\nexport function secondControlPoint(tangent, p0, p3, xField, yField) {\n    const t1 = p0[xField];\n    const t2 = p3[xField];\n    const distance = (t2 - t1) * WEIGHT;\n\n    return point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n}\n\nexport function point(xValue, yValue, xField, yField) {\n    const controlPoint = new Point();\n    controlPoint[xField] = xValue;\n    controlPoint[yField] = yValue;\n\n    return controlPoint;\n}\n\nexport function calculateFunction(fn, x) {\n    const length = fn.length;\n    let result = 0;\n\n    for (let i = 0; i < length; i++) {\n        result += Math.pow(x,i) * fn[i];\n    }\n    return result;\n}\n\nexport function numberSign(value) {\n    return value <= 0 ? -1 : 1;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}