{"ast":null,"code":"import Box from './box';\nimport Point from './point';\nimport { COORD_PRECISION, MAX_VALUE, MIN_VALUE } from '../common/constants';\nimport { Class, clockwise, rad, round } from '../common';\nclass Ring extends Class {\n  constructor(center, innerRadius, radius, startAngle, angle) {\n    super();\n    this.center = center;\n    this.innerRadius = innerRadius;\n    this.radius = radius;\n    this.startAngle = startAngle;\n    this.angle = angle;\n  }\n  clone() {\n    return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n  }\n  middle() {\n    return this.startAngle + this.angle / 2;\n  }\n  setRadius(newRadius, innerRadius) {\n    if (innerRadius) {\n      this.innerRadius = newRadius;\n    } else {\n      this.radius = newRadius;\n    }\n    return this;\n  }\n\n  // TODO: Remove and replace with Point.onCircle\n  point(angle, innerRadius) {\n    const radianAngle = rad(angle);\n    const ax = Math.cos(radianAngle);\n    const ay = Math.sin(radianAngle);\n    const radius = innerRadius ? this.innerRadius : this.radius;\n    const x = round(this.center.x - ax * radius, COORD_PRECISION);\n    const y = round(this.center.y - ay * radius, COORD_PRECISION);\n    return new Point(x, y);\n  }\n  adjacentBox(distance, width, height) {\n    const sector = this.clone().expand(distance);\n    const midAndle = sector.middle();\n    const midPoint = sector.point(midAndle);\n    const hw = width / 2;\n    const hh = height / 2;\n    const sa = Math.sin(rad(midAndle));\n    const ca = Math.cos(rad(midAndle));\n    let x = midPoint.x - hw;\n    let y = midPoint.y - hh;\n    if (Math.abs(sa) < 0.9) {\n      x += hw * -ca / Math.abs(ca);\n    }\n    if (Math.abs(ca) < 0.9) {\n      y += hh * -sa / Math.abs(sa);\n    }\n    return new Box(x, y, x + width, y + height);\n  }\n  containsPoint(p) {\n    const center = this.center;\n    const innerRadius = this.innerRadius;\n    const radius = this.radius;\n    const startAngle = this.startAngle;\n    const endAngle = this.startAngle + this.angle;\n    const dx = p.x - center.x;\n    const dy = p.y - center.y;\n    const vector = new Point(dx, dy);\n    const startPoint = this.point(startAngle);\n    const startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\n    const endPoint = this.point(endAngle);\n    const endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\n    const dist = round(dx * dx + dy * dy, COORD_PRECISION);\n    return (startVector.equals(vector) || clockwise(startVector, vector)) && !clockwise(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;\n  }\n  getBBox() {\n    const box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n    const startAngle = round(this.startAngle % 360);\n    const endAngle = round((startAngle + this.angle) % 360);\n    const innerRadius = this.innerRadius;\n    const allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);\n    const startAngleIndex = allAngles.indexOf(startAngle);\n    const endAngleIndex = allAngles.indexOf(endAngle);\n    let angles;\n    if (startAngle === endAngle) {\n      angles = allAngles;\n    } else {\n      if (startAngleIndex < endAngleIndex) {\n        angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n      } else {\n        angles = [].concat(allAngles.slice(0, endAngleIndex + 1), allAngles.slice(startAngleIndex, allAngles.length));\n      }\n    }\n    for (let i = 0; i < angles.length; i++) {\n      let point = this.point(angles[i]);\n      box.wrapPoint(point);\n      box.wrapPoint(point, innerRadius);\n    }\n    if (!innerRadius) {\n      box.wrapPoint(this.center);\n    }\n    return box;\n  }\n  expand(value) {\n    this.radius += value;\n    return this;\n  }\n}\nfunction numericComparer(a, b) {\n  return a - b;\n}\nexport default Ring;","map":{"version":3,"names":["Box","Point","COORD_PRECISION","MAX_VALUE","MIN_VALUE","Class","clockwise","rad","round","Ring","constructor","center","innerRadius","radius","startAngle","angle","clone","middle","setRadius","newRadius","point","radianAngle","ax","Math","cos","ay","sin","x","y","adjacentBox","distance","width","height","sector","expand","midAndle","midPoint","hw","hh","sa","ca","abs","containsPoint","p","endAngle","dx","dy","vector","startPoint","startVector","endPoint","endVector","dist","equals","getBBox","box","allAngles","sort","numericComparer","startAngleIndex","indexOf","endAngleIndex","angles","slice","concat","length","i","wrapPoint","value","a","b"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/core/ring.js"],"sourcesContent":["import Box from './box';\nimport Point from './point';\nimport { COORD_PRECISION, MAX_VALUE, MIN_VALUE } from '../common/constants';\nimport { Class, clockwise, rad, round } from '../common';\n\nclass Ring extends Class {\n\n    constructor(center, innerRadius, radius, startAngle, angle) {\n        super();\n\n        this.center = center;\n        this.innerRadius = innerRadius;\n        this.radius = radius;\n        this.startAngle = startAngle;\n        this.angle = angle;\n    }\n\n    clone() {\n        return new Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);\n    }\n\n    middle() {\n        return this.startAngle + this.angle / 2;\n    }\n\n    setRadius(newRadius, innerRadius) {\n        if (innerRadius) {\n            this.innerRadius = newRadius;\n        } else {\n            this.radius = newRadius;\n        }\n\n        return this;\n    }\n\n    // TODO: Remove and replace with Point.onCircle\n    point(angle, innerRadius) {\n        const radianAngle = rad(angle);\n        const ax = Math.cos(radianAngle);\n        const ay = Math.sin(radianAngle);\n        const radius = innerRadius ? this.innerRadius : this.radius;\n        const x = round(this.center.x - (ax * radius), COORD_PRECISION);\n        const y = round(this.center.y - (ay * radius), COORD_PRECISION);\n\n        return new Point(x, y);\n    }\n\n    adjacentBox(distance, width, height) {\n        const sector = this.clone().expand(distance);\n        const midAndle = sector.middle();\n        const midPoint = sector.point(midAndle);\n        const hw = width / 2;\n        const hh = height / 2;\n        const sa = Math.sin(rad(midAndle));\n        const ca = Math.cos(rad(midAndle));\n        let x = midPoint.x - hw;\n        let y = midPoint.y - hh;\n\n        if (Math.abs(sa) < 0.9) {\n            x += hw * -ca / Math.abs(ca);\n        }\n\n        if (Math.abs(ca) < 0.9) {\n            y += hh * -sa / Math.abs(sa);\n        }\n\n        return new Box(x, y, x + width, y + height);\n    }\n\n    containsPoint(p) {\n        const center = this.center;\n        const innerRadius = this.innerRadius;\n        const radius = this.radius;\n        const startAngle = this.startAngle;\n        const endAngle = this.startAngle + this.angle;\n        const dx = p.x - center.x;\n        const dy = p.y - center.y;\n        const vector = new Point(dx, dy);\n        const startPoint = this.point(startAngle);\n        const startVector = new Point(startPoint.x - center.x, startPoint.y - center.y);\n        const endPoint = this.point(endAngle);\n        const endVector = new Point(endPoint.x - center.x, endPoint.y - center.y);\n        const dist = round(dx * dx + dy * dy, COORD_PRECISION);\n\n        return (startVector.equals(vector) || clockwise(startVector, vector)) &&\n               !clockwise(endVector, vector) &&\n               dist >= innerRadius * innerRadius && dist <= radius * radius;\n    }\n\n    getBBox() {\n        const box = new Box(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);\n        const startAngle = round(this.startAngle % 360);\n        const endAngle = round((startAngle + this.angle) % 360);\n        const innerRadius = this.innerRadius;\n        const allAngles = [ 0, 90, 180, 270, startAngle, endAngle ].sort(numericComparer);\n        const startAngleIndex = allAngles.indexOf(startAngle);\n        const endAngleIndex = allAngles.indexOf(endAngle);\n        let angles;\n\n        if (startAngle === endAngle) {\n            angles = allAngles;\n        } else {\n            if (startAngleIndex < endAngleIndex) {\n                angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);\n            } else {\n                angles = [].concat(\n                    allAngles.slice(0, endAngleIndex + 1),\n                    allAngles.slice(startAngleIndex, allAngles.length)\n                );\n            }\n        }\n\n        for (let i = 0; i < angles.length; i++) {\n            let point = this.point(angles[i]);\n            box.wrapPoint(point);\n            box.wrapPoint(point, innerRadius);\n        }\n\n        if (!innerRadius) {\n            box.wrapPoint(this.center);\n        }\n\n        return box;\n    }\n\n    expand(value) {\n        this.radius += value;\n        return this;\n    }\n}\n\nfunction numericComparer(a, b) {\n    return a - b;\n}\n\nexport default Ring;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}