{"ast":null,"code":"import HasObservers from '../core/has-observers';\nimport Rect from './rect';\nimport Point from './point';\nimport transform from './transform';\nimport { deg, MIN_NUM, MAX_NUM } from '../util';\nimport isOutOfEndPoint from './math/is-out-of-end-point';\nimport calculateCurveAt from './math/calculate-curve-at';\nimport hasRootsInRange from './math/has-roots-in-range';\nimport curveIntersectionsCount from './math/curve-intersections-count';\nimport lineIntersectionsCount from './math/line-intersections-count';\nimport withPoints from '../mixins/with-points';\nconst points = [\"anchor\", \"controlIn\", \"controlOut\"];\nclass Segment extends withPoints(HasObservers, points) {\n  constructor(anchor, controlIn, controlOut) {\n    super();\n    this.anchor(anchor || new Point());\n    this.controlIn(controlIn);\n    this.controlOut(controlOut);\n  }\n  bboxTo(toSegment, matrix) {\n    const segmentAnchor = this.anchor().transformCopy(matrix);\n    const toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n    let rect;\n    if (this.controlOut() && toSegment.controlIn()) {\n      rect = this._curveBoundingBox(segmentAnchor, this.controlOut().transformCopy(matrix), toSegment.controlIn().transformCopy(matrix), toSegmentAnchor);\n    } else {\n      rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n    }\n    return rect;\n  }\n  _lineBoundingBox(p1, p2) {\n    return Rect.fromPoints(p1, p2);\n  }\n  _curveBoundingBox(p1, cp1, cp2, p2) {\n    const points = [p1, cp1, cp2, p2];\n    const extremesX = this._curveExtremesFor(points, \"x\");\n    const extremesY = this._curveExtremesFor(points, \"y\");\n    const xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p2.x]);\n    const yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p2.y]);\n    return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n  }\n  _curveExtremesFor(points, field) {\n    const extremes = this._curveExtremes(points[0][field], points[1][field], points[2][field], points[3][field]);\n    return {\n      min: calculateCurveAt(extremes.min, field, points),\n      max: calculateCurveAt(extremes.max, field, points)\n    };\n  }\n  _curveExtremes(x1, x2, x3, x4) {\n    const a = x1 - 3 * x2 + 3 * x3 - x4;\n    const b = -2 * (x1 - 2 * x2 + x3);\n    const c = x1 - x2;\n    const sqrt = Math.sqrt(b * b - 4 * a * c);\n    let t1 = 0;\n    let t2 = 1;\n    if (a === 0) {\n      if (b !== 0) {\n        t1 = t2 = -c / b;\n      }\n    } else if (!isNaN(sqrt)) {\n      t1 = (-b + sqrt) / (2 * a);\n      t2 = (-b - sqrt) / (2 * a);\n    }\n    let min = Math.max(Math.min(t1, t2), 0);\n    if (min < 0 || min > 1) {\n      min = 0;\n    }\n    let max = Math.min(Math.max(t1, t2), 1);\n    if (max > 1 || max < 0) {\n      max = 1;\n    }\n    return {\n      min: min,\n      max: max\n    };\n  }\n  _intersectionsTo(segment, point) {\n    let intersectionsCount;\n    if (this.controlOut() && segment.controlIn()) {\n      intersectionsCount = curveIntersectionsCount([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point, this.bboxTo(segment));\n    } else {\n      intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n    }\n    return intersectionsCount;\n  }\n  _isOnCurveTo(segment, point, width, endSegment) {\n    const bbox = this.bboxTo(segment).expand(width, width);\n    if (bbox.containsPoint(point)) {\n      const p1 = this.anchor();\n      const p2 = this.controlOut();\n      const p3 = segment.controlIn();\n      const p4 = segment.anchor();\n      if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n        return !isOutOfEndPoint(p1, p2, point);\n      } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n        return !isOutOfEndPoint(p4, p3, point);\n      }\n\n      //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n      const points = [p1, p2, p3, p4];\n      if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\n        return true;\n      }\n      const rotation = transform().rotate(45, point);\n      const rotatedPoints = [p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation)];\n      return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n    }\n  }\n  _isOnLineTo(segment, point, width) {\n    const p1 = this.anchor();\n    const p2 = segment.anchor();\n    const angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n    const rect = new Rect([p1.x, p1.y - width / 2], [p1.distanceTo(p2), width]);\n    return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\n  }\n  _isOnPathTo(segment, point, width, endSegment) {\n    let isOnPath;\n    if (this.controlOut() && segment.controlIn()) {\n      isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n    } else {\n      isOnPath = this._isOnLineTo(segment, point, width);\n    }\n    return isOnPath;\n  }\n}\nfunction arrayLimits(arr) {\n  let length = arr.length;\n  let min = MAX_NUM;\n  let max = MIN_NUM;\n  for (let i = 0; i < length; i++) {\n    max = Math.max(max, arr[i]);\n    min = Math.min(min, arr[i]);\n  }\n  return {\n    min: min,\n    max: max\n  };\n}\nexport default Segment;","map":{"version":3,"names":["HasObservers","Rect","Point","transform","deg","MIN_NUM","MAX_NUM","isOutOfEndPoint","calculateCurveAt","hasRootsInRange","curveIntersectionsCount","lineIntersectionsCount","withPoints","points","Segment","constructor","anchor","controlIn","controlOut","bboxTo","toSegment","matrix","segmentAnchor","transformCopy","toSegmentAnchor","rect","_curveBoundingBox","_lineBoundingBox","p1","p2","fromPoints","cp1","cp2","extremesX","_curveExtremesFor","extremesY","xLimits","arrayLimits","min","max","x","yLimits","y","field","extremes","_curveExtremes","x1","x2","x3","x4","a","b","c","sqrt","Math","t1","t2","isNaN","_intersectionsTo","segment","point","intersectionsCount","_isOnCurveTo","width","endSegment","bbox","expand","containsPoint","p3","p4","distanceTo","rotation","rotate","rotatedPoints","_isOnLineTo","angle","atan2","_isOnPathTo","isOnPath","arr","length","i"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-drawing/dist/es2015/geometry/segment.js"],"sourcesContent":["import HasObservers from '../core/has-observers';\nimport Rect from './rect';\nimport Point from './point';\nimport transform from './transform';\nimport { deg, MIN_NUM, MAX_NUM } from '../util';\nimport isOutOfEndPoint from './math/is-out-of-end-point';\nimport calculateCurveAt from './math/calculate-curve-at';\nimport hasRootsInRange from './math/has-roots-in-range';\nimport curveIntersectionsCount from './math/curve-intersections-count';\nimport lineIntersectionsCount from './math/line-intersections-count';\nimport withPoints from '../mixins/with-points';\n\n\nconst points = [ \"anchor\", \"controlIn\", \"controlOut\" ];\n\nclass Segment extends withPoints(HasObservers, points) {\n    constructor(anchor, controlIn, controlOut) {\n        super();\n\n        this.anchor(anchor || new Point());\n        this.controlIn(controlIn);\n        this.controlOut(controlOut);\n    }\n\n    bboxTo(toSegment, matrix) {\n        const segmentAnchor = this.anchor().transformCopy(matrix);\n        const toSegmentAnchor = toSegment.anchor().transformCopy(matrix);\n        let rect;\n\n        if (this.controlOut() && toSegment.controlIn()) {\n            rect = this._curveBoundingBox(\n                segmentAnchor, this.controlOut().transformCopy(matrix),\n                toSegment.controlIn().transformCopy(matrix), toSegmentAnchor\n            );\n        } else {\n            rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);\n        }\n\n        return rect;\n    }\n\n    _lineBoundingBox(p1, p2) {\n        return Rect.fromPoints(p1, p2);\n    }\n\n    _curveBoundingBox(p1, cp1, cp2, p2) {\n        const points = [ p1, cp1, cp2, p2 ];\n        const extremesX = this._curveExtremesFor(points, \"x\");\n        const extremesY = this._curveExtremesFor(points, \"y\");\n        const xLimits = arrayLimits([ extremesX.min, extremesX.max, p1.x, p2.x ]);\n        const yLimits = arrayLimits([ extremesY.min, extremesY.max, p1.y, p2.y ]);\n\n        return Rect.fromPoints(new Point(xLimits.min, yLimits.min), new Point(xLimits.max, yLimits.max));\n    }\n\n    _curveExtremesFor(points, field) {\n        const extremes = this._curveExtremes(\n            points[0][field], points[1][field],\n            points[2][field], points[3][field]\n        );\n\n        return {\n            min: calculateCurveAt(extremes.min, field, points),\n            max: calculateCurveAt(extremes.max, field, points)\n        };\n    }\n\n    _curveExtremes(x1, x2, x3, x4) {\n        const a = x1 - 3 * x2 + 3 * x3 - x4;\n        const b = - 2 * (x1 - 2 * x2 + x3);\n        const c = x1 - x2;\n        const sqrt = Math.sqrt(b * b - 4 * a * c);\n        let t1 = 0;\n        let t2 = 1;\n\n        if (a === 0) {\n            if (b !== 0) {\n                t1 = t2 = -c / b;\n            }\n        } else if (!isNaN(sqrt)) {\n            t1 = (- b + sqrt) / (2 * a);\n            t2 = (- b - sqrt) / (2 * a);\n        }\n\n        let min = Math.max(Math.min(t1, t2), 0);\n        if (min < 0 || min > 1) {\n            min = 0;\n        }\n\n        let max = Math.min(Math.max(t1, t2), 1);\n        if (max > 1 || max < 0) {\n            max = 1;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    _intersectionsTo(segment, point) {\n        let intersectionsCount;\n        if (this.controlOut() && segment.controlIn()) {\n            intersectionsCount = curveIntersectionsCount([ this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor() ], point, this.bboxTo(segment));\n        } else {\n            intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point);\n        }\n        return intersectionsCount;\n    }\n\n    _isOnCurveTo(segment, point, width, endSegment) {\n        const bbox = this.bboxTo(segment).expand(width, width);\n        if (bbox.containsPoint(point)) {\n            const p1 = this.anchor();\n            const p2 = this.controlOut();\n            const p3 = segment.controlIn();\n            const p4 = segment.anchor();\n\n            if (endSegment === \"start\" && p1.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p1, p2, point);\n            } else if (endSegment === \"end\" && p4.distanceTo(point) <= width) {\n                return !isOutOfEndPoint(p4, p3, point);\n            }\n\n            //the approach is not entirely correct but is close and the alternatives are solving a 6th degree polynomial or testing the segment points\n            const points = [ p1, p2, p3, p4 ];\n            if (hasRootsInRange(points, point, \"x\", \"y\", width) || hasRootsInRange(points, point, \"y\", \"x\", width)) {\n                return true;\n            }\n            const rotation = transform().rotate(45, point);\n            const rotatedPoints = [ p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation) ];\n            return hasRootsInRange(rotatedPoints, point, \"x\", \"y\", width) || hasRootsInRange(rotatedPoints, point, \"y\", \"x\", width);\n        }\n    }\n\n    _isOnLineTo(segment, point, width) {\n        const p1 = this.anchor();\n        const p2 = segment.anchor();\n        const angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));\n        const rect = new Rect([ p1.x, p1.y - width / 2 ], [ p1.distanceTo(p2), width ]);\n        return rect.containsPoint(point.transformCopy(transform().rotate(-angle, p1)));\n    }\n\n    _isOnPathTo(segment, point, width, endSegment) {\n        let isOnPath;\n        if (this.controlOut() && segment.controlIn()) {\n            isOnPath = this._isOnCurveTo(segment, point, width / 2, endSegment);\n        } else {\n            isOnPath = this._isOnLineTo(segment, point, width);\n        }\n        return isOnPath;\n    }\n}\n\nfunction arrayLimits(arr) {\n    let length = arr.length;\n    let min = MAX_NUM;\n    let max = MIN_NUM;\n\n    for (let i = 0; i < length; i ++) {\n        max = Math.max(max, arr[i]);\n        min = Math.min(min, arr[i]);\n    }\n\n    return {\n        min: min,\n        max: max\n    };\n}\n\nexport default Segment;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}