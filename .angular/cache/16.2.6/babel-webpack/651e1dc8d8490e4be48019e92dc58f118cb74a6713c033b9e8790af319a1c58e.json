{"ast":null,"code":"import { INTERPOLATE, ZERO } from '../constants';\nimport { convertableToNumber } from '../../common';\nimport SeriesBinder from '../series-binder';\nconst AREA_REGEX = /area/i;\nfunction seriesMissingValues(series) {\n  if (series.missingValues) {\n    return series.missingValues;\n  }\n  return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;\n}\nfunction hasValue(series, item) {\n  const fields = SeriesBinder.current.bindPoint(series, null, item);\n  const valueFields = fields.valueFields;\n  for (let field in valueFields) {\n    if (convertableToNumber(valueFields[field])) {\n      return true;\n    }\n  }\n}\nfunction findNext({\n  start,\n  dir,\n  min,\n  max,\n  getter,\n  hasItem,\n  series\n}) {\n  let pointHasValue, outPoint;\n  let idx = start;\n  do {\n    idx += dir;\n    //aggregating and binding the item takes too much time for large number of categories\n    //will assume that if the aggregation does not create value for a missing item for one it will not create for others\n    if (hasItem(idx)) {\n      outPoint = getter(idx);\n      pointHasValue = hasValue(series, outPoint.item);\n    }\n  } while (min <= idx && idx <= max && !pointHasValue);\n  if (pointHasValue) {\n    return outPoint;\n  }\n}\nexport default function createOutOfRangePoints(series, range, count, getter, hasItem) {\n  const {\n    min,\n    max\n  } = range;\n  const hasMinPoint = min > 0 && min < count;\n  const hasMaxPoint = max + 1 < count;\n  if (hasMinPoint || hasMaxPoint) {\n    const missingValues = seriesMissingValues(series);\n    let minPoint, maxPoint;\n    if (missingValues !== INTERPOLATE) {\n      if (hasMinPoint) {\n        minPoint = getter(min - 1);\n      }\n      if (hasMaxPoint) {\n        maxPoint = getter(max + 1);\n      }\n    } else {\n      let outPoint, pointHasValue;\n      if (hasMinPoint) {\n        outPoint = getter(min - 1);\n        pointHasValue = hasValue(series, outPoint.item);\n        if (!pointHasValue) {\n          minPoint = findNext({\n            start: min,\n            dir: -1,\n            min: 0,\n            max: count - 1,\n            getter: getter,\n            hasItem: hasItem,\n            series: series\n          });\n        } else {\n          minPoint = outPoint;\n        }\n      }\n      if (hasMaxPoint) {\n        outPoint = getter(max + 1);\n        pointHasValue = hasValue(series, outPoint.item);\n        if (!pointHasValue) {\n          maxPoint = findNext({\n            start: max,\n            dir: 1,\n            min: 0,\n            max: count - 1,\n            getter: getter,\n            hasItem: hasItem,\n            series: series\n          });\n        } else {\n          maxPoint = outPoint;\n        }\n      }\n    }\n    if (minPoint) {\n      series._outOfRangeMinPoint = minPoint;\n    }\n    if (maxPoint) {\n      series._outOfRangeMaxPoint = maxPoint;\n    }\n  }\n}","map":{"version":3,"names":["INTERPOLATE","ZERO","convertableToNumber","SeriesBinder","AREA_REGEX","seriesMissingValues","series","missingValues","test","type","stack","hasValue","item","fields","current","bindPoint","valueFields","field","findNext","start","dir","min","max","getter","hasItem","pointHasValue","outPoint","idx","createOutOfRangePoints","range","count","hasMinPoint","hasMaxPoint","minPoint","maxPoint","_outOfRangeMinPoint","_outOfRangeMaxPoint"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/utils/create-out-of-range-points.js"],"sourcesContent":["import { INTERPOLATE, ZERO } from '../constants';\nimport { convertableToNumber } from '../../common';\nimport SeriesBinder from '../series-binder';\n\nconst AREA_REGEX = /area/i;\n\nfunction seriesMissingValues(series) {\n    if (series.missingValues) {\n        return series.missingValues;\n    }\n\n    return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;\n}\n\nfunction hasValue(series, item) {\n    const fields = SeriesBinder.current.bindPoint(series, null, item);\n    const valueFields = fields.valueFields;\n\n    for (let field in valueFields) {\n        if (convertableToNumber(valueFields[field])) {\n            return true;\n        }\n    }\n}\n\nfunction findNext({ start, dir, min, max, getter, hasItem, series }) {\n    let pointHasValue, outPoint;\n    let idx = start;\n    do {\n        idx += dir;\n        //aggregating and binding the item takes too much time for large number of categories\n        //will assume that if the aggregation does not create value for a missing item for one it will not create for others\n        if (hasItem(idx)) {\n            outPoint = getter(idx);\n            pointHasValue = hasValue(series, outPoint.item);\n        }\n    } while (min <= idx && idx <= max && !pointHasValue);\n\n    if (pointHasValue) {\n        return outPoint;\n    }\n}\n\nexport default function createOutOfRangePoints(series, range, count, getter, hasItem) {\n    const { min, max } = range;\n    const hasMinPoint = min > 0 && min < count;\n    const hasMaxPoint = max + 1 < count;\n\n    if (hasMinPoint || hasMaxPoint) {\n        const missingValues = seriesMissingValues(series);\n        let minPoint, maxPoint;\n        if (missingValues !== INTERPOLATE) {\n            if (hasMinPoint) {\n                minPoint = getter(min - 1);\n            }\n\n            if (hasMaxPoint) {\n                maxPoint = getter(max + 1);\n            }\n        } else {\n            let outPoint, pointHasValue;\n            if (hasMinPoint) {\n                outPoint = getter(min - 1);\n                pointHasValue = hasValue(series, outPoint.item);\n                if (!pointHasValue) {\n                    minPoint = findNext({\n                        start: min,\n                        dir: -1,\n                        min: 0,\n                        max: count - 1,\n                        getter: getter,\n                        hasItem: hasItem,\n                        series: series\n                    });\n                } else {\n                    minPoint = outPoint;\n                }\n            }\n\n            if (hasMaxPoint) {\n                outPoint = getter(max + 1);\n                pointHasValue = hasValue(series, outPoint.item);\n                if (!pointHasValue) {\n                    maxPoint = findNext({\n                        start: max,\n                        dir: 1,\n                        min: 0,\n                        max: count - 1,\n                        getter: getter,\n                        hasItem: hasItem,\n                        series: series\n                    });\n                } else {\n                    maxPoint = outPoint;\n                }\n            }\n        }\n\n        if (minPoint) {\n            series._outOfRangeMinPoint = minPoint;\n        }\n\n        if (maxPoint) {\n            series._outOfRangeMaxPoint = maxPoint;\n        }\n    }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}