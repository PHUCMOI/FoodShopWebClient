{"ast":null,"code":"import { geometry as geom } from '@progress/kendo-drawing';\nimport Bar from './bar';\nimport CategoricalChart from '../categorical-chart';\nimport ClusterLayout from '../layout/cluster-layout';\nimport StackWrap from '../layout/stack-wrap';\nimport { BAR, OUTSIDE_END, INSIDE_END } from '../constants';\nimport anyHasZIndex from '../utils/any-has-z-index';\nimport { STRING, X, Y } from '../../common/constants';\nimport { defined, isFunction, setDefaultOptions } from '../../common';\nclass BarChart extends CategoricalChart {\n  render() {\n    super.render();\n    this.updateStackRange();\n  }\n  pointType() {\n    return Bar;\n  }\n  clusterType() {\n    return ClusterLayout;\n  }\n  stackType() {\n    return StackWrap;\n  }\n  stackLimits(axisName, stackName) {\n    const limits = super.stackLimits(axisName, stackName);\n    return limits;\n  }\n  createPoint(data, fields) {\n    const {\n      categoryIx,\n      series,\n      seriesIx\n    } = fields;\n    const {\n      options,\n      children\n    } = this;\n    const isStacked = options.isStacked;\n    const value = this.pointValue(data);\n    let pointOptions = this.pointOptions(series, seriesIx);\n    const labelOptions = pointOptions.labels;\n    if (isStacked) {\n      if (labelOptions.position === OUTSIDE_END) {\n        labelOptions.position = INSIDE_END;\n      }\n    }\n    pointOptions.isStacked = isStacked;\n    let color = data.fields.color || series.color;\n    if (value < 0 && pointOptions.negativeColor) {\n      color = pointOptions.negativeColor;\n    }\n    pointOptions = this.evalPointOptions(pointOptions, value, fields);\n    if (isFunction(series.color)) {\n      color = pointOptions.color;\n    }\n    const pointType = this.pointType();\n    const point = new pointType(value, pointOptions);\n    point.color = color;\n    let cluster = children[categoryIx];\n    if (!cluster) {\n      const clusterType = this.clusterType();\n      cluster = new clusterType({\n        vertical: options.invertAxes,\n        gap: options.gap,\n        spacing: options.spacing,\n        rtl: !options.invertAxes && (this.chartService || {}).rtl\n      });\n      this.append(cluster);\n    }\n    if (isStacked) {\n      const stackWrap = this.getStackWrap(series, cluster);\n      stackWrap.append(point);\n    } else {\n      cluster.append(point);\n    }\n    return point;\n  }\n  getStackWrap(series, cluster) {\n    const stack = series.stack;\n    const stackGroup = stack ? stack.group || stack : stack;\n    const wraps = cluster.children;\n    let stackWrap;\n    if (typeof stackGroup === STRING) {\n      for (let i = 0; i < wraps.length; i++) {\n        if (wraps[i]._stackGroup === stackGroup) {\n          stackWrap = wraps[i];\n          break;\n        }\n      }\n    } else {\n      stackWrap = wraps[0];\n    }\n    if (!stackWrap) {\n      const stackType = this.stackType();\n      stackWrap = new stackType({\n        vertical: !this.options.invertAxes\n      });\n      stackWrap._stackGroup = stackGroup;\n      cluster.append(stackWrap);\n    }\n    return stackWrap;\n  }\n  categorySlot(categoryAxis, categoryIx, valueAxis) {\n    const options = this.options;\n    const categorySlot = categoryAxis.getSlot(categoryIx);\n    const startValue = valueAxis.startValue();\n    if (options.isStacked) {\n      const zeroSlot = valueAxis.getSlot(startValue, startValue, true);\n      const stackAxis = options.invertAxes ? X : Y;\n      categorySlot[stackAxis + 1] = categorySlot[stackAxis + 2] = zeroSlot[stackAxis + 1];\n    }\n    return categorySlot;\n  }\n  reflowCategories(categorySlots) {\n    const children = this.children;\n    const childrenLength = children.length;\n    for (let i = 0; i < childrenLength; i++) {\n      children[i].reflow(categorySlots[i]);\n    }\n  }\n  createAnimation() {\n    this._setAnimationOptions();\n    super.createAnimation();\n    if (anyHasZIndex(this.options.series)) {\n      this._setChildrenAnimation();\n    }\n  }\n  _setChildrenAnimation() {\n    const points = this.points;\n    for (let idx = 0; idx < points.length; idx++) {\n      const point = points[idx];\n      const pointVisual = point.visual;\n      if (pointVisual && defined(pointVisual.options.zIndex)) {\n        point.options.animation = this.options.animation;\n        point.createAnimation();\n      }\n    }\n  }\n  _setAnimationOptions() {\n    const options = this.options;\n    const animation = options.animation || {};\n    let origin;\n    if (options.isStacked) {\n      const valueAxis = this.seriesValueAxis(options.series[0]);\n      origin = valueAxis.getSlot(valueAxis.startValue());\n    } else {\n      origin = this.categoryAxis.getSlot(0);\n    }\n    animation.origin = new geom.Point(origin.x1, origin.y1);\n    animation.vertical = !options.invertAxes;\n  }\n}\nsetDefaultOptions(BarChart, {\n  animation: {\n    type: BAR\n  }\n});\nexport default BarChart;","map":{"version":3,"names":["geometry","geom","Bar","CategoricalChart","ClusterLayout","StackWrap","BAR","OUTSIDE_END","INSIDE_END","anyHasZIndex","STRING","X","Y","defined","isFunction","setDefaultOptions","BarChart","render","updateStackRange","pointType","clusterType","stackType","stackLimits","axisName","stackName","limits","createPoint","data","fields","categoryIx","series","seriesIx","options","children","isStacked","value","pointValue","pointOptions","labelOptions","labels","position","color","negativeColor","evalPointOptions","point","cluster","vertical","invertAxes","gap","spacing","rtl","chartService","append","stackWrap","getStackWrap","stack","stackGroup","group","wraps","i","length","_stackGroup","categorySlot","categoryAxis","valueAxis","getSlot","startValue","zeroSlot","stackAxis","reflowCategories","categorySlots","childrenLength","reflow","createAnimation","_setAnimationOptions","_setChildrenAnimation","points","idx","pointVisual","visual","zIndex","animation","origin","seriesValueAxis","Point","x1","y1","type"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/bar-chart/bar-chart.js"],"sourcesContent":["import { geometry as geom } from '@progress/kendo-drawing';\n\nimport Bar from './bar';\n\nimport CategoricalChart from '../categorical-chart';\nimport ClusterLayout from '../layout/cluster-layout';\nimport StackWrap from '../layout/stack-wrap';\nimport { BAR, OUTSIDE_END, INSIDE_END } from '../constants';\n\nimport anyHasZIndex from '../utils/any-has-z-index';\n\nimport { STRING, X, Y } from '../../common/constants';\nimport { defined, isFunction, setDefaultOptions } from '../../common';\n\nclass BarChart extends CategoricalChart {\n\n    render() {\n        super.render();\n        this.updateStackRange();\n    }\n\n    pointType() {\n        return Bar;\n    }\n\n    clusterType() {\n        return ClusterLayout;\n    }\n\n    stackType() {\n        return StackWrap;\n    }\n\n    stackLimits(axisName, stackName) {\n        const limits = super.stackLimits(axisName, stackName);\n\n        return limits;\n    }\n\n    createPoint(data, fields) {\n        const { categoryIx, series, seriesIx } = fields;\n        const { options, children } = this;\n        const isStacked = options.isStacked;\n        const value = this.pointValue(data);\n        let pointOptions = this.pointOptions(series, seriesIx);\n\n        const labelOptions = pointOptions.labels;\n        if (isStacked) {\n            if (labelOptions.position === OUTSIDE_END) {\n                labelOptions.position = INSIDE_END;\n            }\n        }\n\n        pointOptions.isStacked = isStacked;\n\n        let color = data.fields.color || series.color;\n        if (value < 0 && pointOptions.negativeColor) {\n            color = pointOptions.negativeColor;\n        }\n\n        pointOptions = this.evalPointOptions(pointOptions, value, fields);\n        if (isFunction(series.color)) {\n            color = pointOptions.color;\n        }\n\n        const pointType = this.pointType();\n        const point = new pointType(value, pointOptions);\n        point.color = color;\n\n        let cluster = children[categoryIx];\n        if (!cluster) {\n            const clusterType = this.clusterType();\n            cluster = new clusterType({\n                vertical: options.invertAxes,\n                gap: options.gap,\n                spacing: options.spacing,\n                rtl: !options.invertAxes && (this.chartService || {}).rtl\n            });\n            this.append(cluster);\n        }\n\n        if (isStacked) {\n            const stackWrap = this.getStackWrap(series, cluster);\n            stackWrap.append(point);\n        } else {\n            cluster.append(point);\n        }\n\n        return point;\n    }\n\n    getStackWrap(series, cluster) {\n        const stack = series.stack;\n        const stackGroup = stack ? stack.group || stack : stack;\n        const wraps = cluster.children;\n        let stackWrap;\n\n        if (typeof stackGroup === STRING) {\n            for (let i = 0; i < wraps.length; i++) {\n                if (wraps[i]._stackGroup === stackGroup) {\n                    stackWrap = wraps[i];\n                    break;\n                }\n            }\n        } else {\n            stackWrap = wraps[0];\n        }\n\n        if (!stackWrap) {\n            const stackType = this.stackType();\n            stackWrap = new stackType({\n                vertical: !this.options.invertAxes\n            });\n            stackWrap._stackGroup = stackGroup;\n            cluster.append(stackWrap);\n        }\n\n        return stackWrap;\n    }\n\n    categorySlot(categoryAxis, categoryIx, valueAxis) {\n        const options = this.options;\n        const categorySlot = categoryAxis.getSlot(categoryIx);\n        const startValue = valueAxis.startValue();\n\n        if (options.isStacked) {\n            const zeroSlot = valueAxis.getSlot(startValue, startValue, true);\n            const stackAxis = options.invertAxes ? X : Y;\n            categorySlot[stackAxis + 1] = categorySlot[stackAxis + 2] = zeroSlot[stackAxis + 1];\n        }\n\n        return categorySlot;\n    }\n\n    reflowCategories(categorySlots) {\n        const children = this.children;\n        const childrenLength = children.length;\n\n        for (let i = 0; i < childrenLength; i++) {\n            children[i].reflow(categorySlots[i]);\n        }\n    }\n\n    createAnimation() {\n        this._setAnimationOptions();\n        super.createAnimation();\n\n        if (anyHasZIndex(this.options.series)) {\n            this._setChildrenAnimation();\n        }\n    }\n\n    _setChildrenAnimation() {\n        const points = this.points;\n\n        for (let idx = 0; idx < points.length; idx++) {\n            const point = points[idx];\n            const pointVisual = point.visual;\n            if (pointVisual && defined(pointVisual.options.zIndex)) {\n                point.options.animation = this.options.animation;\n                point.createAnimation();\n            }\n        }\n    }\n\n    _setAnimationOptions() {\n        const options = this.options;\n        const animation = options.animation || {};\n        let origin;\n\n        if (options.isStacked) {\n            const valueAxis = this.seriesValueAxis(options.series[0]);\n            origin = valueAxis.getSlot(valueAxis.startValue());\n        } else {\n            origin = this.categoryAxis.getSlot(0);\n        }\n\n        animation.origin = new geom.Point(origin.x1, origin.y1);\n        animation.vertical = !options.invertAxes;\n    }\n}\n\nsetDefaultOptions(BarChart, {\n    animation: {\n        type: BAR\n    }\n});\n\nexport default BarChart;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}