{"ast":null,"code":"import { geometry as geom, drawing as draw } from '@progress/kendo-drawing';\nimport { Class, addClass, setDefaultOptions, deepExtend, defaultErrorHandler } from '../common';\nimport { Box } from '../core';\nimport { encodeData } from './encodings/encoding';\nimport { extend } from './utils';\nimport { surfaceSize } from '../barcode/surface-size';\nconst round = Math.round;\nconst crossPattern = [[0, 1], [1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 0], [2, 0], [2, -1], [1, -1], [1, 0]];\nconst squarePattern = [[0, 1], [1, 1], [1, 0]];\nconst QRCodeDefaults = {\n  DEFAULT_SIZE: 200,\n  QUIET_ZONE_LENGTH: 4,\n  DEFAULT_ERROR_CORRECTION_LEVEL: \"L\",\n  DEFAULT_BACKGROUND: \"#fff\",\n  DEFAULT_DARK_MODULE_COLOR: \"#000\",\n  MIN_BASE_UNIT_SIZE: 1,\n  DEFAULT_LOGO_SIZE: 7\n};\nclass QRCode extends Class {\n  constructor(element, options, errorHandler = defaultErrorHandler) {\n    super();\n    this.options = deepExtend({}, this.options, options);\n    this.element = element;\n    this.wrapper = this.element;\n    this.onError = errorHandler;\n    this._initElement();\n    this._initSurface();\n    this.setOptions(options);\n  }\n  destroy() {\n    this._destroySurface();\n  }\n  _initElement() {\n    addClass(this.element, \"k-qrcode\");\n  }\n  _initSurface() {\n    const {\n      options,\n      surface\n    } = this;\n    if (!surface || surface.options.type !== options.renderAs) {\n      this._destroySurface();\n      this._initSurfaceElement();\n      this.surface = this._createSurface();\n    }\n  }\n  _createSurface() {\n    return draw.Surface.create(this.surfaceElement, {\n      type: this.options.renderAs\n    });\n  }\n  _destroySurface() {\n    if (this.surface) {\n      this.surface.destroy();\n      this.surface = null;\n      this._destroySurfaceElement();\n    }\n  }\n  _initSurfaceElement() {\n    if (!this.surfaceElement) {\n      this.surfaceElement = document.createElement('div');\n      this.surfaceElement.style.position = \"relative\";\n      this.element.appendChild(this.surfaceElement);\n    }\n  }\n  _destroySurfaceElement() {\n    if (this.surfaceElement && this.surfaceElement.parentNode) {\n      this.surfaceElement.parentNode.removeChild(this.surfaceElement);\n      this.surfaceElement = null;\n    }\n  }\n  redraw() {\n    let size = this._getSize();\n    this.surface.clear();\n    this.surface.setSize({\n      width: size,\n      height: size\n    });\n    this.createVisual();\n    this.surface.draw(this.visual);\n  }\n  getSize() {\n    const element = this.element;\n    const elementWidth = element.clientWidth;\n    const elementHeight = element.clientHeight;\n    const size = {\n      width: 0,\n      height: 0\n    };\n    if (elementWidth > 0) {\n      size.width = elementWidth;\n    }\n    if (elementHeight) {\n      size.height = elementHeight;\n    }\n    return size;\n  }\n  _resize() {\n    this.redraw();\n  }\n  createVisual() {\n    this.visual = this._render();\n  }\n  exportVisual() {\n    return this._render();\n  }\n  _render() {\n    let value = this._value,\n      baseUnit,\n      border = this.options.border || {},\n      padding = this.options.padding || 0,\n      borderWidth = border.width || 0,\n      quietZoneSize,\n      matrix,\n      size,\n      dataSize,\n      contentSize;\n    border.width = borderWidth;\n    let visual = new draw.Group();\n    try {\n      if (value) {\n        matrix = encodeData(value, this.options.errorCorrection, this.options.encoding);\n        size = this._getSize();\n        contentSize = size - 2 * (borderWidth + padding);\n        baseUnit = this._calculateBaseUnit(contentSize, matrix.length);\n        dataSize = matrix.length * baseUnit;\n        quietZoneSize = borderWidth + padding + (contentSize - dataSize) / 2;\n        visual.append(this._renderBackground(size, border));\n        visual.append(this._renderMatrix(matrix, baseUnit, quietZoneSize));\n        if (this._hasCustomLogo()) {\n          visual.append(this._renderLogo(size, baseUnit));\n        } else if (this._isSwiss()) {\n          visual.append(this._renderSwissCode(size, baseUnit));\n        }\n      }\n    } catch (error) {\n      this.onError(error);\n    }\n    return visual;\n  }\n  _renderLogo(qrSize, baseUnit) {\n    let image;\n    let imageRect;\n    let center = round(qrSize / 2);\n    let logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);\n    let logoUrl = this.options.overlay.imageUrl;\n    let position = {\n      x: center - logoSize.width / 2,\n      y: center - logoSize.height / 2\n    };\n    imageRect = new geom.Rect(new geom.Point(position.x, position.y), new geom.Size(logoSize.width, logoSize.height));\n    image = new draw.Image(logoUrl, imageRect);\n    return image;\n  }\n  _renderSwissCode(qrSize, baseUnit) {\n    let logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);\n    logoSize = Math.max(logoSize.width, logoSize.height);\n    let crossSize = logoSize / 4;\n    let crossOffset = crossSize / 2;\n    let center = qrSize / 2;\n    let start = {};\n    let visual = new draw.Group();\n    start.x = start.y = Math.ceil(center - baseUnit - logoSize / 2);\n    visual.append(this._renderShape(start, Math.ceil(logoSize + baseUnit * 2), squarePattern, \"#fff\"));\n    start.x = start.y = center - logoSize / 2;\n    visual.append(this._renderShape(start, logoSize, squarePattern, this.options.color));\n    start.x = center + crossOffset - logoSize / 2;\n    start.y = center + crossOffset + crossSize - logoSize / 2;\n    visual.append(this._renderShape(start, crossSize, crossPattern, \"#fff\"));\n    return visual;\n  }\n  _renderShape(start, step, pattern, color) {\n    let path = new draw.MultiPath({\n      fill: {\n        color: color\n      },\n      stroke: null\n    });\n    path.moveTo(start.x, start.y);\n    for (let i = 0; i < pattern.length; i++) {\n      path.lineTo(start.x + step * pattern[i][0], start.y + step * pattern[i][1]);\n    }\n    path.close();\n    return path;\n  }\n  _getSize() {\n    let size;\n    if (this.options.size) {\n      size = parseInt(this.options.size, 10);\n    } else {\n      const element = this.element;\n      const elementSize = surfaceSize(element, this.options.renderAs);\n      const min = Math.min(elementSize.width, elementSize.height);\n      if (min > 0) {\n        size = min;\n      } else {\n        size = QRCodeDefaults.DEFAULT_SIZE;\n      }\n    }\n    return size;\n  }\n  _calculateBaseUnit(size, matrixSize) {\n    let baseUnit = Math.floor(size / matrixSize);\n    if (baseUnit < QRCodeDefaults.MIN_BASE_UNIT_SIZE) {\n      const minSize = Math.ceil(matrixSize * QRCodeDefaults.MIN_BASE_UNIT_SIZE);\n      this.onError(new Error(`Insufficient size for QR Code: the current size is ${size}px and the minimum size is ${minSize}px.`));\n    } else if (baseUnit * matrixSize >= size && baseUnit - 1 >= QRCodeDefaults.MIN_BASE_UNIT_SIZE) {\n      baseUnit--;\n    }\n    return baseUnit;\n  }\n  _renderMatrix(matrix, baseUnit, quietZoneSize) {\n    let path = new draw.MultiPath({\n      fill: {\n        color: this.options.color\n      },\n      stroke: null\n    });\n    for (let row = 0; row < matrix.length; row++) {\n      let y = quietZoneSize + row * baseUnit;\n      let column = 0;\n      while (column < matrix.length) {\n        while (matrix[row][column] === 0 && column < matrix.length) {\n          column++;\n        }\n        if (column < matrix.length) {\n          let x = column;\n          while (matrix[row][column] === 1) {\n            column++;\n          }\n          let x1 = round(quietZoneSize + x * baseUnit);\n          let y1 = round(y);\n          let x2 = round(quietZoneSize + column * baseUnit);\n          let y2 = round(y + baseUnit);\n          path.moveTo(x1, y1).lineTo(x1, y2).lineTo(x2, y2).lineTo(x2, y1).close();\n        }\n      }\n    }\n    return path;\n  }\n  _renderBackground(size, border) {\n    const box = new Box(0, 0, size, size).unpad(border.width / 2);\n    const background = draw.Path.fromRect(box.toRect(), {\n      fill: {\n        color: this.options.background\n      },\n      stroke: {\n        color: border.color,\n        width: border.width\n      }\n    });\n    return background;\n  }\n  setOptions(options) {\n    let newOptions = options || {};\n    this.options = extend(this.options, newOptions);\n    if (options.value !== undefined) {\n      this._value = String(this.options.value);\n    }\n    this._initSurface();\n    this.redraw();\n  }\n  value(value) {\n    if (value === undefined) {\n      return this._value;\n    }\n    this._value = String(value);\n    this.redraw();\n  }\n  _hasCustomLogo() {\n    return Boolean(this.options.overlay.imageUrl);\n  }\n  _isSwiss() {\n    return this.options.overlay.type === \"swiss\";\n  }\n  _getLogoSize(defautLogoSize) {\n    let width = this.options.overlay.width;\n    let height = this.options.overlay.height;\n    if (!width && !height) {\n      width = height = defautLogoSize;\n    } else if (width && !height) {\n      height = width;\n    } else if (!width && height) {\n      width = height;\n    }\n    return {\n      width: width,\n      height: height\n    };\n  }\n}\nsetDefaultOptions(QRCode, {\n  name: \"QRCode\",\n  renderAs: \"svg\",\n  encoding: \"ISO_8859_1\",\n  value: \"\",\n  errorCorrection: QRCodeDefaults.DEFAULT_ERROR_CORRECTION_LEVEL,\n  background: QRCodeDefaults.DEFAULT_BACKGROUND,\n  color: QRCodeDefaults.DEFAULT_DARK_MODULE_COLOR,\n  size: \"\",\n  padding: 0,\n  border: {\n    color: \"\",\n    width: 0\n  },\n  overlay: {\n    type: \"image\",\n    imageUrl: \"\",\n    width: 0,\n    height: 0\n  }\n});\nexport default QRCode;","map":{"version":3,"names":["geometry","geom","drawing","draw","Class","addClass","setDefaultOptions","deepExtend","defaultErrorHandler","Box","encodeData","extend","surfaceSize","round","Math","crossPattern","squarePattern","QRCodeDefaults","DEFAULT_SIZE","QUIET_ZONE_LENGTH","DEFAULT_ERROR_CORRECTION_LEVEL","DEFAULT_BACKGROUND","DEFAULT_DARK_MODULE_COLOR","MIN_BASE_UNIT_SIZE","DEFAULT_LOGO_SIZE","QRCode","constructor","element","options","errorHandler","wrapper","onError","_initElement","_initSurface","setOptions","destroy","_destroySurface","surface","type","renderAs","_initSurfaceElement","_createSurface","Surface","create","surfaceElement","_destroySurfaceElement","document","createElement","style","position","appendChild","parentNode","removeChild","redraw","size","_getSize","clear","setSize","width","height","createVisual","visual","getSize","elementWidth","clientWidth","elementHeight","clientHeight","_resize","_render","exportVisual","value","_value","baseUnit","border","padding","borderWidth","quietZoneSize","matrix","dataSize","contentSize","Group","errorCorrection","encoding","_calculateBaseUnit","length","append","_renderBackground","_renderMatrix","_hasCustomLogo","_renderLogo","_isSwiss","_renderSwissCode","error","qrSize","image","imageRect","center","logoSize","_getLogoSize","logoUrl","overlay","imageUrl","x","y","Rect","Point","Size","Image","max","crossSize","crossOffset","start","ceil","_renderShape","color","step","pattern","path","MultiPath","fill","stroke","moveTo","i","lineTo","close","parseInt","elementSize","min","matrixSize","floor","minSize","Error","row","column","x1","y1","x2","y2","box","unpad","background","Path","fromRect","toRect","newOptions","undefined","String","Boolean","defautLogoSize","name"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/qrcode/qrcode.js"],"sourcesContent":["import {\n    geometry as geom,\n    drawing as draw\n} from '@progress/kendo-drawing';\n\nimport {\n    Class,\n    addClass,\n    setDefaultOptions,\n    deepExtend,\n    defaultErrorHandler\n} from '../common';\n\nimport { Box } from '../core';\nimport { encodeData } from './encodings/encoding';\nimport { extend } from './utils';\n\nimport { surfaceSize } from '../barcode/surface-size';\n\nconst round = Math.round;\nconst crossPattern = [[0, 1], [1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 0], [2, 0], [2, -1], [1, -1], [1, 0]];\nconst squarePattern = [[0, 1], [1, 1], [1, 0]];\n\nconst QRCodeDefaults = {\n    DEFAULT_SIZE: 200,\n    QUIET_ZONE_LENGTH: 4,\n    DEFAULT_ERROR_CORRECTION_LEVEL: \"L\",\n    DEFAULT_BACKGROUND: \"#fff\",\n    DEFAULT_DARK_MODULE_COLOR: \"#000\",\n    MIN_BASE_UNIT_SIZE: 1,\n    DEFAULT_LOGO_SIZE: 7\n};\n\nclass QRCode extends Class {\n    constructor(element, options, errorHandler = defaultErrorHandler) {\n        super();\n\n        this.options = deepExtend({}, this.options, options);\n        this.element = element;\n        this.wrapper = this.element;\n        this.onError = errorHandler;\n\n        this._initElement();\n        this._initSurface();\n\n        this.setOptions(options);\n    }\n\n    destroy() {\n        this._destroySurface();\n    }\n\n    _initElement() {\n        addClass(this.element, \"k-qrcode\");\n    }\n\n    _initSurface() {\n        const { options, surface } = this;\n\n        if (!surface || surface.options.type !== options.renderAs) {\n            this._destroySurface();\n            this._initSurfaceElement();\n            this.surface = this._createSurface();\n        }\n    }\n\n    _createSurface() {\n        return draw.Surface.create(this.surfaceElement, {\n            type: this.options.renderAs\n        });\n    }\n\n    _destroySurface() {\n        if (this.surface) {\n            this.surface.destroy();\n            this.surface = null;\n            this._destroySurfaceElement();\n        }\n    }\n\n    _initSurfaceElement() {\n        if (!this.surfaceElement) {\n            this.surfaceElement = document.createElement('div');\n            this.surfaceElement.style.position = \"relative\";\n            this.element.appendChild(this.surfaceElement);\n        }\n    }\n\n    _destroySurfaceElement() {\n        if (this.surfaceElement && this.surfaceElement.parentNode) {\n            this.surfaceElement.parentNode.removeChild(this.surfaceElement);\n            this.surfaceElement = null;\n        }\n    }\n\n    redraw() {\n        let size = this._getSize();\n\n        this.surface.clear();\n\n        this.surface.setSize({\n            width: size,\n            height: size\n        });\n\n        this.createVisual();\n\n        this.surface.draw(this.visual);\n    }\n\n    getSize() {\n        const element = this.element;\n        const elementWidth = element.clientWidth;\n        const elementHeight = element.clientHeight;\n        const size = { width: 0, height: 0 };\n\n        if (elementWidth > 0) {\n            size.width = elementWidth;\n        }\n\n        if (elementHeight) {\n            size.height = elementHeight;\n        }\n\n        return size;\n    }\n\n    _resize() {\n        this.redraw();\n    }\n\n    createVisual() {\n        this.visual = this._render();\n    }\n\n    exportVisual() {\n        return this._render();\n    }\n\n    _render() {\n        let value = this._value,\n            baseUnit,\n            border = this.options.border || {},\n            padding = this.options.padding || 0,\n            borderWidth = border.width || 0,\n            quietZoneSize,\n            matrix,\n            size,\n            dataSize,\n            contentSize;\n\n        border.width = borderWidth;\n\n        let visual = new draw.Group();\n\n        try {\n            if (value) {\n                matrix = encodeData(value, this.options.errorCorrection, this.options.encoding);\n                size = this._getSize();\n                contentSize = size - 2 * (borderWidth + padding);\n                baseUnit = this._calculateBaseUnit(contentSize, matrix.length);\n                dataSize = matrix.length * baseUnit;\n                quietZoneSize = borderWidth + padding + (contentSize - dataSize) / 2;\n\n                visual.append(this._renderBackground(size, border));\n                visual.append(this._renderMatrix(matrix, baseUnit, quietZoneSize));\n\n                if (this._hasCustomLogo()) {\n                    visual.append(this._renderLogo(size, baseUnit));\n                } else if (this._isSwiss()) {\n                    visual.append(this._renderSwissCode(size, baseUnit));\n                }\n            }\n        } catch (error) {\n            this.onError(error);\n        }\n\n        return visual;\n    }\n\n    _renderLogo(qrSize, baseUnit) {\n        let image;\n        let imageRect;\n        let center = round(qrSize / 2);\n        let logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);\n        let logoUrl = this.options.overlay.imageUrl;\n        let position = {\n            x: center - logoSize.width / 2,\n            y: center - logoSize.height / 2\n        };\n\n        imageRect = new geom.Rect(\n            new geom.Point(position.x, position.y),\n            new geom.Size(logoSize.width, logoSize.height)\n        );\n\n        image = new draw.Image(logoUrl, imageRect);\n\n        return image;\n    }\n\n    _renderSwissCode(qrSize, baseUnit) {\n        let logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);\n        logoSize = Math.max(logoSize.width, logoSize.height);\n        let crossSize = logoSize / 4;\n        let crossOffset = crossSize / 2;\n        let center = qrSize / 2;\n        let start = {};\n        let visual = new draw.Group();\n\n        start.x = start.y = Math.ceil(center - baseUnit - logoSize / 2);\n        visual.append(this._renderShape(start, Math.ceil(logoSize + baseUnit * 2), squarePattern, \"#fff\"));\n\n        start.x = start.y = center - logoSize / 2;\n        visual.append(this._renderShape(start, logoSize, squarePattern, this.options.color));\n\n        start.x = center + crossOffset - logoSize / 2;\n        start.y = center + crossOffset + crossSize - logoSize / 2;\n        visual.append(this._renderShape(start, crossSize, crossPattern, \"#fff\"));\n\n        return visual;\n    }\n\n    _renderShape(start, step, pattern, color) {\n        let path = new draw.MultiPath({\n            fill: {\n                color: color\n            },\n            stroke: null\n        });\n\n        path.moveTo(start.x, start.y);\n\n        for (let i = 0; i < pattern.length; i++) {\n            path.lineTo(start.x + step * pattern[i][0], start.y + step * pattern[i][1]);\n        }\n\n        path.close();\n\n        return path;\n    }\n\n    _getSize() {\n        let size;\n\n        if (this.options.size) {\n            size = parseInt(this.options.size, 10);\n        } else {\n            const element = this.element;\n            const elementSize = surfaceSize(element, this.options.renderAs);\n            const min = Math.min(elementSize.width, elementSize.height);\n\n            if (min > 0) {\n                size = min;\n            } else {\n                size = QRCodeDefaults.DEFAULT_SIZE;\n            }\n        }\n\n        return size;\n    }\n\n    _calculateBaseUnit(size, matrixSize) {\n        let baseUnit = Math.floor(size / matrixSize);\n\n        if (baseUnit < QRCodeDefaults.MIN_BASE_UNIT_SIZE) {\n            const minSize = Math.ceil(matrixSize * QRCodeDefaults.MIN_BASE_UNIT_SIZE);\n            this.onError(new Error(\n                `Insufficient size for QR Code: the current size is ${size}px and the minimum size is ${minSize}px.`\n            ));\n        } else if (baseUnit * matrixSize >= size &&\n            baseUnit - 1 >= QRCodeDefaults.MIN_BASE_UNIT_SIZE) {\n            baseUnit--;\n        }\n\n        return baseUnit;\n    }\n\n    _renderMatrix(matrix, baseUnit, quietZoneSize) {\n        let path = new draw.MultiPath({\n            fill: {\n                color: this.options.color\n            },\n            stroke: null\n        });\n\n        for (let row = 0; row < matrix.length; row++) {\n            let y = quietZoneSize + row * baseUnit;\n            let column = 0;\n\n            while (column < matrix.length) {\n                while (matrix[row][column] === 0 && column < matrix.length) {\n                    column++;\n                }\n\n                if (column < matrix.length) {\n                    let x = column;\n                    while (matrix[row][column] === 1) {\n                        column++;\n                    }\n\n                    let x1 = round(quietZoneSize + x * baseUnit);\n                    let y1 = round(y);\n                    let x2 = round(quietZoneSize + column * baseUnit);\n                    let y2 = round(y + baseUnit);\n\n                    path.moveTo(x1, y1)\n                        .lineTo(x1, y2)\n                        .lineTo(x2, y2)\n                        .lineTo(x2, y1)\n                        .close();\n                }\n            }\n        }\n\n        return path;\n    }\n\n    _renderBackground(size, border) {\n        const box = new Box(0, 0, size, size).unpad(border.width / 2);\n        const background = draw.Path.fromRect(box.toRect(), {\n            fill: {\n                color: this.options.background\n            },\n            stroke: {\n                color: border.color,\n                width: border.width\n            }\n        });\n\n        return background;\n    }\n\n    setOptions(options) {\n        let newOptions = options || {};\n        this.options = extend(this.options, newOptions);\n\n        if (options.value !== undefined) {\n            this._value = String(this.options.value);\n        }\n\n        this._initSurface();\n        this.redraw();\n    }\n\n    value(value) {\n        if (value === undefined) {\n            return this._value;\n        }\n\n        this._value = String(value);\n\n        this.redraw();\n    }\n\n    _hasCustomLogo() {\n        return Boolean(this.options.overlay.imageUrl);\n    }\n\n    _isSwiss() {\n        return this.options.overlay.type === \"swiss\";\n    }\n\n    _getLogoSize(defautLogoSize) {\n        let width = this.options.overlay.width;\n        let height = this.options.overlay.height;\n\n        if (!width && !height) {\n            width = height = defautLogoSize;\n        } else if (width && !height) {\n            height = width;\n        } else if (!width && height) {\n            width = height;\n        }\n\n        return {\n            width: width,\n            height: height\n        };\n    }\n}\n\nsetDefaultOptions(QRCode, {\n    name: \"QRCode\",\n    renderAs: \"svg\",\n    encoding: \"ISO_8859_1\",\n    value: \"\",\n    errorCorrection: QRCodeDefaults.DEFAULT_ERROR_CORRECTION_LEVEL,\n    background: QRCodeDefaults.DEFAULT_BACKGROUND,\n    color: QRCodeDefaults.DEFAULT_DARK_MODULE_COLOR,\n    size: \"\",\n    padding: 0,\n    border: {\n        color: \"\",\n        width: 0\n    },\n    overlay: {\n        type: \"image\",\n        imageUrl: \"\",\n        width: 0,\n        height: 0\n    }\n});\n\nexport default QRCode;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}