{"ast":null,"code":"import { drawing as draw, geometry } from '@progress/kendo-drawing';\nimport PieSegment from './pie-segment';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport { ChartElement, Ring, Box, Point } from '../../core';\nimport { OUTSIDE_END, FADEIN, COLUMN } from '../constants';\nimport { bindSegments, evalOptions } from '../utils';\nimport { CIRCLE, RIGHT, CENTER } from '../../common/constants';\nimport { deepExtend, defined, find, isFunction, last, round, setDefaultOptions, valueOrDefault } from '../../common';\nconst PIE_SECTOR_ANIM_DELAY = 70;\nclass PieChart extends ChartElement {\n  constructor(plotArea, options) {\n    super(options);\n    this.plotArea = plotArea;\n    this.chartService = plotArea.chartService;\n    this.points = [];\n    this.legendItems = [];\n    this.render();\n  }\n  render() {\n    this.traverseDataPoints(this.addValue.bind(this));\n  }\n  traverseDataPoints(callback) {\n    const {\n      options,\n      plotArea: {\n        options: {\n          seriesColors = []\n        }\n      }\n    } = this;\n    const colorsCount = seriesColors.length;\n    const series = options.series;\n    const seriesCount = series.length;\n    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      const data = currentSeries.data;\n      const {\n        total,\n        points,\n        count\n      } = bindSegments(currentSeries);\n      const anglePerValue = 360 / total;\n      let constantAngle;\n      if (!isFinite(anglePerValue)) {\n        constantAngle = 360 / count;\n      }\n      let currentAngle;\n      if (defined(currentSeries.startAngle)) {\n        currentAngle = currentSeries.startAngle;\n      } else {\n        currentAngle = options.startAngle;\n      }\n      if (seriesIx !== seriesCount - 1) {\n        if (currentSeries.labels.position === OUTSIDE_END) {\n          currentSeries.labels.position = CENTER;\n        }\n      }\n      for (let i = 0; i < points.length; i++) {\n        const pointData = points[i];\n        if (!pointData) {\n          continue;\n        }\n        const {\n          fields,\n          value,\n          visible\n        } = pointData;\n        const angle = value !== 0 ? constantAngle || value * anglePerValue : 0;\n        const explode = data.length !== 1 && Boolean(fields.explode);\n        if (!isFunction(currentSeries.color)) {\n          currentSeries.color = fields.color || seriesColors[i % colorsCount];\n        }\n        callback(value, new Ring(null, 0, 0, currentAngle, angle), {\n          owner: this,\n          category: defined(fields.category) ? fields.category : \"\",\n          index: i,\n          series: currentSeries,\n          seriesIx: seriesIx,\n          dataItem: data[i],\n          percentage: total !== 0 ? value / total : 0,\n          explode: explode,\n          visibleInLegend: fields.visibleInLegend,\n          visible: visible,\n          zIndex: seriesCount - seriesIx,\n          animationDelay: this.animationDelay(i, seriesIx, seriesCount)\n        });\n        if (visible !== false) {\n          currentAngle += angle;\n        }\n      }\n    }\n  }\n  evalSegmentOptions(options, value, fields) {\n    const series = fields.series;\n    evalOptions(options, {\n      value: value,\n      series: series,\n      dataItem: fields.dataItem,\n      category: fields.category,\n      percentage: fields.percentage\n    }, {\n      defaults: series._defaults,\n      excluded: [\"data\", \"content\", \"template\", \"visual\", \"toggle\"]\n    });\n  }\n  addValue(value, sector, fields) {\n    const segmentOptions = deepExtend({}, fields.series, {\n      index: fields.index\n    });\n    this.evalSegmentOptions(segmentOptions, value, fields);\n    this.createLegendItem(value, segmentOptions, fields);\n    if (fields.visible === false) {\n      return;\n    }\n    const segment = new PieSegment(value, sector, segmentOptions);\n    Object.assign(segment, fields);\n    this.append(segment);\n    this.points.push(segment);\n  }\n  reflow(targetBox) {\n    const {\n      options,\n      points,\n      seriesConfigs = []\n    } = this;\n    const count = points.length;\n    const box = targetBox.clone();\n    const space = 5;\n    const minWidth = Math.min(box.width(), box.height());\n    const halfMinWidth = minWidth / 2;\n    const defaultPadding = minWidth - minWidth * 0.85;\n    const newBox = new Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);\n    const newBoxCenter = newBox.center();\n    const boxCenter = box.center();\n    const seriesCount = options.series.length;\n    const leftSideLabels = [];\n    const rightSideLabels = [];\n    let padding = valueOrDefault(options.padding, defaultPadding);\n    this.targetBox = targetBox;\n    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n    newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);\n    const radius = halfMinWidth - padding;\n    const center = new Point(radius + newBox.x1 + padding, radius + newBox.y1 + padding);\n    for (let i = 0; i < count; i++) {\n      const segment = points[i];\n      const sector = segment.sector;\n      const seriesIndex = segment.seriesIx;\n      sector.radius = radius;\n      sector.center = center;\n      if (seriesConfigs.length) {\n        const seriesConfig = seriesConfigs[seriesIndex];\n        sector.innerRadius = seriesConfig.innerRadius;\n        sector.radius = seriesConfig.radius;\n      }\n      if (seriesIndex === seriesCount - 1 && segment.explode) {\n        sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());\n      }\n      segment.reflow(newBox);\n      const label = segment.label;\n      if (label) {\n        if (label.options.position === OUTSIDE_END) {\n          if (seriesIndex === seriesCount - 1) {\n            if (label.orientation === RIGHT) {\n              rightSideLabels.push(label);\n            } else {\n              leftSideLabels.push(label);\n            }\n          }\n        }\n      }\n    }\n    if (leftSideLabels.length > 0) {\n      leftSideLabels.sort(this.labelComparator(true));\n      this.leftLabelsReflow(leftSideLabels);\n    }\n    if (rightSideLabels.length > 0) {\n      rightSideLabels.sort(this.labelComparator(false));\n      this.rightLabelsReflow(rightSideLabels);\n    }\n    this.box = newBox;\n  }\n  leftLabelsReflow(labels) {\n    const distances = this.distanceBetweenLabels(labels);\n    this.distributeLabels(distances, labels);\n  }\n  rightLabelsReflow(labels) {\n    const distances = this.distanceBetweenLabels(labels);\n    this.distributeLabels(distances, labels);\n  }\n  distanceBetweenLabels(labels) {\n    const segment = last(this.points);\n    const sector = segment.sector;\n    const count = labels.length - 1;\n    const lr = sector.radius + segment.options.labels.distance;\n    const distances = [];\n    let firstBox = labels[0].box;\n    let distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));\n    distances.push(distance);\n    for (let i = 0; i < count; i++) {\n      const secondBox = labels[i + 1].box;\n      firstBox = labels[i].box;\n      distance = round(secondBox.y1 - firstBox.y2);\n      distances.push(distance);\n    }\n    distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);\n    distances.push(distance);\n    return distances;\n  }\n  distributeLabels(distances, labels) {\n    const count = distances.length;\n    let left, right, remaining;\n    for (let i = 0; i < count; i++) {\n      remaining = -distances[i];\n      left = right = i;\n      while (remaining > 0 && (left >= 0 || right < count)) {\n        remaining = this._takeDistance(distances, i, --left, remaining);\n        remaining = this._takeDistance(distances, i, ++right, remaining);\n      }\n    }\n    this.reflowLabels(distances, labels);\n  }\n  _takeDistance(distances, anchor, position, amount) {\n    let result = amount;\n    if (distances[position] > 0) {\n      const available = Math.min(distances[position], result);\n      result -= available;\n      distances[position] -= available;\n      distances[anchor] += available;\n    }\n    return result;\n  }\n  reflowLabels(distances, labels) {\n    const segment = last(this.points);\n    const sector = segment.sector;\n    const labelOptions = segment.options.labels;\n    const labelsCount = labels.length;\n    const labelDistance = labelOptions.distance;\n    let boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();\n    let boxX;\n    distances[0] += 2;\n    for (let i = 0; i < labelsCount; i++) {\n      const label = labels[i];\n      const box = label.box;\n      boxY += distances[i];\n      boxX = this.hAlignLabel(box.x2, sector.clone().expand(labelDistance), boxY, boxY + box.height(), label.orientation === RIGHT);\n      if (label.orientation === RIGHT) {\n        if (labelOptions.align !== CIRCLE) {\n          boxX = sector.radius + sector.center.x + labelDistance;\n        }\n        label.reflow(new Box(boxX + box.width(), boxY, boxX, boxY));\n      } else {\n        if (labelOptions.align !== CIRCLE) {\n          boxX = sector.center.x - sector.radius - labelDistance;\n        }\n        label.reflow(new Box(boxX - box.width(), boxY, boxX, boxY));\n      }\n      boxY += box.height();\n    }\n  }\n  createVisual() {\n    const {\n      options: {\n        connectors\n      },\n      points\n    } = this;\n    const count = points.length;\n    const space = 4;\n    super.createVisual();\n    this._connectorLines = [];\n    for (let i = 0; i < count; i++) {\n      const segment = points[i];\n      const {\n        sector,\n        label\n      } = segment;\n      const angle = sector.middle();\n      const connectorsColor = (segment.options.connectors || {}).color || connectors.color;\n      if (label) {\n        const connectorLine = new draw.Path({\n          stroke: {\n            color: connectorsColor,\n            width: connectors.width\n          },\n          animation: {\n            type: FADEIN,\n            delay: segment.animationDelay\n          }\n        });\n        if (label.options.position === OUTSIDE_END) {\n          const box = label.box;\n          const centerPoint = sector.center;\n          let start = sector.point(angle);\n          let middle = new Point(box.x1, box.center().y);\n          let sr, end, crossing;\n          start = sector.clone().expand(connectors.padding).point(angle);\n          connectorLine.moveTo(start.x, start.y);\n          // TODO: Extract into a method to remove duplication\n          if (label.orientation === RIGHT) {\n            end = new Point(box.x1 - connectors.padding, box.center().y);\n            crossing = intersection(centerPoint, start, middle, end);\n            middle = new Point(end.x - space, end.y);\n            crossing = crossing || middle;\n            crossing.x = Math.min(crossing.x, middle.x);\n            if (this.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {\n              sr = sector.center.x + sector.radius + space;\n              if (segment.options.labels.align !== COLUMN) {\n                if (sr < middle.x) {\n                  connectorLine.lineTo(sr, start.y);\n                } else {\n                  connectorLine.lineTo(start.x + space * 2, start.y);\n                }\n              } else {\n                connectorLine.lineTo(sr, start.y);\n              }\n              connectorLine.lineTo(middle.x, end.y);\n            } else {\n              crossing.y = end.y;\n              connectorLine.lineTo(crossing.x, crossing.y);\n            }\n          } else {\n            end = new Point(box.x2 + connectors.padding, box.center().y);\n            crossing = intersection(centerPoint, start, middle, end);\n            middle = new Point(end.x + space, end.y);\n            crossing = crossing || middle;\n            crossing.x = Math.max(crossing.x, middle.x);\n            if (this.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {\n              sr = sector.center.x - sector.radius - space;\n              if (segment.options.labels.align !== COLUMN) {\n                if (sr > middle.x) {\n                  connectorLine.lineTo(sr, start.y);\n                } else {\n                  connectorLine.lineTo(start.x - space * 2, start.y);\n                }\n              } else {\n                connectorLine.lineTo(sr, start.y);\n              }\n              connectorLine.lineTo(middle.x, end.y);\n            } else {\n              crossing.y = end.y;\n              connectorLine.lineTo(crossing.x, crossing.y);\n            }\n          }\n          connectorLine.lineTo(end.x, end.y);\n          this._connectorLines.push(connectorLine);\n          this.visual.append(connectorLine);\n        }\n      }\n    }\n  }\n  renderVisual() {\n    super.renderVisual();\n    if (find(this.options.series, options => options.autoFit)) {\n      const targetBox = this.targetBox;\n      const pieCenter = this.box.center();\n      const bbox = this.visual.bbox();\n      if (!bbox) {\n        return;\n      }\n      const bboxBottom = bbox.bottomRight();\n      const scale = Math.min((pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y), (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y), (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x), (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x));\n      if (scale < 1) {\n        this.visual.transform(geometry.transform().scale(scale, scale, [pieCenter.x, pieCenter.y]));\n      }\n    }\n  }\n  labelComparator(reverse) {\n    const reverseValue = reverse ? -1 : 1;\n    return function (a, b) {\n      const first = (a.parent.sector.middle() + 270) % 360;\n      const second = (b.parent.sector.middle() + 270) % 360;\n      return (first - second) * reverseValue;\n    };\n  }\n  hAlignLabel(originalX, sector, y1, y2, direction) {\n    const {\n      radius,\n      center: {\n        x: cx,\n        y: cy\n      }\n    } = sector;\n    const t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));\n    if (t > radius) {\n      return originalX;\n    }\n    return cx + Math.sqrt(radius * radius - t * t) * (direction ? 1 : -1);\n  }\n  pointInCircle(point, center, radius) {\n    return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);\n  }\n  formatPointValue(point, format) {\n    return this.chartService.format.auto(format, point.value);\n  }\n  animationDelay(categoryIndex) {\n    return categoryIndex * PIE_SECTOR_ANIM_DELAY;\n  }\n  stackRoot() {\n    return this;\n  }\n}\nfunction intersection(a1, a2, b1, b2) {\n  const uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n  const ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n  let result;\n  if (ub !== 0) {\n    const ua = uat / ub;\n    result = new Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y));\n  }\n  return result;\n}\nsetDefaultOptions(PieChart, {\n  startAngle: 90,\n  connectors: {\n    width: 2,\n    color: \"#939393\",\n    padding: 8\n  },\n  inactiveItems: {\n    markers: {},\n    labels: {}\n  }\n});\ndeepExtend(PieChart.prototype, PieChartMixin);\nPieChart.prototype.isStackRoot = true;\nexport default PieChart;","map":{"version":3,"names":["drawing","draw","geometry","PieSegment","PieChartMixin","ChartElement","Ring","Box","Point","OUTSIDE_END","FADEIN","COLUMN","bindSegments","evalOptions","CIRCLE","RIGHT","CENTER","deepExtend","defined","find","isFunction","last","round","setDefaultOptions","valueOrDefault","PIE_SECTOR_ANIM_DELAY","PieChart","constructor","plotArea","options","chartService","points","legendItems","render","traverseDataPoints","addValue","bind","callback","seriesColors","colorsCount","length","series","seriesCount","seriesIx","currentSeries","data","total","count","anglePerValue","constantAngle","isFinite","currentAngle","startAngle","labels","position","i","pointData","fields","value","visible","angle","explode","Boolean","color","owner","category","index","dataItem","percentage","visibleInLegend","zIndex","animationDelay","evalSegmentOptions","defaults","_defaults","excluded","sector","segmentOptions","createLegendItem","segment","Object","assign","append","push","reflow","targetBox","seriesConfigs","box","clone","space","minWidth","Math","min","width","height","halfMinWidth","defaultPadding","newBox","x1","y1","newBoxCenter","center","boxCenter","leftSideLabels","rightSideLabels","padding","translate","x","y","radius","seriesIndex","seriesConfig","innerRadius","setRadius","point","middle","label","orientation","sort","labelComparator","leftLabelsReflow","rightLabelsReflow","distances","distanceBetweenLabels","distributeLabels","lr","distance","firstBox","secondBox","y2","left","right","remaining","_takeDistance","reflowLabels","anchor","amount","result","available","labelOptions","labelsCount","labelDistance","boxY","boxX","hAlignLabel","x2","expand","align","createVisual","connectors","_connectorLines","connectorsColor","connectorLine","Path","stroke","animation","type","delay","centerPoint","start","sr","end","crossing","moveTo","intersection","pointInCircle","lineTo","max","visual","renderVisual","autoFit","pieCenter","bbox","bboxBottom","bottomRight","scale","origin","transform","reverse","reverseValue","a","b","first","parent","second","originalX","direction","cx","cy","t","abs","sqrt","pow","formatPointValue","format","auto","categoryIndex","stackRoot","a1","a2","b1","b2","uat","ub","ua","inactiveItems","markers","prototype","isStackRoot"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/pie-chart/pie-chart.js"],"sourcesContent":["import { drawing as draw, geometry } from '@progress/kendo-drawing';\n\nimport PieSegment from './pie-segment';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport { ChartElement, Ring, Box, Point } from '../../core';\n\nimport { OUTSIDE_END, FADEIN, COLUMN } from '../constants';\nimport { bindSegments, evalOptions } from '../utils';\n\nimport { CIRCLE, RIGHT, CENTER } from '../../common/constants';\nimport { deepExtend, defined, find, isFunction, last, round, setDefaultOptions, valueOrDefault } from '../../common';\n\nconst PIE_SECTOR_ANIM_DELAY = 70;\n\nclass PieChart extends ChartElement {\n    constructor(plotArea, options) {\n        super(options);\n\n        this.plotArea = plotArea;\n        this.chartService = plotArea.chartService;\n        this.points = [];\n        this.legendItems = [];\n        this.render();\n    }\n\n    render() {\n        this.traverseDataPoints(this.addValue.bind(this));\n    }\n\n    traverseDataPoints(callback) {\n        const { options, plotArea: { options: { seriesColors = [] } } } = this;\n        const colorsCount = seriesColors.length;\n        const series = options.series;\n        const seriesCount = series.length;\n\n        for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n            const currentSeries = series[seriesIx];\n            const data = currentSeries.data;\n            const { total, points, count } = bindSegments(currentSeries);\n            const anglePerValue = 360 / total;\n            let constantAngle;\n            if (!isFinite(anglePerValue)) {\n                constantAngle = 360 / count;\n            }\n            let currentAngle;\n\n            if (defined(currentSeries.startAngle)) {\n                currentAngle = currentSeries.startAngle;\n            } else {\n                currentAngle = options.startAngle;\n            }\n\n            if (seriesIx !== seriesCount - 1) {\n                if (currentSeries.labels.position === OUTSIDE_END) {\n                    currentSeries.labels.position = CENTER;\n                }\n            }\n\n            for (let i = 0; i < points.length; i++) {\n                const pointData = points[i];\n                if (!pointData) {\n                    continue;\n                }\n\n                const { fields, value, visible } = pointData;\n                const angle = value !== 0 ? (constantAngle || (value * anglePerValue)) : 0;\n                const explode = data.length !== 1 && Boolean(fields.explode);\n\n                if (!isFunction(currentSeries.color)) {\n                    currentSeries.color = fields.color || seriesColors[i % colorsCount];\n                }\n\n                callback(value, new Ring(null, 0, 0, currentAngle, angle), {\n                    owner: this,\n                    category: defined(fields.category) ? fields.category : \"\",\n                    index: i,\n                    series: currentSeries,\n                    seriesIx: seriesIx,\n                    dataItem: data[i],\n                    percentage: total !== 0 ? value / total : 0,\n                    explode: explode,\n                    visibleInLegend: fields.visibleInLegend,\n                    visible: visible,\n                    zIndex: seriesCount - seriesIx,\n                    animationDelay: this.animationDelay(i, seriesIx, seriesCount)\n                });\n\n                if (visible !== false) {\n                    currentAngle += angle;\n                }\n            }\n        }\n    }\n\n    evalSegmentOptions(options, value, fields) {\n        const series = fields.series;\n\n        evalOptions(options, {\n            value: value,\n            series: series,\n            dataItem: fields.dataItem,\n            category: fields.category,\n            percentage: fields.percentage\n        }, { defaults: series._defaults, excluded: [ \"data\", \"content\", \"template\", \"visual\", \"toggle\" ] });\n    }\n\n    addValue(value, sector, fields) {\n        const segmentOptions = deepExtend({}, fields.series, { index: fields.index });\n        this.evalSegmentOptions(segmentOptions, value, fields);\n\n        this.createLegendItem(value, segmentOptions, fields);\n\n        if (fields.visible === false) {\n            return;\n        }\n\n        const segment = new PieSegment(value, sector, segmentOptions);\n        Object.assign(segment, fields);\n        this.append(segment);\n        this.points.push(segment);\n    }\n\n    reflow(targetBox) {\n        const { options, points, seriesConfigs = [] } = this;\n        const count = points.length;\n        const box = targetBox.clone();\n        const space = 5;\n        const minWidth = Math.min(box.width(), box.height());\n        const halfMinWidth = minWidth / 2;\n        const defaultPadding = minWidth - minWidth * 0.85;\n        const newBox = new Box(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);\n        const newBoxCenter = newBox.center();\n        const boxCenter = box.center();\n        const seriesCount = options.series.length;\n        const leftSideLabels = [];\n        const rightSideLabels = [];\n        let padding = valueOrDefault(options.padding, defaultPadding);\n\n        this.targetBox = targetBox;\n\n        padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;\n        newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);\n\n        const radius = halfMinWidth - padding;\n        const center = new Point(\n            radius + newBox.x1 + padding,\n            radius + newBox.y1 + padding\n        );\n\n        for (let i = 0; i < count; i++) {\n            const segment = points[i];\n            const sector = segment.sector;\n            const seriesIndex = segment.seriesIx;\n            sector.radius = radius;\n            sector.center = center;\n\n            if (seriesConfigs.length) {\n                const seriesConfig = seriesConfigs[seriesIndex];\n                sector.innerRadius = seriesConfig.innerRadius;\n                sector.radius = seriesConfig.radius;\n            }\n\n            if (seriesIndex === seriesCount - 1 && segment.explode) {\n                sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());\n            }\n\n            segment.reflow(newBox);\n\n            const label = segment.label;\n            if (label) {\n                if (label.options.position === OUTSIDE_END) {\n                    if (seriesIndex === seriesCount - 1) {\n                        if (label.orientation === RIGHT) {\n                            rightSideLabels.push(label);\n                        } else {\n                            leftSideLabels.push(label);\n                        }\n                    }\n                }\n            }\n        }\n\n        if (leftSideLabels.length > 0) {\n            leftSideLabels.sort(this.labelComparator(true));\n            this.leftLabelsReflow(leftSideLabels);\n        }\n\n        if (rightSideLabels.length > 0) {\n            rightSideLabels.sort(this.labelComparator(false));\n            this.rightLabelsReflow(rightSideLabels);\n        }\n\n        this.box = newBox;\n    }\n\n    leftLabelsReflow(labels) {\n        const distances = this.distanceBetweenLabels(labels);\n\n        this.distributeLabels(distances, labels);\n    }\n\n    rightLabelsReflow(labels) {\n        const distances = this.distanceBetweenLabels(labels);\n\n        this.distributeLabels(distances, labels);\n    }\n\n    distanceBetweenLabels(labels) {\n        const segment = last(this.points);\n        const sector = segment.sector;\n        const count = labels.length - 1;\n        const lr = sector.radius + segment.options.labels.distance;\n        const distances = [];\n        let firstBox = labels[0].box;\n        let distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));\n\n        distances.push(distance);\n\n        for (let i = 0; i < count; i++) {\n            const secondBox = labels[i + 1].box;\n\n            firstBox = labels[i].box;\n            distance = round(secondBox.y1 - firstBox.y2);\n            distances.push(distance);\n        }\n        distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);\n        distances.push(distance);\n\n        return distances;\n    }\n\n    distributeLabels(distances, labels) {\n        const count = distances.length;\n        let left, right, remaining;\n\n        for (let i = 0; i < count; i++) {\n            remaining = -distances[i];\n            left = right = i;\n\n            while (remaining > 0 && (left >= 0 || right < count)) {\n                remaining = this._takeDistance(distances, i, --left, remaining);\n                remaining = this._takeDistance(distances, i, ++right, remaining);\n            }\n        }\n\n        this.reflowLabels(distances, labels);\n    }\n\n    _takeDistance(distances, anchor, position, amount) {\n        let result = amount;\n        if (distances[position] > 0) {\n            const available = Math.min(distances[position], result);\n            result -= available;\n            distances[position] -= available;\n            distances[anchor] += available;\n        }\n\n        return result;\n    }\n\n    reflowLabels(distances, labels) {\n        const segment = last(this.points);\n        const sector = segment.sector;\n        const labelOptions = segment.options.labels;\n        const labelsCount = labels.length;\n        const labelDistance = labelOptions.distance;\n        let boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();\n        let boxX;\n\n        distances[0] += 2;\n        for (let i = 0; i < labelsCount; i++) {\n            const label = labels[i];\n            const box = label.box;\n\n            boxY += distances[i];\n            boxX = this.hAlignLabel(\n                box.x2,\n                sector.clone().expand(labelDistance),\n                boxY,\n                boxY + box.height(),\n                label.orientation === RIGHT);\n\n            if (label.orientation === RIGHT) {\n                if (labelOptions.align !== CIRCLE) {\n                    boxX = sector.radius + sector.center.x + labelDistance;\n                }\n                label.reflow(new Box(boxX + box.width(), boxY, boxX, boxY));\n            } else {\n                if (labelOptions.align !== CIRCLE) {\n                    boxX = sector.center.x - sector.radius - labelDistance;\n                }\n                label.reflow(new Box(boxX - box.width(), boxY, boxX, boxY));\n            }\n\n            boxY += box.height();\n        }\n    }\n\n    createVisual() {\n        const { options: { connectors }, points } = this;\n        const count = points.length;\n        const space = 4;\n\n        super.createVisual();\n\n        this._connectorLines = [];\n\n        for (let i = 0; i < count; i++) {\n            const segment = points[i];\n            const { sector, label } = segment;\n            const angle = sector.middle();\n            const connectorsColor = (segment.options.connectors || {}).color || connectors.color;\n\n            if (label) {\n                const connectorLine = new draw.Path({\n                    stroke: {\n                        color: connectorsColor,\n                        width: connectors.width\n                    },\n                    animation: {\n                        type: FADEIN,\n                        delay: segment.animationDelay\n                    }\n                });\n\n                if (label.options.position === OUTSIDE_END) {\n                    const box = label.box;\n                    const centerPoint = sector.center;\n                    let start = sector.point(angle);\n                    let middle = new Point(box.x1, box.center().y);\n                    let sr, end, crossing;\n\n                    start = sector.clone().expand(connectors.padding).point(angle);\n                    connectorLine.moveTo(start.x, start.y);\n                    // TODO: Extract into a method to remove duplication\n                    if (label.orientation === RIGHT) {\n                        end = new Point(box.x1 - connectors.padding, box.center().y);\n                        crossing = intersection(centerPoint, start, middle, end);\n                        middle = new Point(end.x - space, end.y);\n                        crossing = crossing || middle;\n                        crossing.x = Math.min(crossing.x, middle.x);\n\n                        if (this.pointInCircle(crossing, sector.center, sector.radius + space) ||\n                            crossing.x < sector.center.x) {\n                            sr = sector.center.x + sector.radius + space;\n                            if (segment.options.labels.align !== COLUMN) {\n                                if (sr < middle.x) {\n                                    connectorLine.lineTo(sr, start.y);\n                                } else {\n                                    connectorLine.lineTo(start.x + space * 2, start.y);\n                                }\n                            } else {\n                                connectorLine.lineTo(sr, start.y);\n                            }\n                            connectorLine.lineTo(middle.x, end.y);\n                        } else {\n                            crossing.y = end.y;\n                            connectorLine.lineTo(crossing.x, crossing.y);\n                        }\n                    } else {\n                        end = new Point(box.x2 + connectors.padding, box.center().y);\n                        crossing = intersection(centerPoint, start, middle, end);\n                        middle = new Point(end.x + space, end.y);\n                        crossing = crossing || middle;\n                        crossing.x = Math.max(crossing.x, middle.x);\n\n                        if (this.pointInCircle(crossing, sector.center, sector.radius + space) ||\n                            crossing.x > sector.center.x) {\n                            sr = sector.center.x - sector.radius - space;\n                            if (segment.options.labels.align !== COLUMN) {\n                                if (sr > middle.x) {\n                                    connectorLine.lineTo(sr, start.y);\n                                } else {\n                                    connectorLine.lineTo(start.x - space * 2, start.y);\n                                }\n                            } else {\n                                connectorLine.lineTo(sr, start.y);\n                            }\n                            connectorLine.lineTo(middle.x, end.y);\n                        } else {\n                            crossing.y = end.y;\n                            connectorLine.lineTo(crossing.x, crossing.y);\n                        }\n                    }\n\n                    connectorLine.lineTo(end.x, end.y);\n\n                    this._connectorLines.push(connectorLine);\n                    this.visual.append(connectorLine);\n                }\n            }\n        }\n    }\n\n    renderVisual() {\n        super.renderVisual();\n\n        if (find(this.options.series, options => options.autoFit)) {\n            const targetBox = this.targetBox;\n            const pieCenter = this.box.center();\n            const bbox = this.visual.bbox();\n            if (!bbox) {\n                return;\n            }\n\n            const bboxBottom = bbox.bottomRight();\n\n            const scale = Math.min(\n                (pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y),\n                (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y),\n                (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x),\n                (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x)\n            );\n\n            if (scale < 1) {\n                this.visual.transform(geometry.transform().scale(scale, scale, [ pieCenter.x, pieCenter.y ]));\n            }\n        }\n    }\n\n    labelComparator(reverse) {\n        const reverseValue = reverse ? -1 : 1;\n\n        return function(a, b) {\n            const first = (a.parent.sector.middle() + 270) % 360;\n            const second = (b.parent.sector.middle() + 270) % 360;\n            return (first - second) * reverseValue;\n        };\n    }\n\n    hAlignLabel(originalX, sector, y1, y2, direction) {\n        const { radius, center: { x: cx, y: cy } } = sector;\n        const t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));\n\n        if (t > radius) {\n            return originalX;\n        }\n\n        return cx + Math.sqrt((radius * radius) - (t * t)) * (direction ? 1 : -1);\n    }\n\n    pointInCircle(point, center, radius) {\n        return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);\n    }\n\n    formatPointValue(point, format) {\n        return this.chartService.format.auto(format, point.value);\n    }\n\n    animationDelay(categoryIndex) {\n        return categoryIndex * PIE_SECTOR_ANIM_DELAY;\n    }\n\n    stackRoot() {\n        return this;\n    }\n}\n\nfunction intersection(a1, a2, b1, b2) {\n    const uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);\n    const ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);\n\n    let result;\n    if (ub !== 0) {\n        const ua = (uat / ub);\n\n        result = new Point(\n            a1.x + ua * (a2.x - a1.x),\n            a1.y + ua * (a2.y - a1.y)\n        );\n    }\n\n    return result;\n}\n\nsetDefaultOptions(PieChart, {\n    startAngle: 90,\n    connectors: {\n        width: 2,\n        color: \"#939393\",\n        padding: 8\n    },\n    inactiveItems: {\n        markers: {},\n        labels: {}\n    }\n});\n\ndeepExtend(PieChart.prototype, PieChartMixin);\n\nPieChart.prototype.isStackRoot = true;\n\nexport default PieChart;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}