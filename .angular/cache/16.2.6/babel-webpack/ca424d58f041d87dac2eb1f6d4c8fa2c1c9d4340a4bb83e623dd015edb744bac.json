{"ast":null,"code":"import OptionsStore from '../core/options-store';\nimport Rect from '../geometry/rect';\nimport Matrix from '../geometry/matrix';\nimport createTransform from '../geometry/transform';\nimport toMatrix from '../geometry/to-matrix';\nimport HasObservers from '../core/has-observers';\nimport { defined, definitionId, isTransparent, valueOrDefault } from '../util';\nclass Element extends HasObservers {\n  get nodeType() {\n    return \"Rect\";\n  }\n  constructor(options) {\n    super();\n    this._initOptions(options);\n  }\n  _initOptions(options = {}) {\n    const {\n      clip,\n      transform\n    } = options;\n    if (transform) {\n      options.transform = createTransform(transform);\n    }\n    if (clip && !clip.id) {\n      clip.id = definitionId();\n    }\n    this.options = new OptionsStore(options);\n    this.options.addObserver(this);\n  }\n  transform(value) {\n    if (defined(value)) {\n      this.options.set(\"transform\", createTransform(value));\n    } else {\n      return this.options.get(\"transform\");\n    }\n  }\n  parentTransform() {\n    let element = this;\n    let parentMatrix;\n    while (element.parent) {\n      element = element.parent;\n      let transformation = element.transform();\n      if (transformation) {\n        parentMatrix = transformation.matrix().multiplyCopy(parentMatrix || Matrix.unit());\n      }\n    }\n    if (parentMatrix) {\n      return createTransform(parentMatrix);\n    }\n  }\n  currentTransform(parentTransform = this.parentTransform()) {\n    const elementTransform = this.transform();\n    const elementMatrix = toMatrix(elementTransform);\n    let parentMatrix = toMatrix(parentTransform);\n    let combinedMatrix;\n    if (elementMatrix && parentMatrix) {\n      combinedMatrix = parentMatrix.multiplyCopy(elementMatrix);\n    } else {\n      combinedMatrix = elementMatrix || parentMatrix;\n    }\n    if (combinedMatrix) {\n      return createTransform(combinedMatrix);\n    }\n  }\n  visible(value) {\n    if (defined(value)) {\n      this.options.set(\"visible\", value);\n      return this;\n    }\n    return this.options.get(\"visible\") !== false;\n  }\n  clip(value) {\n    const options = this.options;\n    if (defined(value)) {\n      if (value && !value.id) {\n        value.id = definitionId();\n      }\n      options.set(\"clip\", value);\n      return this;\n    }\n    return options.get(\"clip\");\n  }\n  opacity(value) {\n    if (defined(value)) {\n      this.options.set(\"opacity\", value);\n      return this;\n    }\n    return valueOrDefault(this.options.get(\"opacity\"), 1);\n  }\n  className(value) {\n    if (defined(value)) {\n      this.options.set(\"className\", value);\n      return this;\n    }\n    return this.options.get(\"className\");\n  }\n  clippedBBox(transformation) {\n    const bbox = this._clippedBBox(transformation);\n    if (bbox) {\n      const clip = this.clip();\n      return clip ? Rect.intersect(bbox, clip.bbox(transformation)) : bbox;\n    }\n  }\n  containsPoint(point, parentTransform) {\n    if (this.visible()) {\n      const transform = this.currentTransform(parentTransform);\n      let transformedPoint = point;\n      if (transform) {\n        transformedPoint = point.transformCopy(transform.matrix().invert());\n      }\n      return this._hasFill() && this._containsPoint(transformedPoint) || this._isOnPath && this._hasStroke() && this._isOnPath(transformedPoint);\n    }\n    return false;\n  }\n  _hasFill() {\n    const fill = this.options.fill;\n    return fill && !isTransparent(fill.color);\n  }\n  _hasStroke() {\n    const stroke = this.options.stroke;\n    return stroke && stroke.width > 0 && !isTransparent(stroke.color);\n  }\n  _clippedBBox(transformation) {\n    return this.bbox(transformation);\n  }\n}\nexport default Element;","map":{"version":3,"names":["OptionsStore","Rect","Matrix","createTransform","toMatrix","HasObservers","defined","definitionId","isTransparent","valueOrDefault","Element","nodeType","constructor","options","_initOptions","clip","transform","id","addObserver","value","set","get","parentTransform","element","parentMatrix","parent","transformation","matrix","multiplyCopy","unit","currentTransform","elementTransform","elementMatrix","combinedMatrix","visible","opacity","className","clippedBBox","bbox","_clippedBBox","intersect","containsPoint","point","transformedPoint","transformCopy","invert","_hasFill","_containsPoint","_isOnPath","_hasStroke","fill","color","stroke","width"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-drawing/dist/es2015/shapes/element.js"],"sourcesContent":["import OptionsStore from '../core/options-store';\nimport Rect from '../geometry/rect';\nimport Matrix from '../geometry/matrix';\nimport createTransform from '../geometry/transform';\nimport toMatrix from '../geometry/to-matrix';\nimport HasObservers from '../core/has-observers';\nimport { defined, definitionId, isTransparent, valueOrDefault } from '../util';\n\nclass Element extends HasObservers {\n    get nodeType() {\n        return \"Rect\";\n    }\n\n    constructor(options) {\n        super();\n\n        this._initOptions(options);\n    }\n\n    _initOptions(options = {}) {\n        const { clip, transform } = options;\n\n        if (transform) {\n            options.transform = createTransform(transform);\n        }\n\n        if (clip && !clip.id) {\n            clip.id = definitionId();\n        }\n\n        this.options = new OptionsStore(options);\n        this.options.addObserver(this);\n    }\n\n    transform(value) {\n        if (defined(value)) {\n            this.options.set(\"transform\", createTransform(value));\n        } else {\n            return this.options.get(\"transform\");\n        }\n    }\n\n    parentTransform() {\n        let element = this;\n        let parentMatrix;\n\n        while (element.parent) {\n            element = element.parent;\n            let transformation = element.transform();\n            if (transformation) {\n                parentMatrix = transformation.matrix().multiplyCopy(parentMatrix || Matrix.unit());\n            }\n        }\n\n        if (parentMatrix) {\n            return createTransform(parentMatrix);\n        }\n    }\n\n    currentTransform(parentTransform = this.parentTransform()) {\n        const elementTransform = this.transform();\n        const elementMatrix = toMatrix(elementTransform);\n\n        let parentMatrix = toMatrix(parentTransform);\n        let combinedMatrix;\n\n        if (elementMatrix && parentMatrix) {\n            combinedMatrix = parentMatrix.multiplyCopy(elementMatrix);\n        } else {\n            combinedMatrix = elementMatrix || parentMatrix;\n        }\n\n        if (combinedMatrix) {\n            return createTransform(combinedMatrix);\n        }\n    }\n\n    visible(value) {\n        if (defined(value)) {\n            this.options.set(\"visible\", value);\n            return this;\n        }\n\n        return this.options.get(\"visible\") !== false;\n    }\n\n    clip(value) {\n        const options = this.options;\n        if (defined(value)) {\n            if (value && !value.id) {\n                value.id = definitionId();\n            }\n            options.set(\"clip\", value);\n            return this;\n        }\n\n        return options.get(\"clip\");\n    }\n\n    opacity(value) {\n        if (defined(value)) {\n            this.options.set(\"opacity\", value);\n            return this;\n        }\n\n        return valueOrDefault(this.options.get(\"opacity\"), 1);\n    }\n\n    className(value) {\n        if (defined(value)) {\n            this.options.set(\"className\", value);\n            return this;\n        }\n\n        return this.options.get(\"className\");\n    }\n\n    clippedBBox(transformation) {\n        const bbox = this._clippedBBox(transformation);\n        if (bbox) {\n            const clip = this.clip();\n            return clip ? Rect.intersect(bbox, clip.bbox(transformation)) : bbox;\n        }\n    }\n\n    containsPoint(point, parentTransform) {\n        if (this.visible()) {\n            const transform = this.currentTransform(parentTransform);\n            let transformedPoint = point;\n            if (transform) {\n                transformedPoint = point.transformCopy(transform.matrix().invert());\n            }\n            return (this._hasFill() && this._containsPoint(transformedPoint)) || (this._isOnPath && this._hasStroke() && this._isOnPath(transformedPoint));\n        }\n        return false;\n    }\n\n    _hasFill() {\n        const fill = this.options.fill;\n        return fill && !isTransparent(fill.color);\n    }\n\n    _hasStroke() {\n        const stroke = this.options.stroke;\n        return stroke && stroke.width > 0 && !isTransparent(stroke.color);\n    }\n\n    _clippedBBox(transformation) {\n        return this.bbox(transformation);\n    }\n}\n\nexport default Element;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}