{"ast":null,"code":"import { isPresent, isString } from './utils';\nimport { composeSortDescriptors } from './sorting/sort-array.operator';\nimport { groupBy, normalizeGroups } from './grouping/group.operators';\nimport { normalizeFilters } from './filtering/filter.operators';\nimport { compileFilter } from './filtering/filter-expression.factory';\nimport { exec, skip, take, filter, concat } from './transducers';\nimport { getter } from './accessor';\nimport { compose } from './funcs';\n/**\n * Orders the specified array according to the provided sort descriptors.\n *\n * @param {T[]} data - The data to be sorted.\n * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.\n * @returns {T[]} - The sorted data.\n *\n * @example\n * ```ts\n * import { orderBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = orderBy(data, [{ field: \"name\", dir: \"asc\" }]);\n * ```\n */\nexport const orderBy = (data, descriptors) => {\n  if (descriptors.some(x => isPresent(x.dir) || isPresent(x.compare))) {\n    data = data.slice(0);\n    const comparer = composeSortDescriptors(descriptors);\n    data.sort(comparer);\n  }\n  return data;\n};\nconst defaultComparer = (a, b) => a === b;\nconst normalizeComparer = comparer => {\n  if (isString(comparer)) {\n    const accessor = getter(comparer);\n    comparer = (a, b) => accessor(a) === accessor(b);\n  }\n  return comparer;\n};\nconst _distinct = (data, comparer) => data.filter((x, idx, xs) => xs.findIndex(comparer.bind(null, x)) === idx);\n/**\n * Reduces the provided array so it contains only unique values.\n *\n * @param {T[]} data - The array that will be reduced.\n * @param {(Comparer | string)} comparer - An optional custom comparer function or the field name that will be used for comparison.\n * @returns {T[]} - The reduced data.\n *\n * @example\n * ```ts\n * import { distinct } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = distinct(data, \"subcategory\");\n *\n * // output:\n * // result => [\n * //     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n * //     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" }\n * // ];\n * ```\n */\nexport const distinct = (data, comparer = defaultComparer) => _distinct(data, normalizeComparer(comparer));\n/**\n * @hidden\n */\nexport const count = (data, predicate) => {\n  let counter = 0;\n  for (let idx = 0, length = data.length; idx < length; idx++) {\n    if (predicate(data[idx])) {\n      counter++;\n    }\n  }\n  return counter;\n};\n/**\n * @hidden\n */\nexport const limit = (data, predicate) => {\n  if (predicate) {\n    return data.filter(predicate);\n  }\n  return data;\n};\n/**\n * Applies the specified operation descriptors to the data.\n *\n * @param {T[]} data - The data to be processed.\n * @param {State} state - The operation descriptors that will be applied to the data.\n * @returns {DataResult} - The processed data.\n *\n * @example\n * ```ts\n *\n * const result = process(data, {\n *     skip: 10,\n *     take: 20,\n *     group: [{\n *       field: 'category.categoryName',\n *             aggregates: [\n *                   { aggregate: \"sum\", field: \"unitPrice\" },\n *                   { aggregate: \"sum\", field: \"unitsInStock\" }\n *             ]\n *       }],\n *     sort: [{ field: 'productName', dir: 'desc' }],\n *     filter: {\n *         logic: \"or\",\n *         filters: [\n *           { field: \"discontinued\", operator: \"eq\", value: true },\n *           { field: \"unitPrice\", operator: \"lt\", value: 22 }\n *         ]\n *     }\n * });\n *\n * ```\n */\nexport const process = (data, state) => {\n  const {\n    skip: skipCount,\n    take: takeCount,\n    filter: filterDescriptor,\n    sort,\n    group\n  } = state;\n  const sortDescriptors = [...normalizeGroups(group || []), ...(sort || [])];\n  if (sortDescriptors.length) {\n    data = orderBy(data, sortDescriptors);\n  }\n  const hasFilters = isPresent(filterDescriptor) && filter.length;\n  const hasGroups = isPresent(group) && group.length;\n  if (!hasFilters && !hasGroups) {\n    return {\n      data: takeCount ? data.slice(skipCount, skipCount + takeCount) : data,\n      total: data.length\n    };\n  }\n  let total;\n  const transformers = [];\n  let predicate;\n  if (hasFilters) {\n    predicate = compileFilter(normalizeFilters(filterDescriptor));\n    total = count(data, predicate);\n    transformers.push(filter(predicate));\n  } else {\n    total = data.length;\n  }\n  if (isPresent(skipCount) && isPresent(takeCount)) {\n    transformers.push(skip(skipCount));\n    transformers.push(take(takeCount));\n  }\n  if (transformers.length) {\n    const transform = compose(...transformers);\n    const result = hasGroups ? groupBy(data, group, transform, limit(data, predicate)) : exec(transform(concat), [], data);\n    return {\n      data: result,\n      total: total\n    };\n  }\n  return {\n    data: hasGroups ? groupBy(data, group) : data,\n    total: total\n  };\n};","map":{"version":3,"names":["isPresent","isString","composeSortDescriptors","groupBy","normalizeGroups","normalizeFilters","compileFilter","exec","skip","take","filter","concat","getter","compose","orderBy","data","descriptors","some","x","dir","compare","slice","comparer","sort","defaultComparer","a","b","normalizeComparer","accessor","_distinct","idx","xs","findIndex","bind","distinct","count","predicate","counter","length","limit","process","state","skipCount","takeCount","filterDescriptor","group","sortDescriptors","hasFilters","hasGroups","total","transformers","push","transform","result"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-data-query/dist/es2015/array.operators.js"],"sourcesContent":["import { isPresent, isString } from './utils';\nimport { composeSortDescriptors } from './sorting/sort-array.operator';\nimport { groupBy, normalizeGroups } from './grouping/group.operators';\nimport { normalizeFilters } from './filtering/filter.operators';\nimport { compileFilter } from './filtering/filter-expression.factory';\nimport { exec, skip, take, filter, concat } from './transducers';\nimport { getter } from './accessor';\nimport { compose } from './funcs';\n/**\n * Orders the specified array according to the provided sort descriptors.\n *\n * @param {T[]} data - The data to be sorted.\n * @param {SortDescriptor[]} descriptors - The descriptors by which the data will be sorted.\n * @returns {T[]} - The sorted data.\n *\n * @example\n * ```ts\n * import { orderBy } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = orderBy(data, [{ field: \"name\", dir: \"asc\" }]);\n * ```\n */\nexport const orderBy = (data, descriptors) => {\n    if (descriptors.some(x => isPresent(x.dir) || isPresent(x.compare))) {\n        data = data.slice(0);\n        const comparer = composeSortDescriptors(descriptors);\n        data.sort(comparer);\n    }\n    return data;\n};\nconst defaultComparer = (a, b) => a === b;\nconst normalizeComparer = (comparer) => {\n    if (isString(comparer)) {\n        const accessor = getter(comparer);\n        comparer = (a, b) => accessor(a) === accessor(b);\n    }\n    return comparer;\n};\nconst _distinct = (data, comparer) => data.filter((x, idx, xs) => xs.findIndex(comparer.bind(null, x)) === idx);\n/**\n * Reduces the provided array so it contains only unique values.\n *\n * @param {T[]} data - The array that will be reduced.\n * @param {(Comparer | string)} comparer - An optional custom comparer function or the field name that will be used for comparison.\n * @returns {T[]} - The reduced data.\n *\n * @example\n * ```ts\n * import { distinct } from '@progress/kendo-data-query';\n *\n * const data = [\n *     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n *     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" },\n *     { name: \"Beef\", category: \"Food\", subcategory: \"Meat\" }\n * ];\n *\n * const result = distinct(data, \"subcategory\");\n *\n * // output:\n * // result => [\n * //     { name: \"Pork\", category: \"Food\", subcategory: \"Meat\" },\n * //     { name: \"Pepper\", category: \"Food\", subcategory: \"Vegetables\" }\n * // ];\n * ```\n */\nexport const distinct = (data, comparer = defaultComparer) => _distinct(data, normalizeComparer(comparer));\n/**\n * @hidden\n */\nexport const count = (data, predicate) => {\n    let counter = 0;\n    for (let idx = 0, length = data.length; idx < length; idx++) {\n        if (predicate(data[idx])) {\n            counter++;\n        }\n    }\n    return counter;\n};\n/**\n * @hidden\n */\nexport const limit = (data, predicate) => {\n    if (predicate) {\n        return data.filter(predicate);\n    }\n    return data;\n};\n/**\n * Applies the specified operation descriptors to the data.\n *\n * @param {T[]} data - The data to be processed.\n * @param {State} state - The operation descriptors that will be applied to the data.\n * @returns {DataResult} - The processed data.\n *\n * @example\n * ```ts\n *\n * const result = process(data, {\n *     skip: 10,\n *     take: 20,\n *     group: [{\n *       field: 'category.categoryName',\n *             aggregates: [\n *                   { aggregate: \"sum\", field: \"unitPrice\" },\n *                   { aggregate: \"sum\", field: \"unitsInStock\" }\n *             ]\n *       }],\n *     sort: [{ field: 'productName', dir: 'desc' }],\n *     filter: {\n *         logic: \"or\",\n *         filters: [\n *           { field: \"discontinued\", operator: \"eq\", value: true },\n *           { field: \"unitPrice\", operator: \"lt\", value: 22 }\n *         ]\n *     }\n * });\n *\n * ```\n */\nexport const process = (data, state) => {\n    const { skip: skipCount, take: takeCount, filter: filterDescriptor, sort, group } = state;\n    const sortDescriptors = [...normalizeGroups(group || []), ...sort || []];\n    if (sortDescriptors.length) {\n        data = orderBy(data, sortDescriptors);\n    }\n    const hasFilters = isPresent(filterDescriptor) && filter.length;\n    const hasGroups = isPresent(group) && group.length;\n    if (!hasFilters && !hasGroups) {\n        return {\n            data: takeCount ? data.slice(skipCount, skipCount + takeCount) : data,\n            total: data.length\n        };\n    }\n    let total;\n    const transformers = [];\n    let predicate;\n    if (hasFilters) {\n        predicate = compileFilter(normalizeFilters(filterDescriptor));\n        total = count(data, predicate);\n        transformers.push(filter(predicate));\n    }\n    else {\n        total = data.length;\n    }\n    if (isPresent(skipCount) && isPresent(takeCount)) {\n        transformers.push(skip(skipCount));\n        transformers.push(take(takeCount));\n    }\n    if (transformers.length) {\n        const transform = compose(...transformers);\n        const result = hasGroups ?\n            groupBy(data, group, transform, limit(data, predicate)) :\n            exec(transform(concat), [], data);\n        return { data: result, total: total };\n    }\n    return {\n        data: hasGroups ? groupBy(data, group) : data,\n        total: total\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}