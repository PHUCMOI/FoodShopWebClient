{"ast":null,"code":"import Axis from './axis';\nimport AxisLabel from './axis-label';\nimport { BLACK, COORD_PRECISION, DEFAULT_PRECISION, X, Y } from '../common/constants';\nimport { defined, isNumber, last, limitValue, round, setDefaultOptions, valueOrDefault, HashMap } from '../common';\nimport { dateEquals } from '../date-utils';\nconst MIN_CATEGORY_POINTS_RANGE = 0.01;\nconst MIN_CATEGORY_RANGE = 0.1;\nfunction indexOf(value, arr) {\n  if (value instanceof Date) {\n    const length = arr.length;\n    for (let idx = 0; idx < length; idx++) {\n      if (dateEquals(arr[idx], value)) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n  return arr.indexOf(value);\n}\nclass CategoryAxis extends Axis {\n  initFields() {\n    this._ticks = {};\n  }\n  categoriesHash() {\n    return \"\";\n  }\n  clone() {\n    const copy = new CategoryAxis(Object.assign({}, this.options, {\n      categories: this.options.srcCategories\n    }), this.chartService);\n    copy.createLabels();\n    return copy;\n  }\n  initUserOptions(options) {\n    const categories = options.categories || [];\n    const definedMin = defined(options.min);\n    const definedMax = defined(options.max);\n    options.srcCategories = options.categories = categories;\n    if ((definedMin || definedMax) && categories.length) {\n      const min = definedMin ? Math.floor(options.min) : 0;\n      let max;\n      if (definedMax) {\n        max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\n      } else {\n        max = categories.length;\n      }\n      options.categories = options.categories.slice(min, max);\n    }\n    return options;\n  }\n  rangeIndices() {\n    const options = this.options;\n    const length = options.categories.length || 1;\n    const min = isNumber(options.min) ? options.min % 1 : 0;\n    let max;\n    if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\n      max = length - (1 - options.max % 1);\n    } else {\n      max = length - (options.justified ? 1 : 0);\n    }\n    return {\n      min: min,\n      max: max\n    };\n  }\n  range() {\n    const options = this.options;\n    const min = isNumber(options.min) ? options.min : 0;\n    const max = isNumber(options.max) ? options.max : this.totalRange().max;\n    return {\n      min: min,\n      max: max\n    };\n  }\n  roundedRange() {\n    return this.range();\n  }\n  totalRange() {\n    const options = this.options;\n    return {\n      min: 0,\n      max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0)\n    };\n  }\n  scaleOptions() {\n    const {\n      min,\n      max\n    } = this.rangeIndices();\n    const lineBox = this.lineBox();\n    const size = this.options.vertical ? lineBox.height() : lineBox.width();\n    const scale = size / (max - min || 1);\n    return {\n      scale: scale * (this.options.reverse ? -1 : 1),\n      box: lineBox,\n      min: min,\n      max: max\n    };\n  }\n  arrangeLabels() {\n    super.arrangeLabels();\n    this.hideOutOfRangeLabels();\n  }\n  hideOutOfRangeLabels() {\n    const {\n      box,\n      labels\n    } = this;\n    if (labels.length > 0) {\n      const valueAxis = this.options.vertical ? Y : X;\n      const start = box[valueAxis + 1];\n      const end = box[valueAxis + 2];\n      const firstLabel = labels[0];\n      const lastLabel = last(labels);\n      if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\n        firstLabel.options.visible = false;\n      }\n      if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\n        lastLabel.options.visible = false;\n      }\n    }\n  }\n  getMajorTickPositions() {\n    return this.getTicks().majorTicks;\n  }\n  getMinorTickPositions() {\n    return this.getTicks().minorTicks;\n  }\n  getLabelsTickPositions() {\n    return this.getTicks().labelTicks;\n  }\n  tickIndices(stepSize) {\n    const {\n      min,\n      max\n    } = this.rangeIndices();\n    const limit = Math.ceil(max);\n    let current = Math.floor(min);\n    const indices = [];\n    while (current <= limit) {\n      indices.push(current);\n      current += stepSize;\n    }\n    return indices;\n  }\n  getTickPositions(stepSize) {\n    const {\n      vertical,\n      reverse\n    } = this.options;\n    const {\n      scale,\n      box,\n      min\n    } = this.scaleOptions();\n    const pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];\n    const indices = this.tickIndices(stepSize);\n    const positions = [];\n    for (let idx = 0; idx < indices.length; idx++) {\n      positions.push(pos + round(scale * (indices[idx] - min), COORD_PRECISION));\n    }\n    return positions;\n  }\n  getTicks() {\n    const options = this.options;\n    const cache = this._ticks;\n    const range = this.rangeIndices();\n    const lineBox = this.lineBox();\n    const hash = lineBox.getHash() + range.min + \",\" + range.max + options.reverse + options.justified;\n    if (cache._hash !== hash) {\n      const hasMinor = options.minorTicks.visible || options.minorGridLines.visible;\n      cache._hash = hash;\n      cache.labelTicks = this.getTickPositions(1);\n      cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);\n      cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];\n    }\n    return cache;\n  }\n  filterOutOfRangePositions(positions, lineBox) {\n    if (!positions.length) {\n      return positions;\n    }\n    const axis = this.options.vertical ? Y : X;\n    const inRange = position => lineBox[axis + 1] <= position && position <= lineBox[axis + 2];\n    const end = positions.length - 1;\n    let startIndex = 0;\n    while (!inRange(positions[startIndex]) && startIndex <= end) {\n      startIndex++;\n    }\n    let endIndex = end;\n    while (!inRange(positions[endIndex]) && endIndex >= 0) {\n      endIndex--;\n    }\n    return positions.slice(startIndex, endIndex + 1);\n  }\n  lineInfo() {\n    const {\n      vertical,\n      reverse\n    } = this.options;\n    const lineBox = this.lineBox();\n    const lineSize = vertical ? lineBox.height() : lineBox.width();\n    const axis = vertical ? Y : X;\n    const axisDir = reverse ? -1 : 1;\n    const startEdge = axisDir === 1 ? 1 : 2;\n    const axisOrigin = axis + startEdge.toString();\n    const lineStart = lineBox[axisOrigin];\n    return {\n      axis,\n      axisOrigin,\n      axisDir,\n      lineBox,\n      lineSize,\n      lineStart\n    };\n  }\n  lineDir() {\n    /*\n     *  Category axis line direction:\n     *    * Vertical: down.\n     *    * Horizontal: right.\n     */\n\n    const {\n      reverse\n    } = this.options;\n    return reverse ? -1 : 1;\n  }\n\n  // TODO: Rename to slotBox, valueSlot, slotByIndex?\n  getSlot(from, to, limit) {\n    const options = this.options;\n    const {\n      reverse,\n      justified\n    } = options;\n    const {\n      scale,\n      box,\n      min\n    } = this.scaleOptions();\n    const {\n      axis: valueAxis,\n      lineStart\n    } = this.lineInfo();\n    const slotBox = box.clone();\n    const singleSlot = !defined(to);\n    const start = valueOrDefault(from, 0);\n    let end = valueOrDefault(to, start);\n    end = Math.max(end - 1, start);\n\n    // Fixes transient bug caused by iOS 6.0 JIT\n    // (one can never be too sure)\n    end = Math.max(start, end);\n    let p1 = lineStart + (start - min) * scale;\n    let p2 = lineStart + (end + 1 - min) * scale;\n    if (singleSlot && justified) {\n      p2 = p1;\n    }\n    if (limit) {\n      p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);\n      p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);\n    }\n    slotBox[valueAxis + 1] = reverse ? p2 : p1;\n    slotBox[valueAxis + 2] = reverse ? p1 : p2;\n    return slotBox;\n  }\n  limitSlot(slot) {\n    const vertical = this.options.vertical;\n    const valueAxis = vertical ? Y : X;\n    const lineBox = this.lineBox();\n    const limittedSlot = slot.clone();\n    limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n    limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n    return limittedSlot;\n  }\n  slot(from, to, limit) {\n    const min = Math.floor(this.options.min || 0);\n    let start = from;\n    let end = to;\n    if (typeof start === \"string\") {\n      start = this.categoryIndex(start);\n    } else if (isNumber(start)) {\n      start -= min;\n    }\n    if (typeof end === \"string\") {\n      end = this.categoryIndex(end);\n    } else if (isNumber(end)) {\n      end -= min;\n    }\n    return super.slot(start, end, limit);\n  }\n  pointCategoryIndex(point) {\n    const {\n      reverse,\n      justified,\n      vertical\n    } = this.options;\n    const valueAxis = vertical ? Y : X;\n    const {\n      scale,\n      box,\n      min,\n      max\n    } = this.scaleOptions();\n    const startValue = reverse ? max : min;\n    const lineStart = box[valueAxis + 1];\n    const lineEnd = box[valueAxis + 2];\n    const pos = point[valueAxis];\n    if (pos < lineStart || pos > lineEnd) {\n      return null;\n    }\n    let value = startValue + (pos - lineStart) / scale;\n    const diff = value % 1;\n    if (justified) {\n      value = Math.round(value);\n    } else if (diff === 0 && value > 0) {\n      value--;\n    }\n    return Math.floor(value);\n  }\n  getCategory(point) {\n    const index = this.pointCategoryIndex(point);\n    if (index === null) {\n      return null;\n    }\n    return this.options.categories[index];\n  }\n  categoryIndex(value) {\n    return this.totalIndex(value) - Math.floor(this.options.min || 0);\n  }\n  categoryAt(index, total) {\n    const options = this.options;\n    return (total ? options.srcCategories : options.categories)[index];\n  }\n  categoriesCount() {\n    return (this.options.categories || []).length;\n  }\n  translateRange(delta) {\n    const options = this.options;\n    const lineBox = this.lineBox();\n    const size = options.vertical ? lineBox.height() : lineBox.width();\n    const range = options.categories.length;\n    const scale = size / range;\n    const offset = round(delta / scale, DEFAULT_PRECISION);\n    return {\n      min: offset,\n      max: range + offset\n    };\n  }\n  scaleRange(scale, cursor) {\n    const position = Math.abs(this.pointOffset(cursor));\n    const rangeIndices = this.limitedRangeIndices();\n    const range = rangeIndices.max - rangeIndices.min;\n    const delta = this.scaleToDelta(scale, range);\n    const minDelta = position * delta;\n    const maxDelta = (1 - position) * delta;\n    const min = rangeIndices.min + minDelta;\n    let max = rangeIndices.max - maxDelta;\n    if (max - min < MIN_CATEGORY_RANGE) {\n      max = min + MIN_CATEGORY_RANGE;\n    }\n    return {\n      min: min,\n      max: max\n    };\n  }\n  zoomRange(scale, cursor) {\n    const {\n      min: totalMin,\n      max: totalMax\n    } = this.totalRange();\n    const range = this.scaleRange(scale, cursor);\n    return {\n      min: limitValue(range.min, totalMin, totalMax),\n      max: limitValue(range.max, totalMin, totalMax)\n    };\n  }\n  labelsCount() {\n    const labelsRange = this.labelsRange();\n    return labelsRange.max - labelsRange.min;\n  }\n  labelsRange() {\n    const options = this.options;\n    const {\n      justified,\n      labels: labelOptions\n    } = options;\n    let {\n      min,\n      max\n    } = this.limitedRangeIndices(true);\n    const start = Math.floor(min);\n    if (!justified) {\n      min = Math.floor(min);\n      max = Math.ceil(max);\n    } else {\n      min = Math.ceil(min);\n      max = Math.floor(max);\n    }\n    let skip;\n    if (min > labelOptions.skip) {\n      skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\n    } else {\n      skip = labelOptions.skip;\n    }\n    return {\n      min: skip - start,\n      max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\n    };\n  }\n  createAxisLabel(index, labelOptions, labelContext) {\n    const options = this.options;\n    const dataItem = options.dataItems ? options.dataItems[index] : null;\n    const category = valueOrDefault(options.categories[index], \"\");\n    labelContext.dataItem = dataItem;\n    const text = this.axisLabelText(category, labelOptions, labelContext);\n    return new AxisLabel(category, text, index, dataItem, labelOptions);\n  }\n  shouldRenderNote(value) {\n    const range = this.limitedRangeIndices();\n    return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\n  }\n  noteSlot(value) {\n    const options = this.options;\n    const index = value - Math.floor(options.min || 0);\n    return this.getSlot(index);\n  }\n  arrangeNotes() {\n    super.arrangeNotes();\n    this.hideOutOfRangeNotes();\n  }\n  hideOutOfRangeNotes() {\n    const {\n      notes,\n      box\n    } = this;\n    if (notes && notes.length) {\n      const valueAxis = this.options.vertical ? Y : X;\n      const start = box[valueAxis + 1];\n      const end = box[valueAxis + 2];\n      for (let idx = 0; idx < notes.length; idx++) {\n        const note = notes[idx];\n        if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\n          note.hide();\n        }\n      }\n    }\n  }\n  pan(delta) {\n    const range = this.limitedRangeIndices(true);\n    const {\n      scale\n    } = this.scaleOptions();\n    const offset = round(delta / scale, DEFAULT_PRECISION);\n    const totalRange = this.totalRange();\n    const min = range.min + offset;\n    const max = range.max + offset;\n    return this.limitRange(min, max, 0, totalRange.max, offset);\n  }\n  pointsRange(start, end) {\n    const {\n      reverse,\n      vertical\n    } = this.options;\n    const valueAxis = vertical ? Y : X;\n    const range = this.limitedRangeIndices(true);\n    const {\n      scale,\n      box\n    } = this.scaleOptions();\n    const lineStart = box[valueAxis + (reverse ? 2 : 1)];\n    const diffStart = start[valueAxis] - lineStart;\n    const diffEnd = end[valueAxis] - lineStart;\n    const min = range.min + diffStart / scale;\n    const max = range.min + diffEnd / scale;\n    const rangeMin = Math.min(min, max);\n    const rangeMax = Math.max(min, max);\n    if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\n      return {\n        min: rangeMin,\n        max: rangeMax\n      };\n    }\n  }\n  valueRange() {\n    return this.range();\n  }\n  totalIndex(value) {\n    const options = this.options;\n    const index = this._categoriesMap ? this._categoriesMap.get(value) : indexOf(value, options.srcCategories);\n    return index;\n  }\n  currentRangeIndices() {\n    const options = this.options;\n    let min = 0;\n    if (isNumber(options.min)) {\n      min = Math.floor(options.min);\n    }\n    let max;\n    if (isNumber(options.max)) {\n      max = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;\n    } else {\n      max = this.totalCount() - 1;\n    }\n    return {\n      min: min,\n      max: max\n    };\n  }\n  limitedRangeIndices(totalLimit) {\n    const options = this.options;\n    let min = isNumber(options.min) ? options.min : 0;\n    let max;\n    if (isNumber(options.max)) {\n      max = options.max;\n    } else if (isNumber(options.min)) {\n      max = min + options.categories.length;\n    } else {\n      max = this.totalRange().max || 1;\n    }\n    if (totalLimit) {\n      const totalRange = this.totalRange();\n      min = limitValue(min, 0, totalRange.max);\n      max = limitValue(max, 0, totalRange.max);\n    }\n    return {\n      min: min,\n      max: max\n    };\n  }\n  totalRangeIndices() {\n    return {\n      min: 0,\n      max: this.totalRange().max || 1\n    };\n  }\n  mapCategories() {\n    if (!this._categoriesMap) {\n      const map = this._categoriesMap = new HashMap();\n      const srcCategories = this.options.srcCategories;\n      for (let idx = 0; idx < srcCategories.length; idx++) {\n        map.set(srcCategories[idx], idx);\n      }\n    }\n  }\n  totalCount() {\n    return Math.max(this.options.srcCategories.length, this._seriesMax || 0);\n  }\n}\nsetDefaultOptions(CategoryAxis, {\n  type: \"category\",\n  vertical: false,\n  majorGridLines: {\n    visible: false,\n    width: 1,\n    color: BLACK\n  },\n  labels: {\n    zIndex: 1\n  },\n  justified: false,\n  _deferLabels: true\n});\nexport default CategoryAxis;","map":{"version":3,"names":["Axis","AxisLabel","BLACK","COORD_PRECISION","DEFAULT_PRECISION","X","Y","defined","isNumber","last","limitValue","round","setDefaultOptions","valueOrDefault","HashMap","dateEquals","MIN_CATEGORY_POINTS_RANGE","MIN_CATEGORY_RANGE","indexOf","value","arr","Date","length","idx","CategoryAxis","initFields","_ticks","categoriesHash","clone","copy","Object","assign","options","categories","srcCategories","chartService","createLabels","initUserOptions","definedMin","min","definedMax","max","Math","floor","justified","ceil","slice","rangeIndices","totalRange","range","roundedRange","_seriesMax","scaleOptions","lineBox","size","vertical","height","width","scale","reverse","box","arrangeLabels","hideOutOfRangeLabels","labels","valueAxis","start","end","firstLabel","lastLabel","visible","getMajorTickPositions","getTicks","majorTicks","getMinorTickPositions","minorTicks","getLabelsTickPositions","labelTicks","tickIndices","stepSize","limit","current","indices","push","getTickPositions","pos","positions","cache","hash","getHash","_hash","hasMinor","minorGridLines","filterOutOfRangePositions","axis","inRange","position","startIndex","endIndex","lineInfo","lineSize","axisDir","startEdge","axisOrigin","toString","lineStart","lineDir","getSlot","from","to","slotBox","singleSlot","p1","p2","limitSlot","slot","limittedSlot","categoryIndex","pointCategoryIndex","point","startValue","lineEnd","diff","getCategory","index","totalIndex","categoryAt","total","categoriesCount","translateRange","delta","offset","scaleRange","cursor","abs","pointOffset","limitedRangeIndices","scaleToDelta","minDelta","maxDelta","zoomRange","totalMin","totalMax","labelsCount","labelsRange","labelOptions","skip","step","createAxisLabel","labelContext","dataItem","dataItems","category","text","axisLabelText","shouldRenderNote","noteSlot","arrangeNotes","hideOutOfRangeNotes","notes","note","hide","pan","limitRange","pointsRange","diffStart","diffEnd","rangeMin","rangeMax","valueRange","_categoriesMap","get","currentRangeIndices","totalCount","totalLimit","totalRangeIndices","mapCategories","map","set","type","majorGridLines","color","zIndex","_deferLabels"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/core/category-axis.js"],"sourcesContent":["import Axis from './axis';\nimport AxisLabel from './axis-label';\n\nimport { BLACK, COORD_PRECISION, DEFAULT_PRECISION, X, Y } from '../common/constants';\nimport { defined, isNumber, last, limitValue, round, setDefaultOptions, valueOrDefault, HashMap } from '../common';\nimport { dateEquals } from '../date-utils';\n\nconst MIN_CATEGORY_POINTS_RANGE = 0.01;\nconst MIN_CATEGORY_RANGE = 0.1;\n\nfunction indexOf(value, arr) {\n    if (value instanceof Date) {\n        const length = arr.length;\n        for (let idx = 0; idx < length; idx++) {\n            if (dateEquals(arr[idx], value)) {\n                return idx;\n            }\n        }\n\n        return -1;\n    }\n\n    return arr.indexOf(value);\n}\n\nclass CategoryAxis extends Axis {\n    initFields() {\n        this._ticks = {};\n    }\n\n    categoriesHash() {\n        return \"\";\n    }\n\n    clone() {\n        const copy = new CategoryAxis(Object.assign({}, this.options, {\n            categories: this.options.srcCategories\n        }), this.chartService);\n        copy.createLabels();\n\n        return copy;\n    }\n\n    initUserOptions(options) {\n        const categories = options.categories || [];\n        const definedMin = defined(options.min);\n        const definedMax = defined(options.max);\n        options.srcCategories = options.categories = categories;\n\n        if ((definedMin || definedMax) && categories.length) {\n            const min = definedMin ? Math.floor(options.min) : 0;\n            let max;\n\n            if (definedMax) {\n                max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\n            } else {\n                max = categories.length;\n            }\n\n            options.categories = options.categories.slice(min, max);\n        }\n\n        return options;\n    }\n\n    rangeIndices() {\n        const options = this.options;\n        const length = options.categories.length || 1;\n        const min = isNumber(options.min) ? options.min % 1 : 0;\n        let max;\n\n        if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\n            max = length - (1 - options.max % 1);\n        } else {\n            max = length - (options.justified ? 1 : 0);\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    range() {\n        const options = this.options;\n        const min = isNumber(options.min) ? options.min : 0;\n        const max = isNumber(options.max) ? options.max : this.totalRange().max;\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    roundedRange() {\n        return this.range();\n    }\n\n    totalRange() {\n        const options = this.options;\n        return { min: 0, max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0) };\n    }\n\n    scaleOptions() {\n        const { min, max } = this.rangeIndices();\n        const lineBox = this.lineBox();\n        const size = this.options.vertical ? lineBox.height() : lineBox.width();\n        const scale = size / ((max - min) || 1);\n\n        return {\n            scale: scale * (this.options.reverse ? -1 : 1),\n            box: lineBox,\n            min: min,\n            max: max\n        };\n    }\n\n    arrangeLabels() {\n        super.arrangeLabels();\n        this.hideOutOfRangeLabels();\n    }\n\n    hideOutOfRangeLabels() {\n        const { box, labels } = this;\n\n        if (labels.length > 0) {\n            const valueAxis = this.options.vertical ? Y : X;\n            const start = box[valueAxis + 1];\n            const end = box[valueAxis + 2];\n            const firstLabel = labels[0];\n            const lastLabel = last(labels);\n\n            if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\n                firstLabel.options.visible = false;\n            }\n            if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\n                lastLabel.options.visible = false;\n            }\n        }\n    }\n\n    getMajorTickPositions() {\n        return this.getTicks().majorTicks;\n    }\n\n    getMinorTickPositions() {\n        return this.getTicks().minorTicks;\n    }\n\n    getLabelsTickPositions() {\n        return this.getTicks().labelTicks;\n    }\n\n    tickIndices(stepSize) {\n        const { min, max } = this.rangeIndices();\n        const limit = Math.ceil(max);\n        let current = Math.floor(min);\n        const indices = [];\n\n        while (current <= limit) {\n            indices.push(current);\n            current += stepSize;\n        }\n\n        return indices;\n    }\n\n    getTickPositions(stepSize) {\n        const { vertical, reverse } = this.options;\n        const { scale, box, min } = this.scaleOptions();\n        const pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];\n        const indices = this.tickIndices(stepSize);\n        const positions = [];\n\n        for (let idx = 0; idx < indices.length; idx++) {\n            positions.push(pos + round(scale * (indices[idx] - min), COORD_PRECISION));\n        }\n\n        return positions;\n    }\n\n    getTicks() {\n        const options = this.options;\n        const cache = this._ticks;\n        const range = this.rangeIndices();\n        const lineBox = this.lineBox();\n        const hash = lineBox.getHash() + range.min + \",\" + range.max + options.reverse + options.justified;\n\n        if (cache._hash !== hash) {\n            const hasMinor = options.minorTicks.visible || options.minorGridLines.visible;\n            cache._hash = hash;\n            cache.labelTicks = this.getTickPositions(1);\n            cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);\n            cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];\n        }\n\n        return cache;\n    }\n\n    filterOutOfRangePositions(positions, lineBox) {\n        if (!positions.length) {\n            return positions;\n        }\n\n        const axis = this.options.vertical ? Y : X;\n        const inRange = (position) => lineBox[axis + 1] <= position && position <= lineBox[axis + 2];\n\n        const end = positions.length - 1;\n        let startIndex = 0;\n        while (!inRange(positions[startIndex]) && startIndex <= end) {\n            startIndex++;\n        }\n\n        let endIndex = end;\n\n        while (!inRange(positions[endIndex]) && endIndex >= 0) {\n            endIndex--;\n        }\n\n        return positions.slice(startIndex, endIndex + 1);\n    }\n\n    lineInfo() {\n        const { vertical, reverse } = this.options;\n        const lineBox = this.lineBox();\n        const lineSize = vertical ? lineBox.height() : lineBox.width();\n        const axis = vertical ? Y : X;\n        const axisDir = reverse ? -1 : 1;\n        const startEdge = axisDir === 1 ? 1 : 2;\n        const axisOrigin = axis + startEdge.toString();\n        const lineStart = lineBox[axisOrigin];\n\n        return {\n            axis,\n            axisOrigin,\n            axisDir,\n            lineBox,\n            lineSize,\n            lineStart\n        };\n    }\n\n    lineDir() {\n        /*\n         *  Category axis line direction:\n         *    * Vertical: down.\n         *    * Horizontal: right.\n         */\n\n        const { reverse } = this.options;\n        return reverse ? -1 : 1;\n    }\n\n    // TODO: Rename to slotBox, valueSlot, slotByIndex?\n    getSlot(from, to, limit) {\n        const options = this.options;\n        const { reverse, justified } = options;\n        const { scale, box, min } = this.scaleOptions();\n        const { axis: valueAxis, lineStart } = this.lineInfo();\n\n        const slotBox = box.clone();\n        const singleSlot = !defined(to);\n\n        const start = valueOrDefault(from, 0);\n        let end = valueOrDefault(to, start);\n        end = Math.max(end - 1, start);\n\n        // Fixes transient bug caused by iOS 6.0 JIT\n        // (one can never be too sure)\n        end = Math.max(start, end);\n\n        let p1 = lineStart + (start - min) * scale;\n        let p2 = lineStart + (end + 1 - min) * scale;\n\n        if (singleSlot && justified) {\n            p2 = p1;\n        }\n\n        if (limit) {\n            p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);\n            p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);\n        }\n\n        slotBox[valueAxis + 1] = reverse ? p2 : p1;\n        slotBox[valueAxis + 2] = reverse ? p1 : p2;\n\n        return slotBox;\n    }\n\n    limitSlot(slot) {\n        const vertical = this.options.vertical;\n        const valueAxis = vertical ? Y : X;\n        const lineBox = this.lineBox();\n        const limittedSlot = slot.clone();\n\n        limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n        limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n\n        return limittedSlot;\n    }\n\n    slot(from, to, limit) {\n        const min = Math.floor(this.options.min || 0);\n        let start = from;\n        let end = to;\n\n        if (typeof start === \"string\") {\n            start = this.categoryIndex(start);\n        } else if (isNumber(start)) {\n            start -= min;\n        }\n\n        if (typeof end === \"string\") {\n            end = this.categoryIndex(end);\n        } else if (isNumber(end)) {\n            end -= min;\n        }\n\n        return super.slot(start, end, limit);\n    }\n\n    pointCategoryIndex(point) {\n        const { reverse, justified, vertical } = this.options;\n        const valueAxis = vertical ? Y : X;\n        const { scale, box, min, max } = this.scaleOptions();\n        const startValue = reverse ? max : min;\n        const lineStart = box[valueAxis + 1];\n        const lineEnd = box[valueAxis + 2];\n        const pos = point[valueAxis];\n\n        if (pos < lineStart || pos > lineEnd) {\n            return null;\n        }\n\n        let value = startValue + (pos - lineStart) / scale;\n        const diff = value % 1;\n\n        if (justified) {\n            value = Math.round(value);\n        } else if (diff === 0 && value > 0) {\n            value--;\n        }\n\n        return Math.floor(value);\n    }\n\n    getCategory(point) {\n        const index = this.pointCategoryIndex(point);\n\n        if (index === null) {\n            return null;\n        }\n\n        return this.options.categories[index];\n    }\n\n    categoryIndex(value) {\n        return this.totalIndex(value) - Math.floor(this.options.min || 0);\n    }\n\n    categoryAt(index, total) {\n        const options = this.options;\n\n        return (total ? options.srcCategories : options.categories)[index];\n    }\n\n    categoriesCount() {\n        return (this.options.categories || []).length;\n    }\n\n    translateRange(delta) {\n        const options = this.options;\n        const lineBox = this.lineBox();\n        const size = options.vertical ? lineBox.height() : lineBox.width();\n        const range = options.categories.length;\n        const scale = size / range;\n        const offset = round(delta / scale, DEFAULT_PRECISION);\n\n        return {\n            min: offset,\n            max: range + offset\n        };\n    }\n\n    scaleRange(scale, cursor) {\n        const position = Math.abs(this.pointOffset(cursor));\n        const rangeIndices = this.limitedRangeIndices();\n        const range = rangeIndices.max - rangeIndices.min;\n        const delta = this.scaleToDelta(scale, range);\n        const minDelta = position * delta;\n        const maxDelta = (1 - position) * delta;\n        const min = rangeIndices.min + minDelta;\n        let max = rangeIndices.max - maxDelta;\n\n        if (max - min < MIN_CATEGORY_RANGE) {\n            max = min + MIN_CATEGORY_RANGE;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    zoomRange(scale, cursor) {\n        const { min: totalMin, max: totalMax } = this.totalRange();\n        const range = this.scaleRange(scale, cursor);\n\n        return {\n            min: limitValue(range.min, totalMin, totalMax),\n            max: limitValue(range.max, totalMin, totalMax)\n        };\n    }\n\n    labelsCount() {\n        const labelsRange = this.labelsRange();\n\n        return labelsRange.max - labelsRange.min;\n    }\n\n    labelsRange() {\n        const options = this.options;\n        const { justified, labels: labelOptions } = options;\n        let { min, max } = this.limitedRangeIndices(true);\n        const start = Math.floor(min);\n\n        if (!justified) {\n            min = Math.floor(min);\n            max = Math.ceil(max);\n        } else {\n            min = Math.ceil(min);\n            max = Math.floor(max);\n        }\n\n        let skip;\n\n        if (min > labelOptions.skip) {\n            skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\n        } else {\n            skip = labelOptions.skip;\n        }\n\n        return {\n            min: skip - start,\n            max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\n        };\n    }\n\n    createAxisLabel(index, labelOptions, labelContext) {\n        const options = this.options;\n        const dataItem = options.dataItems ? options.dataItems[index] : null;\n        const category = valueOrDefault(options.categories[index], \"\");\n\n        labelContext.dataItem = dataItem;\n        const text = this.axisLabelText(category, labelOptions, labelContext);\n\n        return new AxisLabel(category, text, index, dataItem, labelOptions);\n    }\n\n    shouldRenderNote(value) {\n        const range = this.limitedRangeIndices();\n\n        return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\n    }\n\n    noteSlot(value) {\n        const options = this.options;\n        const index = value - Math.floor(options.min || 0);\n        return this.getSlot(index);\n    }\n\n    arrangeNotes() {\n        super.arrangeNotes();\n        this.hideOutOfRangeNotes();\n    }\n\n    hideOutOfRangeNotes() {\n        const { notes, box } = this;\n        if (notes && notes.length) {\n            const valueAxis = this.options.vertical ? Y : X;\n            const start = box[valueAxis + 1];\n            const end = box[valueAxis + 2];\n\n            for (let idx = 0; idx < notes.length; idx++) {\n                const note = notes[idx];\n                if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\n                    note.hide();\n                }\n            }\n        }\n    }\n\n    pan(delta) {\n        const range = this.limitedRangeIndices(true);\n        const { scale } = this.scaleOptions();\n        const offset = round(delta / scale, DEFAULT_PRECISION);\n        const totalRange = this.totalRange();\n        const min = range.min + offset;\n        const max = range.max + offset;\n\n        return this.limitRange(min, max, 0, totalRange.max, offset);\n    }\n\n    pointsRange(start, end) {\n        const { reverse, vertical } = this.options;\n        const valueAxis = vertical ? Y : X;\n        const range = this.limitedRangeIndices(true);\n        const { scale, box } = this.scaleOptions();\n        const lineStart = box[valueAxis + (reverse ? 2 : 1)];\n\n        const diffStart = start[valueAxis] - lineStart;\n        const diffEnd = end[valueAxis] - lineStart;\n\n        const min = range.min + diffStart / scale;\n        const max = range.min + diffEnd / scale;\n        const rangeMin = Math.min(min, max);\n        const rangeMax = Math.max(min, max);\n\n        if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\n            return {\n                min: rangeMin,\n                max: rangeMax\n            };\n        }\n    }\n\n    valueRange() {\n        return this.range();\n    }\n\n    totalIndex(value) {\n        const options = this.options;\n        const index = this._categoriesMap ?\n            this._categoriesMap.get(value) : indexOf(value, options.srcCategories);\n\n        return index;\n    }\n\n    currentRangeIndices() {\n        const options = this.options;\n        let min = 0;\n\n        if (isNumber(options.min)) {\n            min = Math.floor(options.min);\n        }\n\n        let max;\n        if (isNumber(options.max)) {\n            max = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;\n        } else {\n            max = this.totalCount() - 1;\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    limitedRangeIndices(totalLimit) {\n        const options = this.options;\n        let min = isNumber(options.min) ? options.min : 0;\n        let max;\n\n        if (isNumber(options.max)) {\n            max = options.max;\n        } else if (isNumber(options.min)) {\n            max = min + options.categories.length;\n        } else {\n            max = this.totalRange().max || 1;\n        }\n\n        if (totalLimit) {\n            const totalRange = this.totalRange();\n            min = limitValue(min, 0, totalRange.max);\n            max = limitValue(max, 0, totalRange.max);\n        }\n\n        return {\n            min: min,\n            max: max\n        };\n    }\n\n    totalRangeIndices() {\n        return {\n            min: 0,\n            max: this.totalRange().max || 1\n        };\n    }\n\n    mapCategories() {\n        if (!this._categoriesMap) {\n            const map = this._categoriesMap = new HashMap();\n            const srcCategories = this.options.srcCategories;\n            for (let idx = 0; idx < srcCategories.length; idx++) {\n                map.set(srcCategories[idx], idx);\n            }\n        }\n    }\n\n    totalCount() {\n        return Math.max(this.options.srcCategories.length, this._seriesMax || 0);\n    }\n}\n\nsetDefaultOptions(CategoryAxis, {\n    type: \"category\",\n    vertical: false,\n    majorGridLines: {\n        visible: false,\n        width: 1,\n        color: BLACK\n    },\n    labels: {\n        zIndex: 1\n    },\n    justified: false,\n    _deferLabels: true\n});\n\nexport default CategoryAxis;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}