{"ast":null,"code":"/* eslint-disable */\nimport { Result, ResultType } from './result';\nimport { Stream } from './stream';\nconst toArray = value => (value || '').split('');\nconst ESCAPE_CHARACTER = '\\\\';\n/**\n * @hidden\n */\nexport class Parser {\n  constructor(parse) {\n    this.parse = parse;\n  }\n  run(input, control = '') {\n    if (input instanceof Stream) {\n      return this.parse(input);\n    } else {\n      return this.parse(new Stream(toArray(input), toArray(control)));\n    }\n  }\n  //map :: Functor f => f a ~> (a -> b) -> f b\n  map(f) {\n    return new Parser(stream => this.parse(stream).map(f));\n  }\n  //chain :: Chain m => m a ~> (a -> m b) -> m b\n  chain(f) {\n    return new Parser(stream => this.parse(stream).chain((v, s) => f(v).run(s)));\n  }\n  isLiteral(c) {\n    return this.run(c).type === ResultType.Literal;\n  }\n}\n/**\n * @hidden\n */\nexport const mask = ({\n  prompt,\n  promptPlaceholder\n}) => rule => new Parser(stream => {\n  while (!stream.eof()) {\n    const {\n      char,\n      control\n    } = stream.peek();\n    if (char === control && control === prompt) {\n      stream.eat();\n      return new Result(prompt, stream, ResultType.Mask);\n    }\n    if (rule.test(char)) {\n      stream.eat();\n      return new Result(char, stream, ResultType.Mask);\n    }\n    if (char === promptPlaceholder) {\n      stream.eat();\n      return new Result(prompt, stream, ResultType.Mask);\n    }\n    stream.eat_input();\n  }\n  stream.eat();\n  return new Result(prompt, stream, ResultType.Mask);\n});\n/**\n * @hidden\n */\nexport const literal = _token => new Parser(stream => {\n  //    let {char, control} = stream.peek();\n  let char = stream.peek().char;\n  if (char === _token) {\n    stream.eat();\n    return new Result(_token, stream, ResultType.Literal);\n  }\n  //    if (control === _token) {\n  //        while (!stream.eof() && char !== _token) {\n  //            stream.eat_input();\n  //            char = stream.peek().char;\n  //        }\n  //    }\n  //\n  //    if (control !== undefined) {\n  //        stream.eat();\n  //    }\n  return new Result(_token, stream, ResultType.Literal);\n});\n/**\n * @hidden\n */\nexport const unmask = prompt => rule => new Parser(stream => {\n  while (!stream.eof()) {\n    const {\n      char,\n      control\n    } = stream.peek();\n    if (char === prompt && control === prompt) {\n      stream.eat();\n      return new Result(char, stream);\n    }\n    if (rule.test(char)) {\n      stream.eat();\n      return new Result(char, stream);\n    }\n    stream.eat_input();\n  }\n  stream.eat();\n  return new Result('', stream);\n});\n/**\n * @hidden\n */\nexport const unliteral = _token => new Parser(stream => {\n  if (stream.eof()) {\n    return new Result('', stream);\n  }\n  const {\n    char\n  } = stream.peek();\n  if (char === _token) {\n    stream.eat();\n  }\n  return new Result(_token, stream);\n});\n/**\n * @hidden\n */\nexport const token = (rules, creator) => new Parser(stream => {\n  let {\n    char\n  } = stream.next();\n  const rule = rules[char];\n  if (char === ESCAPE_CHARACTER) {\n    char = stream.next().char;\n    return new Result(creator.literal(char), stream);\n  }\n  if (!rule) {\n    return new Result(creator.literal(char), stream);\n  }\n  return new Result(creator.mask(rule), stream);\n});\n/**\n * @hidden\n */\nexport const rawMask = ({\n  prompt,\n  promptPlaceholder\n}) => new Parser(stream => {\n  let {\n    char\n  } = stream.next();\n  if (char === prompt) {\n    return new Result(promptPlaceholder, stream);\n  }\n  return new Result(char, stream);\n});\n/**\n * @hidden\n */\nexport const rawLiteral = includeLiterals => new Parser(stream => {\n  let {\n    char\n  } = stream.next();\n  if (includeLiterals) {\n    return new Result(char, stream);\n  }\n  return new Result('', stream);\n});","map":{"version":3,"names":["Result","ResultType","Stream","toArray","value","split","ESCAPE_CHARACTER","Parser","constructor","parse","run","input","control","map","f","stream","chain","v","s","isLiteral","c","type","Literal","mask","prompt","promptPlaceholder","rule","eof","char","peek","eat","Mask","test","eat_input","literal","_token","unmask","unliteral","token","rules","creator","next","rawMask","rawLiteral","includeLiterals"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-inputs-common/dist/es2015/maskedtextbox/parsing/parsers.js"],"sourcesContent":["/* eslint-disable */\nimport { Result, ResultType } from './result';\nimport { Stream } from './stream';\nconst toArray = (value) => (value || '').split('');\nconst ESCAPE_CHARACTER = '\\\\';\n/**\n * @hidden\n */\nexport class Parser {\n    constructor(parse) {\n        this.parse = parse;\n    }\n    run(input, control = '') {\n        if (input instanceof Stream) {\n            return this.parse(input);\n        }\n        else {\n            return this.parse(new Stream(toArray(input), toArray(control)));\n        }\n    }\n    //map :: Functor f => f a ~> (a -> b) -> f b\n    map(f) {\n        return new Parser(stream => this.parse(stream).map(f));\n    }\n    //chain :: Chain m => m a ~> (a -> m b) -> m b\n    chain(f) {\n        return new Parser(stream => this.parse(stream).chain((v, s) => f(v).run(s)));\n    }\n    isLiteral(c) {\n        return this.run(c).type === ResultType.Literal;\n    }\n}\n/**\n * @hidden\n */\nexport const mask = ({ prompt, promptPlaceholder }) => rule => new Parser(stream => {\n    while (!stream.eof()) {\n        const { char, control } = stream.peek();\n        if (char === control && control === prompt) {\n            stream.eat();\n            return new Result(prompt, stream, ResultType.Mask);\n        }\n        if (rule.test(char)) {\n            stream.eat();\n            return new Result(char, stream, ResultType.Mask);\n        }\n        if (char === promptPlaceholder) {\n            stream.eat();\n            return new Result(prompt, stream, ResultType.Mask);\n        }\n        stream.eat_input();\n    }\n    stream.eat();\n    return new Result(prompt, stream, ResultType.Mask);\n});\n/**\n * @hidden\n */\nexport const literal = _token => new Parser(stream => {\n    //    let {char, control} = stream.peek();\n    let char = stream.peek().char;\n    if (char === _token) {\n        stream.eat();\n        return new Result(_token, stream, ResultType.Literal);\n    }\n    //    if (control === _token) {\n    //        while (!stream.eof() && char !== _token) {\n    //            stream.eat_input();\n    //            char = stream.peek().char;\n    //        }\n    //    }\n    //\n    //    if (control !== undefined) {\n    //        stream.eat();\n    //    }\n    return new Result(_token, stream, ResultType.Literal);\n});\n/**\n * @hidden\n */\nexport const unmask = prompt => rule => new Parser(stream => {\n    while (!stream.eof()) {\n        const { char, control } = stream.peek();\n        if (char === prompt && control === prompt) {\n            stream.eat();\n            return new Result(char, stream);\n        }\n        if (rule.test(char)) {\n            stream.eat();\n            return new Result(char, stream);\n        }\n        stream.eat_input();\n    }\n    stream.eat();\n    return new Result('', stream);\n});\n/**\n * @hidden\n */\nexport const unliteral = _token => new Parser(stream => {\n    if (stream.eof()) {\n        return new Result('', stream);\n    }\n    const { char } = stream.peek();\n    if (char === _token) {\n        stream.eat();\n    }\n    return new Result(_token, stream);\n});\n/**\n * @hidden\n */\nexport const token = (rules, creator) => new Parser(stream => {\n    let { char } = stream.next();\n    const rule = rules[char];\n    if (char === ESCAPE_CHARACTER) {\n        char = stream.next().char;\n        return new Result(creator.literal(char), stream);\n    }\n    if (!rule) {\n        return new Result(creator.literal(char), stream);\n    }\n    return new Result(creator.mask(rule), stream);\n});\n/**\n * @hidden\n */\nexport const rawMask = ({ prompt, promptPlaceholder }) => new Parser(stream => {\n    let { char } = stream.next();\n    if (char === prompt) {\n        return new Result(promptPlaceholder, stream);\n    }\n    return new Result(char, stream);\n});\n/**\n * @hidden\n */\nexport const rawLiteral = includeLiterals => new Parser(stream => {\n    let { char } = stream.next();\n    if (includeLiterals) {\n        return new Result(char, stream);\n    }\n    return new Result('', stream);\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}