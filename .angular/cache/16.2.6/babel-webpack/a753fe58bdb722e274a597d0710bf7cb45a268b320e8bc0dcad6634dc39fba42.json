{"ast":null,"code":"import { intersect } from \"./algorithms\";\nimport { getWindow, autoScrollVelocity, scrollableViewPort, getScrollableParent, isPointerInsideContainer, getDocument } from \"./utils\";\n/** @hidden */\nexport var DRAG_AND_DROP_DISPATCH_ACTION;\n(function (DRAG_AND_DROP_DISPATCH_ACTION) {\n  DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_DOWN\"] = \"pointerdown\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_MOVE\"] = \"pointermove\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_UP\"] = \"pointerup\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_CANCEL\"] = \"pointercancel\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"MOUSE_DOWN\"] = \"mousedown\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"MOUSE_MOVE\"] = \"mousemove\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"MOUSE_UP\"] = \"mouseup\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"CONTEXT_MENU\"] = \"contextmenu\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_START\"] = \"touchstart\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_MOVE\"] = \"touchmove\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_END\"] = \"touchend\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_CANCEL\"] = \"touchcancel\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"SCROLL\"] = \"scroll\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"START\"] = \"KENDO_DRAG_AND_DROP_START\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"MOVE\"] = \"KENDO_DRAG_AND_DROP_MOVE\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"END\"] = \"KENDO_DRAG_AND_DROP_END\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"CANCEL\"] = \"KENDO_DRAG_AND_DROP_CANCEL\";\n})(DRAG_AND_DROP_DISPATCH_ACTION || (DRAG_AND_DROP_DISPATCH_ACTION = {}));\nconst isTouchEvent = event => /^touch/.test(event.type);\nconst isScrollEvent = event => /^(scroll)/.test(event.type);\n/** @hidden */\nexport const normalizeEvent = (event, state) => isTouchEvent(event) ? {\n  pageX: event.changedTouches[0].pageX,\n  pageY: event.changedTouches[0].pageY,\n  clientX: event.changedTouches[0].clientX,\n  clientY: event.changedTouches[0].clientY,\n  scrollX: state.scrollOffset.x,\n  scrollY: state.scrollOffset.y,\n  offsetX: state.offset.x,\n  offsetY: state.offset.y,\n  type: event.type,\n  originalEvent: event,\n  isTouch: true,\n  altKey: false,\n  ctrlKey: false,\n  shiftKey: false,\n  metaKey: false\n} : isScrollEvent(event) ? {\n  pageX: state.pageOffset.x,\n  pageY: state.pageOffset.y,\n  clientX: state.clientOffset.x,\n  clientY: state.clientOffset.y,\n  scrollX: state.scrollOffset.x,\n  scrollY: state.scrollOffset.y,\n  offsetX: state.offset.x,\n  offsetY: state.offset.y,\n  type: event.type,\n  originalEvent: event,\n  altKey: false,\n  ctrlKey: false,\n  shiftKey: false,\n  metaKey: false\n} : {\n  pageX: event.pageX,\n  pageY: event.pageY,\n  clientX: event.clientX,\n  clientY: event.clientY,\n  offsetX: event.offsetX,\n  offsetY: event.offsetY,\n  scrollX: state.scrollOffset.x,\n  scrollY: state.scrollOffset.y,\n  type: event.type,\n  ctrlKey: event.ctrlKey,\n  shiftKey: event.shiftKey,\n  altKey: event.altKey,\n  metaKey: event.metaKey,\n  originalEvent: event\n};\nconst noop = () => {};\n/** @hidden */\nexport const dispatchDragAndDrop = (state, action, callbacks = {}) => {\n  const {\n    onIsPressedChange = noop,\n    onIsScrollingChange = noop,\n    onVelocityChange = noop,\n    onOffsetChange = noop,\n    onPageOffsetChange = noop,\n    onClientOffsetChange = noop,\n    onScrollOffsetChange = noop,\n    onInitialScrollOffsetChange = noop\n  } = callbacks;\n  const drag = action.payload;\n  const element = drag.element;\n  const hint = drag.hint;\n  const autoScrollDirection = state.autoScrollDirection;\n  const overrideScrollableParent = state.scrollableParent;\n  const event = normalizeEvent(action.event, state);\n  switch (event.type) {\n    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN && (!event.originalEvent.isPrimary || event.originalEvent.button !== 0)) {\n        break;\n      }\n    // In rare cases where the `which` attribute is available in the mouse event\n    // we check if the `left button` is explicitly clicked:\n    // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/which#return_value\n    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN && event.originalEvent.which && event.originalEvent.which > 1 || state.ignoreMouse) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START && event.originalEvent.touches.length !== 1) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.START:\n      {\n        const scrollableParent = overrideScrollableParent || getScrollableParent(action.payload.element);\n        onInitialScrollOffsetChange(scrollableParent instanceof Window ? {\n          x: scrollableParent.scrollX,\n          y: scrollableParent.scrollY\n        } : {\n          x: scrollableParent.scrollLeft,\n          y: scrollableParent.scrollTop\n        });\n        onClientOffsetChange({\n          x: event.clientX,\n          y: event.clientY\n        });\n        onPageOffsetChange({\n          x: event.pageX,\n          y: event.pageY\n        });\n        onOffsetChange({\n          x: event.offsetX,\n          y: event.offsetY\n        });\n        onIsPressedChange(true);\n        if (drag.onPress) {\n          drag.onPress(event);\n        }\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.SCROLL:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.SCROLL && !state.pressed) {\n        break;\n      }\n      const scrollableParent = overrideScrollableParent || getScrollableParent(element);\n      const scrollOffset = scrollableParent instanceof Window ? {\n        x: scrollableParent.scrollX,\n        y: scrollableParent.scrollY\n      } : {\n        x: scrollableParent.scrollLeft,\n        y: scrollableParent.scrollTop\n      };\n      event.scrollX = scrollOffset.x - state.initialScrollOffset.x;\n      event.scrollY = scrollOffset.y - state.initialScrollOffset.y;\n      onScrollOffsetChange({\n        x: event.scrollX,\n        y: event.scrollY\n      });\n    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE && !event.originalEvent.isPrimary) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_MOVE:\n    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE && event.originalEvent.touches.length !== 1) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.MOVE:\n      {\n        if (state.pressed) {\n          if (state.autoScroll && event.originalEvent.type !== 'scroll') {\n            if (element) {\n              const document = getDocument(element);\n              const scrollableParent = overrideScrollableParent || getScrollableParent(document.elementFromPoint(event.clientX, event.clientY));\n              const newVelocity = autoScrollVelocity(event.clientX, event.clientY, scrollableViewPort(scrollableParent, getWindow(element)));\n              onVelocityChange({\n                x: autoScrollDirection && autoScrollDirection.horizontal === false ? 0 : newVelocity.x,\n                y: autoScrollDirection && autoScrollDirection.vertical === false ? 0 : newVelocity.y\n              });\n              onIsScrollingChange(newVelocity.y !== 0 || newVelocity.x !== 0);\n            }\n          }\n          if (!state.drag && drag.onDragStart) {\n            drag.onDragStart(event);\n          }\n          if (drag.onDrag) {\n            drag.onDrag(event);\n          }\n          const dropElement = intersect(hint || element, state.drops.map(drop => drop && drop.element).filter(d => d !== (hint || element)));\n          const drop = state.drops.find(drop => drop.element === dropElement);\n          if (drop && dropElement && isPointerInsideContainer(event.clientX, event.clientY, overrideScrollableParent || getScrollableParent(dropElement)) && dropElement !== element) {\n            if ((state.drop && state.drop.element) !== dropElement) {\n              if (state.drop && state.drop.onDragLeave) {\n                state.drop.onDragLeave(event);\n              }\n              if (drop.onDragEnter) {\n                drop.onDragEnter(event);\n              }\n            } else {\n              if (drop.onDragOver) {\n                drop.onDragOver(event);\n              }\n            }\n          } else if (state.drop && state.drop.onDragLeave) {\n            state.drop.onDragLeave(event);\n          }\n        }\n        onClientOffsetChange({\n          x: event.clientX,\n          y: event.clientY\n        });\n        onPageOffsetChange({\n          x: event.pageX,\n          y: event.pageY\n        });\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP && !event.originalEvent.isPrimary) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_UP:\n    // the last finger has been lifted, and the user is not doing gesture.\n    // there might be a better way to handle this.\n    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END && event.originalEvent.touches.length !== 1) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.END:\n      {\n        onIsPressedChange(false);\n        onIsScrollingChange(false);\n        onScrollOffsetChange({\n          x: 0,\n          y: 0\n        });\n        if (drag.onRelease) {\n          drag.onRelease(event);\n        }\n        if (state.drop && state.drop.onDrop) {\n          state.drop.onDrop(event);\n        }\n        if (state.drag && drag.onDragEnd) {\n          drag.onDragEnd(event);\n        }\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_CANCEL:\n    case DRAG_AND_DROP_DISPATCH_ACTION.CONTEXT_MENU:\n    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_CANCEL:\n    case DRAG_AND_DROP_DISPATCH_ACTION.CANCEL:\n      {\n        onIsPressedChange(false);\n        onIsScrollingChange(false);\n        onScrollOffsetChange({\n          x: 0,\n          y: 0\n        });\n        if (drag.onDragEnd) {\n          drag.onDragEnd(event);\n        }\n        if (state.drop && state.drop.onDragLeave) {\n          state.drop.onDragLeave(event);\n        }\n        break;\n      }\n    default:\n      break;\n  }\n};","map":{"version":3,"names":["intersect","getWindow","autoScrollVelocity","scrollableViewPort","getScrollableParent","isPointerInsideContainer","getDocument","DRAG_AND_DROP_DISPATCH_ACTION","isTouchEvent","event","test","type","isScrollEvent","normalizeEvent","state","pageX","changedTouches","pageY","clientX","clientY","scrollX","scrollOffset","x","scrollY","y","offsetX","offset","offsetY","originalEvent","isTouch","altKey","ctrlKey","shiftKey","metaKey","pageOffset","clientOffset","noop","dispatchDragAndDrop","action","callbacks","onIsPressedChange","onIsScrollingChange","onVelocityChange","onOffsetChange","onPageOffsetChange","onClientOffsetChange","onScrollOffsetChange","onInitialScrollOffsetChange","drag","payload","element","hint","autoScrollDirection","overrideScrollableParent","scrollableParent","POINTER_DOWN","isPrimary","button","MOUSE_DOWN","which","ignoreMouse","TOUCH_START","touches","length","START","Window","scrollLeft","scrollTop","onPress","SCROLL","pressed","initialScrollOffset","POINTER_MOVE","MOUSE_MOVE","TOUCH_MOVE","MOVE","autoScroll","document","elementFromPoint","newVelocity","horizontal","vertical","onDragStart","onDrag","dropElement","drops","map","drop","filter","d","find","onDragLeave","onDragEnter","onDragOver","POINTER_UP","MOUSE_UP","TOUCH_END","END","onRelease","onDrop","onDragEnd","POINTER_CANCEL","CONTEXT_MENU","TOUCH_CANCEL","CANCEL"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-draggable-common/dist/es2015/drag-n-drop.js"],"sourcesContent":["import { intersect } from \"./algorithms\";\nimport { getWindow, autoScrollVelocity, scrollableViewPort, getScrollableParent, isPointerInsideContainer, getDocument } from \"./utils\";\n/** @hidden */\nexport var DRAG_AND_DROP_DISPATCH_ACTION;\n(function (DRAG_AND_DROP_DISPATCH_ACTION) {\n    DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_DOWN\"] = \"pointerdown\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_MOVE\"] = \"pointermove\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_UP\"] = \"pointerup\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_CANCEL\"] = \"pointercancel\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"MOUSE_DOWN\"] = \"mousedown\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"MOUSE_MOVE\"] = \"mousemove\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"MOUSE_UP\"] = \"mouseup\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"CONTEXT_MENU\"] = \"contextmenu\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_START\"] = \"touchstart\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_MOVE\"] = \"touchmove\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_END\"] = \"touchend\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_CANCEL\"] = \"touchcancel\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"SCROLL\"] = \"scroll\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"START\"] = \"KENDO_DRAG_AND_DROP_START\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"MOVE\"] = \"KENDO_DRAG_AND_DROP_MOVE\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"END\"] = \"KENDO_DRAG_AND_DROP_END\";\n    DRAG_AND_DROP_DISPATCH_ACTION[\"CANCEL\"] = \"KENDO_DRAG_AND_DROP_CANCEL\";\n})(DRAG_AND_DROP_DISPATCH_ACTION || (DRAG_AND_DROP_DISPATCH_ACTION = {}));\nconst isTouchEvent = (event) => /^touch/.test(event.type);\nconst isScrollEvent = (event) => /^(scroll)/.test(event.type);\n/** @hidden */\nexport const normalizeEvent = (event, state) => (isTouchEvent(event)\n    ? ({\n        pageX: event.changedTouches[0].pageX,\n        pageY: event.changedTouches[0].pageY,\n        clientX: event.changedTouches[0].clientX,\n        clientY: event.changedTouches[0].clientY,\n        scrollX: state.scrollOffset.x,\n        scrollY: state.scrollOffset.y,\n        offsetX: state.offset.x,\n        offsetY: state.offset.y,\n        type: event.type,\n        originalEvent: event,\n        isTouch: true,\n        altKey: false,\n        ctrlKey: false,\n        shiftKey: false,\n        metaKey: false\n    })\n    : isScrollEvent(event)\n        ? ({\n            pageX: state.pageOffset.x,\n            pageY: state.pageOffset.y,\n            clientX: state.clientOffset.x,\n            clientY: state.clientOffset.y,\n            scrollX: state.scrollOffset.x,\n            scrollY: state.scrollOffset.y,\n            offsetX: state.offset.x,\n            offsetY: state.offset.y,\n            type: event.type,\n            originalEvent: event,\n            altKey: false,\n            ctrlKey: false,\n            shiftKey: false,\n            metaKey: false\n        })\n        : ({\n            pageX: event.pageX,\n            pageY: event.pageY,\n            clientX: event.clientX,\n            clientY: event.clientY,\n            offsetX: event.offsetX,\n            offsetY: event.offsetY,\n            scrollX: state.scrollOffset.x,\n            scrollY: state.scrollOffset.y,\n            type: event.type,\n            ctrlKey: event.ctrlKey,\n            shiftKey: event.shiftKey,\n            altKey: event.altKey,\n            metaKey: event.metaKey,\n            originalEvent: event\n        }));\nconst noop = () => { };\n/** @hidden */\nexport const dispatchDragAndDrop = (state, action, callbacks = {}) => {\n    const { onIsPressedChange = noop, onIsScrollingChange = noop, onVelocityChange = noop, onOffsetChange = noop, onPageOffsetChange = noop, onClientOffsetChange = noop, onScrollOffsetChange = noop, onInitialScrollOffsetChange = noop } = callbacks;\n    const drag = action.payload;\n    const element = drag.element;\n    const hint = drag.hint;\n    const autoScrollDirection = state.autoScrollDirection;\n    const overrideScrollableParent = state.scrollableParent;\n    const event = normalizeEvent(action.event, state);\n    switch (event.type) {\n        case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN:\n            if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN\n                && (!event.originalEvent.isPrimary\n                    || event.originalEvent.button !== 0)) {\n                break;\n            }\n        // In rare cases where the `which` attribute is available in the mouse event\n        // we check if the `left button` is explicitly clicked:\n        // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/which#return_value\n        case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN:\n            if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN\n                && (event.originalEvent.which\n                    && event.originalEvent.which > 1)\n                || state.ignoreMouse) {\n                break;\n            }\n        case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START:\n            if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START\n                && event.originalEvent.touches.length !== 1) {\n                break;\n            }\n        case DRAG_AND_DROP_DISPATCH_ACTION.START: {\n            const scrollableParent = overrideScrollableParent || getScrollableParent(action.payload.element);\n            onInitialScrollOffsetChange(scrollableParent instanceof Window\n                ? { x: scrollableParent.scrollX, y: scrollableParent.scrollY }\n                : { x: scrollableParent.scrollLeft, y: scrollableParent.scrollTop });\n            onClientOffsetChange({\n                x: event.clientX,\n                y: event.clientY\n            });\n            onPageOffsetChange({\n                x: event.pageX,\n                y: event.pageY\n            });\n            onOffsetChange({\n                x: event.offsetX,\n                y: event.offsetY\n            });\n            onIsPressedChange(true);\n            if (drag.onPress) {\n                drag.onPress(event);\n            }\n            break;\n        }\n        case DRAG_AND_DROP_DISPATCH_ACTION.SCROLL:\n            if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.SCROLL && !state.pressed) {\n                break;\n            }\n            const scrollableParent = overrideScrollableParent || getScrollableParent(element);\n            const scrollOffset = scrollableParent instanceof Window\n                ? { x: scrollableParent.scrollX, y: scrollableParent.scrollY }\n                : { x: scrollableParent.scrollLeft, y: scrollableParent.scrollTop };\n            event.scrollX = scrollOffset.x - state.initialScrollOffset.x;\n            event.scrollY = scrollOffset.y - state.initialScrollOffset.y;\n            onScrollOffsetChange({\n                x: event.scrollX,\n                y: event.scrollY\n            });\n        case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE:\n            if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE && !event.originalEvent.isPrimary) {\n                break;\n            }\n        case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_MOVE:\n        case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE:\n            if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE && event.originalEvent.touches.length !== 1) {\n                break;\n            }\n        case DRAG_AND_DROP_DISPATCH_ACTION.MOVE: {\n            if (state.pressed) {\n                if (state.autoScroll && event.originalEvent.type !== 'scroll') {\n                    if (element) {\n                        const document = getDocument(element);\n                        const scrollableParent = overrideScrollableParent || getScrollableParent(document.elementFromPoint(event.clientX, event.clientY));\n                        const newVelocity = autoScrollVelocity(event.clientX, event.clientY, scrollableViewPort(scrollableParent, getWindow(element)));\n                        onVelocityChange({\n                            x: (autoScrollDirection && autoScrollDirection.horizontal === false) ? 0 : newVelocity.x,\n                            y: (autoScrollDirection && autoScrollDirection.vertical === false) ? 0 : newVelocity.y\n                        });\n                        onIsScrollingChange(newVelocity.y !== 0 || newVelocity.x !== 0);\n                    }\n                }\n                if (!state.drag && drag.onDragStart) {\n                    drag.onDragStart(event);\n                }\n                if (drag.onDrag) {\n                    drag.onDrag(event);\n                }\n                const dropElement = intersect(hint || element, state.drops.map((drop) => drop && drop.element).filter((d) => d !== (hint || element)));\n                const drop = state.drops.find((drop) => drop.element === dropElement);\n                if (drop\n                    && dropElement\n                    && isPointerInsideContainer(event.clientX, event.clientY, overrideScrollableParent || getScrollableParent(dropElement))\n                    && dropElement !== element) {\n                    if ((state.drop && state.drop.element) !== dropElement) {\n                        if (state.drop && state.drop.onDragLeave) {\n                            state.drop.onDragLeave(event);\n                        }\n                        if (drop.onDragEnter) {\n                            drop.onDragEnter(event);\n                        }\n                    }\n                    else {\n                        if (drop.onDragOver) {\n                            drop.onDragOver(event);\n                        }\n                    }\n                }\n                else if (state.drop && state.drop.onDragLeave) {\n                    state.drop.onDragLeave(event);\n                }\n            }\n            onClientOffsetChange({\n                x: event.clientX,\n                y: event.clientY\n            });\n            onPageOffsetChange({\n                x: event.pageX,\n                y: event.pageY\n            });\n            break;\n        }\n        case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP:\n            if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP && !event.originalEvent.isPrimary) {\n                break;\n            }\n        case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_UP:\n        // the last finger has been lifted, and the user is not doing gesture.\n        // there might be a better way to handle this.\n        case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END:\n            if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END && event.originalEvent.touches.length !== 1) {\n                break;\n            }\n        case DRAG_AND_DROP_DISPATCH_ACTION.END: {\n            onIsPressedChange(false);\n            onIsScrollingChange(false);\n            onScrollOffsetChange({ x: 0, y: 0 });\n            if (drag.onRelease) {\n                drag.onRelease(event);\n            }\n            if (state.drop && state.drop.onDrop) {\n                state.drop.onDrop(event);\n            }\n            if (state.drag && drag.onDragEnd) {\n                drag.onDragEnd(event);\n            }\n            break;\n        }\n        case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_CANCEL:\n        case DRAG_AND_DROP_DISPATCH_ACTION.CONTEXT_MENU:\n        case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_CANCEL:\n        case DRAG_AND_DROP_DISPATCH_ACTION.CANCEL: {\n            onIsPressedChange(false);\n            onIsScrollingChange(false);\n            onScrollOffsetChange({ x: 0, y: 0 });\n            if (drag.onDragEnd) {\n                drag.onDragEnd(event);\n            }\n            if (state.drop && state.drop.onDragLeave) {\n                state.drop.onDragLeave(event);\n            }\n            break;\n        }\n        default:\n            break;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}