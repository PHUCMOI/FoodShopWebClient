{"ast":null,"code":"import { drawing as draw } from '@progress/kendo-drawing';\nimport { alignPathToPixel } from '../common';\nimport { ChartElement } from '../core';\nclass ChartContainer extends ChartElement {\n  constructor(options, pane) {\n    super(options);\n    this.pane = pane;\n  }\n  shouldClip() {\n    const children = this.children;\n    const length = children.length;\n    for (let i = 0; i < length; i++) {\n      if (children[i].options.clip === true) {\n        return true;\n      }\n    }\n    return false;\n  }\n  _clipBox() {\n    return this.pane.chartsBox();\n  }\n  createVisual() {\n    this.visual = new draw.Group({\n      zIndex: 0\n    });\n    if (this.shouldClip()) {\n      const clipBox = this.clipBox = this._clipBox();\n      const clipRect = clipBox.toRect();\n      const clipPath = draw.Path.fromRect(clipRect);\n      alignPathToPixel(clipPath);\n      this.visual.clip(clipPath);\n      this.unclipLabels();\n    }\n  }\n  stackRoot() {\n    return this;\n  }\n  unclipLabels() {\n    const {\n      children: charts,\n      clipBox\n    } = this;\n    for (let i = 0; i < charts.length; i++) {\n      const points = charts[i].points || {};\n      const length = points.length;\n      for (let j = 0; j < length; j++) {\n        const point = points[j];\n        if (point && point.visible !== false && point.overlapsBox && point.overlapsBox(clipBox)) {\n          if (point.unclipElements) {\n            point.unclipElements();\n          } else {\n            const {\n              label,\n              note\n            } = point;\n            if (label && label.options.visible) {\n              if (label.alignToClipBox) {\n                label.alignToClipBox(clipBox);\n              }\n              label.options.noclip = true;\n            }\n            if (note && note.options.visible) {\n              note.options.noclip = true;\n            }\n          }\n        }\n      }\n    }\n  }\n  destroy() {\n    super.destroy();\n    delete this.parent;\n  }\n}\nChartContainer.prototype.isStackRoot = true;\nexport default ChartContainer;","map":{"version":3,"names":["drawing","draw","alignPathToPixel","ChartElement","ChartContainer","constructor","options","pane","shouldClip","children","length","i","clip","_clipBox","chartsBox","createVisual","visual","Group","zIndex","clipBox","clipRect","toRect","clipPath","Path","fromRect","unclipLabels","stackRoot","charts","points","j","point","visible","overlapsBox","unclipElements","label","note","alignToClipBox","noclip","destroy","parent","prototype","isStackRoot"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/chart-container.js"],"sourcesContent":["import { drawing as draw } from '@progress/kendo-drawing';\nimport { alignPathToPixel } from '../common';\n\nimport { ChartElement } from '../core';\n\nclass ChartContainer extends ChartElement {\n    constructor(options, pane) {\n        super(options);\n        this.pane = pane;\n    }\n\n    shouldClip() {\n        const children = this.children;\n        const length = children.length;\n\n        for (let i = 0; i < length; i++) {\n            if (children[i].options.clip === true) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    _clipBox() {\n        return this.pane.chartsBox();\n    }\n\n    createVisual() {\n        this.visual = new draw.Group({\n            zIndex: 0\n        });\n\n        if (this.shouldClip()) {\n            const clipBox = this.clipBox = this._clipBox();\n            const clipRect = clipBox.toRect();\n            const clipPath = draw.Path.fromRect(clipRect);\n            alignPathToPixel(clipPath);\n\n            this.visual.clip(clipPath);\n            this.unclipLabels();\n        }\n    }\n\n    stackRoot() {\n        return this;\n    }\n\n    unclipLabels() {\n        const { children: charts, clipBox } = this;\n\n        for (let i = 0; i < charts.length; i++) {\n            const points = charts[i].points || {};\n            const length = points.length;\n\n            for (let j = 0; j < length; j++) {\n                const point = points[j];\n                if (point && point.visible !== false && point.overlapsBox && point.overlapsBox(clipBox)) {\n                    if (point.unclipElements) {\n                        point.unclipElements();\n                    } else {\n                        const { label, note } = point;\n\n                        if (label && label.options.visible) {\n                            if (label.alignToClipBox) {\n                                label.alignToClipBox(clipBox);\n                            }\n                            label.options.noclip = true;\n                        }\n\n                        if (note && note.options.visible) {\n                            note.options.noclip = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    destroy() {\n        super.destroy();\n\n        delete this.parent;\n    }\n}\n\nChartContainer.prototype.isStackRoot = true;\n\nexport default ChartContainer;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}