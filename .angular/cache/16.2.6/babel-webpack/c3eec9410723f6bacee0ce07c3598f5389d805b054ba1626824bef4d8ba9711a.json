{"ast":null,"code":"import Point from '../geometry/point';\nimport { last } from '../util';\nconst ShapeMap = {\n  l: function (path, options) {\n    const {\n      parameters,\n      position\n    } = options;\n    for (let i = 0; i < parameters.length; i += 2) {\n      let point = new Point(parameters[i], parameters[i + 1]);\n      if (options.isRelative) {\n        point.translateWith(position);\n      }\n      path.lineTo(point.x, point.y);\n      position.x = point.x;\n      position.y = point.y;\n    }\n  },\n  c: function (path, options) {\n    const {\n      parameters,\n      position\n    } = options;\n    for (let i = 0; i < parameters.length; i += 6) {\n      let controlOut = new Point(parameters[i], parameters[i + 1]);\n      let controlIn = new Point(parameters[i + 2], parameters[i + 3]);\n      let point = new Point(parameters[i + 4], parameters[i + 5]);\n      if (options.isRelative) {\n        controlIn.translateWith(position);\n        controlOut.translateWith(position);\n        point.translateWith(position);\n      }\n      path.curveTo(controlOut, controlIn, point);\n      position.x = point.x;\n      position.y = point.y;\n    }\n  },\n  v: function (path, options) {\n    const value = options.isRelative ? 0 : options.position.x;\n    toLineParamaters(options.parameters, true, value);\n    this.l(path, options);\n  },\n  h: function (path, options) {\n    const value = options.isRelative ? 0 : options.position.y;\n    toLineParamaters(options.parameters, false, value);\n    this.l(path, options);\n  },\n  a: function (path, options) {\n    const {\n      parameters,\n      position\n    } = options;\n    for (let i = 0; i < parameters.length; i += 7) {\n      const radiusX = parameters[i];\n      const radiusY = parameters[i + 1];\n      const rotation = parameters[i + 2];\n      const largeArc = parameters[i + 3];\n      const swipe = parameters[i + 4];\n      const endPoint = new Point(parameters[i + 5], parameters[i + 6]);\n      if (options.isRelative) {\n        endPoint.translateWith(position);\n      }\n      if (position.x !== endPoint.x || position.y !== endPoint.y) {\n        path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);\n        position.x = endPoint.x;\n        position.y = endPoint.y;\n      }\n    }\n  },\n  s: function (path, options) {\n    const {\n      parameters,\n      position,\n      previousCommand\n    } = options;\n    let lastControlIn;\n    if (previousCommand === \"s\" || previousCommand === \"c\") {\n      lastControlIn = last(last(path.paths).segments).controlIn();\n    }\n    for (let i = 0; i < parameters.length; i += 4) {\n      let controlIn = new Point(parameters[i], parameters[i + 1]);\n      let endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n      let controlOut;\n      if (options.isRelative) {\n        controlIn.translateWith(position);\n        endPoint.translateWith(position);\n      }\n      if (lastControlIn) {\n        controlOut = reflectionPoint(lastControlIn, position);\n      } else {\n        controlOut = position.clone();\n      }\n      lastControlIn = controlIn;\n      path.curveTo(controlOut, controlIn, endPoint);\n      position.x = endPoint.x;\n      position.y = endPoint.y;\n    }\n  },\n  q: function (path, options) {\n    const {\n      parameters,\n      position\n    } = options;\n    for (let i = 0; i < parameters.length; i += 4) {\n      let controlPoint = new Point(parameters[i], parameters[i + 1]);\n      let endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n      if (options.isRelative) {\n        controlPoint.translateWith(position);\n        endPoint.translateWith(position);\n      }\n      let cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n      position.x = endPoint.x;\n      position.y = endPoint.y;\n    }\n  },\n  t: function (path, options) {\n    const {\n      parameters,\n      position,\n      previousCommand\n    } = options;\n    let controlPoint;\n    if (previousCommand === \"q\" || previousCommand === \"t\") {\n      let lastSegment = last(last(path.paths).segments);\n      controlPoint = lastSegment.controlIn().clone().translateWith(position.scaleCopy(-1 / 3)).scale(3 / 2);\n    }\n    for (let i = 0; i < parameters.length; i += 2) {\n      let endPoint = new Point(parameters[i], parameters[i + 1]);\n      if (options.isRelative) {\n        endPoint.translateWith(position);\n      }\n      if (controlPoint) {\n        controlPoint = reflectionPoint(controlPoint, position);\n      } else {\n        controlPoint = position.clone();\n      }\n      let cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n      position.x = endPoint.x;\n      position.y = endPoint.y;\n    }\n  }\n};\nfunction toLineParamaters(parameters, isVertical, value) {\n  const insertPosition = isVertical ? 0 : 1;\n  for (let i = 0; i < parameters.length; i += 2) {\n    parameters.splice(i + insertPosition, 0, value);\n  }\n}\nfunction reflectionPoint(point, center) {\n  if (point && center) {\n    return center.scaleCopy(2).translate(-point.x, -point.y);\n  }\n}\nconst third = 1 / 3;\nfunction quadraticToCubicControlPoints(position, controlPoint, endPoint) {\n  const scaledPoint = controlPoint.clone().scale(2 / 3);\n  return {\n    controlOut: scaledPoint.clone().translateWith(position.scaleCopy(third)),\n    controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))\n  };\n}\nexport default ShapeMap;","map":{"version":3,"names":["Point","last","ShapeMap","l","path","options","parameters","position","i","length","point","isRelative","translateWith","lineTo","x","y","c","controlOut","controlIn","curveTo","v","value","toLineParamaters","h","a","radiusX","radiusY","rotation","largeArc","swipe","endPoint","arcTo","s","previousCommand","lastControlIn","paths","segments","reflectionPoint","clone","q","controlPoint","cubicControlPoints","quadraticToCubicControlPoints","t","lastSegment","scaleCopy","scale","isVertical","insertPosition","splice","center","translate","third","scaledPoint"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-drawing/dist/es2015/parsing/shape-map.js"],"sourcesContent":["import Point from '../geometry/point';\nimport { last } from '../util';\n\nconst ShapeMap = {\n    l: function(path, options) {\n        const { parameters, position } = options;\n\n        for (let i = 0; i < parameters.length; i += 2) {\n            let point = new Point(parameters[i], parameters[i + 1]);\n\n            if (options.isRelative) {\n                point.translateWith(position);\n            }\n\n            path.lineTo(point.x, point.y);\n\n            position.x = point.x;\n            position.y = point.y;\n        }\n    },\n\n    c: function(path, options) {\n        const { parameters, position } = options;\n\n        for (let i = 0; i < parameters.length; i += 6) {\n            let controlOut = new Point(parameters[i], parameters[i + 1]);\n            let controlIn = new Point(parameters[i + 2], parameters[i + 3]);\n            let point = new Point(parameters[i + 4], parameters[i + 5]);\n            if (options.isRelative) {\n                controlIn.translateWith(position);\n                controlOut.translateWith(position);\n                point.translateWith(position);\n            }\n\n            path.curveTo(controlOut, controlIn, point);\n\n            position.x = point.x;\n            position.y = point.y;\n        }\n    },\n\n    v: function(path, options) {\n        const value = options.isRelative ? 0 : options.position.x;\n\n        toLineParamaters(options.parameters, true, value);\n        this.l(path, options);\n    },\n\n    h: function(path, options) {\n        const value = options.isRelative ? 0 : options.position.y;\n\n        toLineParamaters(options.parameters, false, value);\n        this.l(path, options);\n    },\n\n    a: function(path, options) {\n        const { parameters, position } = options;\n\n        for (let i = 0; i < parameters.length; i += 7) {\n            const radiusX = parameters[i];\n            const radiusY = parameters[i + 1];\n            const rotation = parameters[i + 2];\n            const largeArc = parameters[i + 3];\n            const swipe = parameters[i + 4];\n            const endPoint = new Point(parameters[i + 5], parameters[i + 6]);\n\n            if (options.isRelative) {\n                endPoint.translateWith(position);\n            }\n            if (position.x !== endPoint.x || position.y !== endPoint.y) {\n                path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);\n\n                position.x = endPoint.x;\n                position.y = endPoint.y;\n            }\n        }\n    },\n\n    s: function(path, options) {\n        const { parameters, position, previousCommand } = options;\n        let lastControlIn;\n\n        if (previousCommand === \"s\" || previousCommand === \"c\") {\n            lastControlIn = last(last(path.paths).segments).controlIn();\n        }\n\n        for (let i = 0; i < parameters.length; i += 4) {\n            let controlIn = new Point(parameters[i], parameters[i + 1]);\n            let endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n            let controlOut;\n\n            if (options.isRelative) {\n                controlIn.translateWith(position);\n                endPoint.translateWith(position);\n            }\n\n            if (lastControlIn) {\n                controlOut = reflectionPoint(lastControlIn, position);\n            } else {\n                controlOut = position.clone();\n            }\n\n            lastControlIn = controlIn;\n\n            path.curveTo(controlOut, controlIn, endPoint);\n\n            position.x = endPoint.x;\n            position.y = endPoint.y;\n        }\n    },\n\n    q: function(path, options) {\n        const { parameters, position } = options;\n\n        for (let i = 0; i < parameters.length; i += 4) {\n            let controlPoint = new Point(parameters[i], parameters[i + 1]);\n            let endPoint = new Point(parameters[i + 2], parameters[i + 3]);\n\n            if (options.isRelative) {\n                controlPoint.translateWith(position);\n                endPoint.translateWith(position);\n            }\n\n            let cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n\n            path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n\n            position.x = endPoint.x;\n            position.y = endPoint.y;\n        }\n    },\n\n    t: function(path, options) {\n        const { parameters, position, previousCommand } = options;\n        let controlPoint;\n\n        if (previousCommand === \"q\" || previousCommand === \"t\") {\n            let lastSegment = last(last(path.paths).segments);\n            controlPoint = lastSegment.controlIn().clone()\n                .translateWith(position.scaleCopy(-1 / 3))\n                .scale(3 / 2);\n        }\n\n        for (let i = 0; i < parameters.length; i += 2) {\n            let endPoint = new Point(parameters[i], parameters[i + 1]);\n            if (options.isRelative) {\n                endPoint.translateWith(position);\n            }\n\n            if (controlPoint) {\n                controlPoint = reflectionPoint(controlPoint, position);\n            } else {\n                controlPoint = position.clone();\n            }\n\n            let cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);\n\n            path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);\n\n            position.x = endPoint.x;\n            position.y = endPoint.y;\n        }\n    }\n};\n\nfunction toLineParamaters(parameters, isVertical, value) {\n    const insertPosition = isVertical ? 0 : 1;\n\n    for (let i = 0; i < parameters.length; i += 2) {\n        parameters.splice(i + insertPosition, 0, value);\n    }\n}\n\nfunction reflectionPoint(point, center) {\n    if (point && center) {\n        return center.scaleCopy(2).translate(-point.x, -point.y);\n    }\n}\n\nconst third = 1 / 3;\n\nfunction quadraticToCubicControlPoints(position, controlPoint, endPoint) {\n    const scaledPoint = controlPoint.clone().scale(2 / 3);\n    return {\n        controlOut: scaledPoint.clone().translateWith(position.scaleCopy(third)),\n        controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))\n    };\n}\n\nexport default ShapeMap;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}