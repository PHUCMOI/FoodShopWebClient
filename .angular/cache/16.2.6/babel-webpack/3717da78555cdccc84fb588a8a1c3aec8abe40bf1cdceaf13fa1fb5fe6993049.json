{"ast":null,"code":"import PlotAreaBase from './plotarea-base';\nimport AxisGroupRangeTracker from '../axis-group-range-tracker';\nimport PlotAreaEventsMixin from '../mixins/plotarea-events-mixin';\nimport SeriesAggregator from '../aggregates/series-aggregator';\nimport DefaultAggregates from '../aggregates/default-aggregates';\nimport SeriesBinder from '../series-binder';\nimport BarChart from '../bar-chart/bar-chart';\nimport RangeBarChart from '../range-bar-chart/range-bar-chart';\nimport BulletChart from '../bullet-chart/bullet-chart';\nimport LineChart from '../line-chart/line-chart';\nimport AreaChart from '../area-chart/area-chart';\nimport RangeAreaChart from '../range-area-chart/range-area-chart';\nimport OHLCChart from '../ohlc-chart/ohlc-chart';\nimport CandlestickChart from '../candlestick-chart/candlestick-chart';\nimport BoxPlotChart from '../box-plot-chart/box-plot-chart';\nimport WaterfallChart from '../waterfall-chart/waterfall-chart';\nimport trendlineFactory from '../trendlines/trendline-factory';\nimport trendlineRegistry from '../trendlines/trendline-registry';\nimport { CategoryAxis, DateCategoryAxis, NumericAxis, LogarithmicAxis, Point } from '../../core';\nimport { appendIfNotNull, categoriesCount, createOutOfRangePoints, equalsIgnoreCase, filterSeriesByType, getDateField, getField, isDateAxis, singleItemOrArray } from '../utils';\nimport { BAR, COLUMN, BULLET, VERTICAL_BULLET, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA, RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL, BOX_PLOT, VERTICAL_BOX_PLOT, OHLC, CANDLESTICK, LOGARITHMIC, STEP, EQUALLY_SPACED_SERIES } from '../constants';\nimport { DATE, MAX_VALUE } from '../../common/constants';\nimport { setDefaultOptions, inArray, deepExtend, defined, eventElement, grep } from '../../common';\nconst AREA_SERIES = [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA];\nconst OUT_OF_RANGE_SERIES = [LINE, VERTICAL_LINE].concat(AREA_SERIES);\nclass CategoricalPlotArea extends PlotAreaBase {\n  initFields(series) {\n    this.namedCategoryAxes = {};\n    this.namedValueAxes = {};\n    this.valueAxisRangeTracker = new AxisGroupRangeTracker();\n    this._seriesPointsCache = {};\n    this._currentPointsCache = {};\n    if (series.length > 0) {\n      this.invertAxes = inArray(series[0].type, [BAR, BULLET, VERTICAL_LINE, VERTICAL_AREA, VERTICAL_RANGE_AREA, RANGE_BAR, HORIZONTAL_WATERFALL, VERTICAL_BOX_PLOT]);\n      for (let i = 0; i < series.length; i++) {\n        const stack = series[i].stack;\n        if (stack && stack.type === \"100%\") {\n          this.stack100 = true;\n          break;\n        }\n      }\n    }\n  }\n  render(panes = this.panes) {\n    this.series = [...this.originalSeries];\n    this.createCategoryAxes(panes);\n    this.aggregateCategories(panes);\n    this.createTrendlineSeries(panes);\n    this.createCategoryAxesLabels(panes);\n    this.createCharts(panes);\n    this.createValueAxes(panes);\n  }\n  removeAxis(axis) {\n    const axisName = axis.options.name;\n    super.removeAxis(axis);\n    if (axis instanceof CategoryAxis) {\n      delete this.namedCategoryAxes[axisName];\n    } else {\n      this.valueAxisRangeTracker.reset(axisName);\n      delete this.namedValueAxes[axisName];\n    }\n    if (axis === this.categoryAxis) {\n      delete this.categoryAxis;\n    }\n    if (axis === this.valueAxis) {\n      delete this.valueAxis;\n    }\n  }\n  trendlineFactory(options, series) {\n    const categoryAxis = this.seriesCategoryAxis(options);\n    const seriesValues = this.seriesValues.bind(this, series.index);\n    const trendline = trendlineFactory(trendlineRegistry, options.type, {\n      options,\n      categoryAxis,\n      seriesValues\n    });\n    if (trendline) {\n      // Inherit settings\n      trendline.categoryAxis = series.categoryAxis;\n      trendline.valueAxis = series.valueAxis;\n      return this.filterSeries(trendline, categoryAxis);\n    }\n    return trendline;\n  }\n  trendlineAggregateForecast() {\n    return this.series.map(series => (series.trendline || {}).forecast).filter(forecast => forecast !== undefined).reduce((result, forecast) => ({\n      before: Math.max(result.before, forecast.before || 0),\n      after: Math.max(result.after, forecast.after || 0)\n    }), {\n      before: 0,\n      after: 0\n    });\n  }\n  seriesValues(seriesIx, range) {\n    const result = [];\n    let series = this.srcSeries[seriesIx];\n    const categoryAxis = this.seriesCategoryAxis(series);\n    const dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);\n    if (dateAxis) {\n      this._seriesPointsCache = {};\n      this._currentPointsCache = {};\n      categoryAxis.options.dataItems = [];\n      series = this.aggregateSeries(series, categoryAxis, categoryAxis.totalRangeIndices());\n    }\n    const min = range ? range.min : 0;\n    const max = range ? range.max : series.data.length;\n    for (let categoryIx = min; categoryIx < max; categoryIx++) {\n      const data = this.bindPoint(series, categoryIx);\n      result.push({\n        categoryIx,\n        category: data.fields.category,\n        valueFields: data.valueFields\n      });\n    }\n    return result;\n  }\n  createCharts(panes) {\n    const seriesByPane = this.groupSeriesByPane();\n    for (let i = 0; i < panes.length; i++) {\n      const pane = panes[i];\n      const paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n      this.addToLegend(paneSeries);\n      const visibleSeries = this.filterVisibleSeries(paneSeries);\n      if (!visibleSeries) {\n        continue;\n      }\n      const groups = this.groupSeriesByCategoryAxis(visibleSeries);\n      for (let groupIx = 0; groupIx < groups.length; groupIx++) {\n        this.createChartGroup(groups[groupIx], pane);\n      }\n    }\n  }\n  createChartGroup(series, pane) {\n    this.createAreaChart(filterSeriesByType(series, [AREA, VERTICAL_AREA]), pane);\n    this.createRangeAreaChart(filterSeriesByType(series, [RANGE_AREA, VERTICAL_RANGE_AREA]), pane);\n    this.createBarChart(filterSeriesByType(series, [COLUMN, BAR]), pane);\n    this.createRangeBarChart(filterSeriesByType(series, [RANGE_COLUMN, RANGE_BAR]), pane);\n    this.createBulletChart(filterSeriesByType(series, [BULLET, VERTICAL_BULLET]), pane);\n    this.createCandlestickChart(filterSeriesByType(series, CANDLESTICK), pane);\n    this.createBoxPlotChart(filterSeriesByType(series, [BOX_PLOT, VERTICAL_BOX_PLOT]), pane);\n    this.createOHLCChart(filterSeriesByType(series, OHLC), pane);\n    this.createWaterfallChart(filterSeriesByType(series, [WATERFALL, HORIZONTAL_WATERFALL]), pane);\n    this.createLineChart(filterSeriesByType(series, [LINE, VERTICAL_LINE]), pane);\n  }\n  aggregateCategories(panes) {\n    const series = [...this.series];\n    const processedSeries = [];\n    this._currentPointsCache = {};\n    this._seriesPointsCache = this._seriesPointsCache || {};\n    for (let i = 0; i < series.length; i++) {\n      let currentSeries = series[i];\n      if (!this.isTrendline(currentSeries)) {\n        const categoryAxis = this.seriesCategoryAxis(currentSeries);\n        const axisPane = this.findPane(categoryAxis.options.pane);\n        const dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);\n        if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {\n          currentSeries = this.aggregateSeries(currentSeries, categoryAxis, categoryAxis.currentRangeIndices());\n        } else {\n          currentSeries = this.filterSeries(currentSeries, categoryAxis);\n        }\n      }\n      processedSeries.push(currentSeries);\n    }\n    this._seriesPointsCache = this._currentPointsCache;\n    this._currentPointsCache = null;\n    this.srcSeries = series;\n    this.series = processedSeries;\n  }\n  filterSeries(series, categoryAxis) {\n    const dataLength = (series.data || {}).length;\n    categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);\n    if (!(defined(categoryAxis.options.min) || defined(categoryAxis.options.max))) {\n      return series;\n    }\n    const range = categoryAxis.currentRangeIndices();\n    const outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);\n    const currentSeries = deepExtend({}, series);\n    currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);\n    if (outOfRangePoints) {\n      createOutOfRangePoints(currentSeries, range, dataLength, idx => ({\n        item: series.data[idx],\n        category: categoryAxis.categoryAt(idx, true),\n        categoryIx: idx - range.min\n      }), idx => defined(series.data[idx]));\n    }\n    return currentSeries;\n  }\n  clearSeriesPointsCache() {\n    this._seriesPointsCache = {};\n  }\n  seriesSourcePoints(series, categoryAxis) {\n    const key = `${series.index};${categoryAxis.categoriesHash()}`;\n    if (this._seriesPointsCache && this._seriesPointsCache[key]) {\n      this._currentPointsCache[key] = this._seriesPointsCache[key];\n      return this._seriesPointsCache[key];\n    }\n    const axisOptions = categoryAxis.options;\n    const srcCategories = axisOptions.srcCategories;\n    const dateAxis = equalsIgnoreCase(axisOptions.type, DATE);\n    const srcData = series.data;\n    const getFn = dateAxis ? getDateField : getField;\n    const result = [];\n    if (!dateAxis) {\n      categoryAxis.mapCategories(); //fixes major performance issue caused by searching for the index for large data\n    }\n\n    for (let idx = 0; idx < srcData.length; idx++) {\n      let category;\n      if (series.categoryField) {\n        category = getFn(series.categoryField, srcData[idx], this.chartService.intl);\n      } else {\n        category = srcCategories[idx];\n      }\n      if (defined(category) && category !== null) {\n        const categoryIx = categoryAxis.totalIndex(category);\n        result[categoryIx] = result[categoryIx] || {\n          items: [],\n          category: category\n        };\n        result[categoryIx].items.push(idx);\n      }\n    }\n    this._currentPointsCache[key] = result;\n    return result;\n  }\n  aggregateSeries(series, categoryAxis, range) {\n    const srcData = series.data;\n    if (!srcData.length) {\n      return series;\n    }\n    const srcPoints = this.seriesSourcePoints(series, categoryAxis);\n    const result = deepExtend({}, series);\n    const aggregator = new SeriesAggregator(deepExtend({}, series), SeriesBinder.current, DefaultAggregates.current);\n    const data = result.data = [];\n    const dataItems = categoryAxis.options.dataItems || [];\n    const categoryItem = idx => {\n      const categoryIdx = idx - range.min;\n      let point = srcPoints[idx];\n      if (!point) {\n        point = srcPoints[idx] = {};\n      }\n      point.categoryIx = categoryIdx;\n      if (!point.item) {\n        const category = categoryAxis.categoryAt(idx, true);\n        point.category = category;\n        point.item = aggregator.aggregatePoints(point.items, category);\n      }\n      return point;\n    };\n    for (let idx = range.min; idx <= range.max; idx++) {\n      const point = categoryItem(idx);\n      data[point.categoryIx] = point.item;\n      if (point.items && point.items.length) {\n        dataItems[point.categoryIx] = point.item;\n      }\n    }\n    if (inArray(result.type, OUT_OF_RANGE_SERIES)) {\n      createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, idx => srcPoints[idx]);\n    }\n    categoryAxis.options.dataItems = dataItems;\n    return result;\n  }\n  appendChart(chart, pane) {\n    const series = chart.options.series;\n    const categoryAxis = this.seriesCategoryAxis(series[0]);\n    let categories = categoryAxis.options.categories;\n    let categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);\n    if (categoriesToAdd > 0) {\n      //consider setting an option to axis instead of adding fake categories\n      categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);\n      while (categoriesToAdd--) {\n        categories.push(\"\");\n      }\n    }\n    this.valueAxisRangeTracker.update(chart.valueAxisRanges);\n    super.appendChart(chart, pane);\n  }\n\n  // TODO: Refactor, optionally use series.pane option\n  seriesPaneName(series) {\n    const options = this.options;\n    const axisName = series.axis;\n    const axisOptions = [].concat(options.valueAxis);\n    const axis = grep(axisOptions, function (a) {\n      return a.name === axisName;\n    })[0];\n    const panes = options.panes || [{}];\n    const defaultPaneName = (panes[0] || {}).name || \"default\";\n    const paneName = (axis || {}).pane || defaultPaneName;\n    return paneName;\n  }\n  seriesCategoryAxis(series) {\n    const axisName = series.categoryAxis;\n    const axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;\n    if (!axis) {\n      throw new Error(\"Unable to locate category axis with name \" + axisName);\n    }\n    return axis;\n  }\n  stackableChartOptions(firstSeries, pane) {\n    const stack = firstSeries.stack;\n    const isStacked100 = stack && stack.type === \"100%\";\n    const clip = pane.options.clip;\n    return {\n      isStacked: stack,\n      isStacked100: isStacked100,\n      clip: clip\n    };\n  }\n  groupSeriesByCategoryAxis(series) {\n    const categoryAxes = [];\n    const unique = {};\n    for (let idx = 0; idx < series.length; idx++) {\n      const name = series[idx].categoryAxis || \"$$default$$\";\n      if (!unique.hasOwnProperty(name)) {\n        unique[name] = true;\n        categoryAxes.push(name);\n      }\n    }\n    const groups = [];\n    for (let axisIx = 0; axisIx < categoryAxes.length; axisIx++) {\n      const axis = categoryAxes[axisIx];\n      const axisSeries = groupSeries(series, axis, axisIx);\n      if (axisSeries.length === 0) {\n        continue;\n      }\n      groups.push(axisSeries);\n    }\n    return groups;\n  }\n  createBarChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n    const firstSeries = series[0];\n    const barChart = new BarChart(this, Object.assign({\n      series: series,\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      spacing: firstSeries.spacing\n    }, this.stackableChartOptions(firstSeries, pane)));\n    this.appendChart(barChart, pane);\n  }\n  createRangeBarChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n    const firstSeries = series[0];\n    const rangeColumnChart = new RangeBarChart(this, {\n      series: series,\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      spacing: firstSeries.spacing\n    });\n    this.appendChart(rangeColumnChart, pane);\n  }\n  createBulletChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n    const firstSeries = series[0];\n    const bulletChart = new BulletChart(this, {\n      series: series,\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      spacing: firstSeries.spacing,\n      clip: pane.options.clip\n    });\n    this.appendChart(bulletChart, pane);\n  }\n  createLineChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n    const firstSeries = series[0];\n    const lineChart = new LineChart(this, Object.assign({\n      invertAxes: this.invertAxes,\n      series: series\n    }, this.stackableChartOptions(firstSeries, pane)));\n    this.appendChart(lineChart, pane);\n  }\n  createAreaChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n    const firstSeries = series[0];\n    const areaChart = new AreaChart(this, Object.assign({\n      invertAxes: this.invertAxes,\n      series: series\n    }, this.stackableChartOptions(firstSeries, pane)));\n    this.appendChart(areaChart, pane);\n  }\n  createRangeAreaChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n    const rangeAreaChart = new RangeAreaChart(this, {\n      invertAxes: this.invertAxes,\n      series: series,\n      clip: pane.options.clip\n    });\n    this.appendChart(rangeAreaChart, pane);\n  }\n  createOHLCChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n    const firstSeries = series[0];\n    const chart = new OHLCChart(this, {\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      series: series,\n      spacing: firstSeries.spacing,\n      clip: pane.options.clip\n    });\n    this.appendChart(chart, pane);\n  }\n  createCandlestickChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n    const firstSeries = series[0];\n    const chart = new CandlestickChart(this, {\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      series: series,\n      spacing: firstSeries.spacing,\n      clip: pane.options.clip\n    });\n    this.appendChart(chart, pane);\n  }\n  createBoxPlotChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n    const firstSeries = series[0];\n    const chart = new BoxPlotChart(this, {\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      series: series,\n      spacing: firstSeries.spacing,\n      clip: pane.options.clip\n    });\n    this.appendChart(chart, pane);\n  }\n  createWaterfallChart(series, pane) {\n    if (series.length === 0) {\n      return;\n    }\n    const firstSeries = series[0];\n    const waterfallChart = new WaterfallChart(this, {\n      series: series,\n      invertAxes: this.invertAxes,\n      gap: firstSeries.gap,\n      spacing: firstSeries.spacing\n    });\n    this.appendChart(waterfallChart, pane);\n  }\n  axisRequiresRounding(categoryAxisName, categoryAxisIndex) {\n    const centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);\n    for (let seriesIx = 0; seriesIx < this.series.length; seriesIx++) {\n      const currentSeries = this.series[seriesIx];\n      if (inArray(currentSeries.type, AREA_SERIES)) {\n        const line = currentSeries.line;\n        if (line && line.style === STEP) {\n          centeredSeries.push(currentSeries);\n        }\n      }\n    }\n    for (let seriesIx = 0; seriesIx < centeredSeries.length; seriesIx++) {\n      const seriesAxis = centeredSeries[seriesIx].categoryAxis || \"\";\n      if (seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) {\n        return true;\n      }\n    }\n  }\n  aggregatedAxis(categoryAxisName, categoryAxisIndex) {\n    const series = this.series;\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const seriesAxis = series[seriesIx].categoryAxis || \"\";\n      if ((seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) && series[seriesIx].categoryField) {\n        return true;\n      }\n    }\n  }\n  createCategoryAxesLabels() {\n    const axes = this.axes;\n    for (let i = 0; i < axes.length; i++) {\n      if (axes[i] instanceof CategoryAxis) {\n        axes[i].createLabels();\n      }\n    }\n  }\n  createCategoryAxes(panes) {\n    const invertAxes = this.invertAxes;\n    const definitions = [].concat(this.options.categoryAxis);\n    const axes = [];\n    for (let i = 0; i < definitions.length; i++) {\n      let axisOptions = definitions[i];\n      const axisPane = this.findPane(axisOptions.pane);\n      if (inArray(axisPane, panes)) {\n        const {\n          name,\n          categories = []\n        } = axisOptions;\n        axisOptions = deepExtend({\n          vertical: invertAxes,\n          reverse: !invertAxes && this.chartService.rtl,\n          axisCrossingValue: invertAxes ? MAX_VALUE : 0\n        }, axisOptions);\n        if (!defined(axisOptions.justified)) {\n          axisOptions.justified = this.isJustified();\n        }\n        if (this.axisRequiresRounding(name, i)) {\n          axisOptions.justified = false;\n        }\n        let categoryAxis;\n        if (isDateAxis(axisOptions, categories[0])) {\n          axisOptions._forecast = this.trendlineAggregateForecast();\n          categoryAxis = new DateCategoryAxis(axisOptions, this.chartService);\n        } else {\n          categoryAxis = new CategoryAxis(axisOptions, this.chartService);\n        }\n        definitions[i].categories = categoryAxis.options.srcCategories;\n        if (name) {\n          if (this.namedCategoryAxes[name]) {\n            throw new Error(`Category axis with name ${name} is already defined`);\n          }\n          this.namedCategoryAxes[name] = categoryAxis;\n        }\n        categoryAxis.axisIndex = i;\n        axes.push(categoryAxis);\n        this.appendAxis(categoryAxis);\n      }\n    }\n    const primaryAxis = this.categoryAxis || axes[0];\n    this.categoryAxis = primaryAxis;\n    if (invertAxes) {\n      this.axisY = primaryAxis;\n    } else {\n      this.axisX = primaryAxis;\n    }\n  }\n  isJustified() {\n    const series = this.series;\n    for (let i = 0; i < series.length; i++) {\n      const currentSeries = series[i];\n      if (!inArray(currentSeries.type, AREA_SERIES)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  createValueAxes(panes) {\n    const tracker = this.valueAxisRangeTracker;\n    const defaultRange = tracker.query();\n    const definitions = [].concat(this.options.valueAxis);\n    const invertAxes = this.invertAxes;\n    const baseOptions = {\n      vertical: !invertAxes,\n      reverse: invertAxes && this.chartService.rtl\n    };\n    const axes = [];\n    if (this.stack100) {\n      baseOptions.roundToMajorUnit = false;\n      baseOptions.labels = {\n        format: \"P0\"\n      };\n    }\n    for (let i = 0; i < definitions.length; i++) {\n      const axisOptions = definitions[i];\n      const axisPane = this.findPane(axisOptions.pane);\n      if (inArray(axisPane, panes)) {\n        const name = axisOptions.name;\n        const defaultAxisRange = equalsIgnoreCase(axisOptions.type, LOGARITHMIC) ? {\n          min: 0.1,\n          max: 1\n        } : {\n          min: 0,\n          max: 1\n        };\n        const range = tracker.query(name) || defaultRange || defaultAxisRange;\n        if (i === 0 && range && defaultRange) {\n          range.min = Math.min(range.min, defaultRange.min);\n          range.max = Math.max(range.max, defaultRange.max);\n        }\n        let axisType;\n        if (equalsIgnoreCase(axisOptions.type, LOGARITHMIC)) {\n          axisType = LogarithmicAxis;\n        } else {\n          axisType = NumericAxis;\n        }\n        const valueAxis = new axisType(range.min, range.max, deepExtend({}, baseOptions, axisOptions), this.chartService);\n        if (name) {\n          if (this.namedValueAxes[name]) {\n            throw new Error(`Value axis with name ${name} is already defined`);\n          }\n          this.namedValueAxes[name] = valueAxis;\n        }\n        valueAxis.axisIndex = i;\n        axes.push(valueAxis);\n        this.appendAxis(valueAxis);\n      }\n    }\n    const primaryAxis = this.valueAxis || axes[0];\n    this.valueAxis = primaryAxis;\n    if (invertAxes) {\n      this.axisX = primaryAxis;\n    } else {\n      this.axisY = primaryAxis;\n    }\n  }\n  _dispatchEvent(chart, e, eventType) {\n    const coords = chart._eventCoordinates(e);\n    const point = new Point(coords.x, coords.y);\n    const pane = this.pointPane(point);\n    const categories = [];\n    const values = [];\n    if (!pane) {\n      return;\n    }\n    const allAxes = pane.axes;\n    for (let i = 0; i < allAxes.length; i++) {\n      const axis = allAxes[i];\n      if (axis.getValue) {\n        appendIfNotNull(values, axis.getValue(point));\n      } else {\n        appendIfNotNull(categories, axis.getCategory(point));\n      }\n    }\n    if (categories.length === 0) {\n      appendIfNotNull(categories, this.categoryAxis.getCategory(point));\n    }\n    if (categories.length > 0 && values.length > 0) {\n      chart.trigger(eventType, {\n        element: eventElement(e),\n        originalEvent: e,\n        category: singleItemOrArray(categories),\n        value: singleItemOrArray(values)\n      });\n    }\n  }\n  pointPane(point) {\n    const panes = this.panes;\n    for (let i = 0; i < panes.length; i++) {\n      const currentPane = panes[i];\n      if (currentPane.contentBox.containsPoint(point)) {\n        return currentPane;\n      }\n    }\n  }\n  updateAxisOptions(axis, options) {\n    updateAxisOptions(this.options, axis, options);\n    updateAxisOptions(this.originalOptions, axis, options);\n  }\n}\nfunction updateAxisOptions(targetOptions, axis, options) {\n  const axesOptions = axis instanceof CategoryAxis ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);\n  deepExtend(axesOptions[axis.axisIndex], options);\n}\nfunction groupSeries(series, axis, axisIx) {\n  return grep(series, function (s) {\n    return axisIx === 0 && !s.categoryAxis || s.categoryAxis === axis;\n  });\n}\nsetDefaultOptions(CategoricalPlotArea, {\n  categoryAxis: {},\n  valueAxis: {}\n});\ndeepExtend(CategoricalPlotArea.prototype, PlotAreaEventsMixin);\nexport default CategoricalPlotArea;","map":{"version":3,"names":["PlotAreaBase","AxisGroupRangeTracker","PlotAreaEventsMixin","SeriesAggregator","DefaultAggregates","SeriesBinder","BarChart","RangeBarChart","BulletChart","LineChart","AreaChart","RangeAreaChart","OHLCChart","CandlestickChart","BoxPlotChart","WaterfallChart","trendlineFactory","trendlineRegistry","CategoryAxis","DateCategoryAxis","NumericAxis","LogarithmicAxis","Point","appendIfNotNull","categoriesCount","createOutOfRangePoints","equalsIgnoreCase","filterSeriesByType","getDateField","getField","isDateAxis","singleItemOrArray","BAR","COLUMN","BULLET","VERTICAL_BULLET","LINE","VERTICAL_LINE","AREA","VERTICAL_AREA","RANGE_AREA","VERTICAL_RANGE_AREA","RANGE_COLUMN","RANGE_BAR","WATERFALL","HORIZONTAL_WATERFALL","BOX_PLOT","VERTICAL_BOX_PLOT","OHLC","CANDLESTICK","LOGARITHMIC","STEP","EQUALLY_SPACED_SERIES","DATE","MAX_VALUE","setDefaultOptions","inArray","deepExtend","defined","eventElement","grep","AREA_SERIES","OUT_OF_RANGE_SERIES","concat","CategoricalPlotArea","initFields","series","namedCategoryAxes","namedValueAxes","valueAxisRangeTracker","_seriesPointsCache","_currentPointsCache","length","invertAxes","type","i","stack","stack100","render","panes","originalSeries","createCategoryAxes","aggregateCategories","createTrendlineSeries","createCategoryAxesLabels","createCharts","createValueAxes","removeAxis","axis","axisName","options","name","reset","categoryAxis","valueAxis","seriesCategoryAxis","seriesValues","bind","index","trendline","filterSeries","trendlineAggregateForecast","map","forecast","filter","undefined","reduce","result","before","Math","max","after","seriesIx","range","srcSeries","dateAxis","dataItems","aggregateSeries","totalRangeIndices","min","data","categoryIx","bindPoint","push","category","fields","valueFields","seriesByPane","groupSeriesByPane","pane","paneSeries","addToLegend","visibleSeries","filterVisibleSeries","groups","groupSeriesByCategoryAxis","groupIx","createChartGroup","createAreaChart","createRangeAreaChart","createBarChart","createRangeBarChart","createBulletChart","createCandlestickChart","createBoxPlotChart","createOHLCChart","createWaterfallChart","createLineChart","processedSeries","currentSeries","isTrendline","axisPane","findPane","categoryField","currentRangeIndices","dataLength","_seriesMax","outOfRangePoints","slice","idx","item","categoryAt","clearSeriesPointsCache","seriesSourcePoints","key","categoriesHash","axisOptions","srcCategories","srcData","getFn","mapCategories","chartService","intl","totalIndex","items","srcPoints","aggregator","current","categoryItem","categoryIdx","point","aggregatePoints","totalCount","appendChart","chart","categories","categoriesToAdd","update","valueAxisRanges","seriesPaneName","a","defaultPaneName","paneName","Error","stackableChartOptions","firstSeries","isStacked100","clip","isStacked","categoryAxes","unique","hasOwnProperty","axisIx","axisSeries","groupSeries","barChart","Object","assign","gap","spacing","rangeColumnChart","bulletChart","lineChart","areaChart","rangeAreaChart","waterfallChart","axisRequiresRounding","categoryAxisName","categoryAxisIndex","centeredSeries","line","style","seriesAxis","aggregatedAxis","axes","createLabels","definitions","vertical","reverse","rtl","axisCrossingValue","justified","isJustified","_forecast","axisIndex","appendAxis","primaryAxis","axisY","axisX","tracker","defaultRange","query","baseOptions","roundToMajorUnit","labels","format","defaultAxisRange","axisType","_dispatchEvent","e","eventType","coords","_eventCoordinates","x","y","pointPane","values","allAxes","getValue","getCategory","trigger","element","originalEvent","value","currentPane","contentBox","containsPoint","updateAxisOptions","originalOptions","targetOptions","axesOptions","s","prototype"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/plotarea/categorical-plotarea.js"],"sourcesContent":["import PlotAreaBase from './plotarea-base';\nimport AxisGroupRangeTracker from '../axis-group-range-tracker';\nimport PlotAreaEventsMixin from '../mixins/plotarea-events-mixin';\nimport SeriesAggregator from '../aggregates/series-aggregator';\nimport DefaultAggregates from '../aggregates/default-aggregates';\nimport SeriesBinder from '../series-binder';\nimport BarChart from '../bar-chart/bar-chart';\nimport RangeBarChart from '../range-bar-chart/range-bar-chart';\nimport BulletChart from '../bullet-chart/bullet-chart';\nimport LineChart from '../line-chart/line-chart';\nimport AreaChart from '../area-chart/area-chart';\nimport RangeAreaChart from '../range-area-chart/range-area-chart';\nimport OHLCChart from '../ohlc-chart/ohlc-chart';\nimport CandlestickChart from '../candlestick-chart/candlestick-chart';\nimport BoxPlotChart from '../box-plot-chart/box-plot-chart';\nimport WaterfallChart from '../waterfall-chart/waterfall-chart';\nimport trendlineFactory from '../trendlines/trendline-factory';\nimport trendlineRegistry from '../trendlines/trendline-registry';\n\nimport { CategoryAxis, DateCategoryAxis, NumericAxis, LogarithmicAxis, Point } from '../../core';\n\nimport { appendIfNotNull, categoriesCount, createOutOfRangePoints, equalsIgnoreCase, filterSeriesByType,\n    getDateField, getField, isDateAxis, singleItemOrArray } from '../utils';\n\nimport { BAR, COLUMN, BULLET, VERTICAL_BULLET, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA,\n    RANGE_AREA, VERTICAL_RANGE_AREA, RANGE_COLUMN, RANGE_BAR, WATERFALL, HORIZONTAL_WATERFALL,\n    BOX_PLOT, VERTICAL_BOX_PLOT, OHLC, CANDLESTICK, LOGARITHMIC, STEP, EQUALLY_SPACED_SERIES } from '../constants';\n\nimport { DATE, MAX_VALUE } from '../../common/constants';\nimport { setDefaultOptions, inArray, deepExtend, defined, eventElement, grep } from '../../common';\n\nconst AREA_SERIES = [ AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA ];\nconst OUT_OF_RANGE_SERIES = [ LINE, VERTICAL_LINE ].concat(AREA_SERIES);\n\nclass CategoricalPlotArea extends PlotAreaBase {\n\n    initFields(series) {\n        this.namedCategoryAxes = {};\n        this.namedValueAxes = {};\n        this.valueAxisRangeTracker = new AxisGroupRangeTracker();\n        this._seriesPointsCache = {};\n        this._currentPointsCache = {};\n\n        if (series.length > 0) {\n            this.invertAxes = inArray(\n                series[0].type, [ BAR, BULLET, VERTICAL_LINE, VERTICAL_AREA, VERTICAL_RANGE_AREA,\n                                 RANGE_BAR, HORIZONTAL_WATERFALL, VERTICAL_BOX_PLOT ]\n            );\n\n            for (let i = 0; i < series.length; i++) {\n                const stack = series[i].stack;\n                if (stack && stack.type === \"100%\") {\n                    this.stack100 = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    render(panes = this.panes) {\n        this.series = [...this.originalSeries];\n        this.createCategoryAxes(panes);\n\n        this.aggregateCategories(panes);\n        this.createTrendlineSeries(panes);\n\n        this.createCategoryAxesLabels(panes);\n        this.createCharts(panes);\n        this.createValueAxes(panes);\n    }\n\n    removeAxis(axis) {\n        const axisName = axis.options.name;\n\n        super.removeAxis(axis);\n\n        if (axis instanceof CategoryAxis) {\n            delete this.namedCategoryAxes[axisName];\n        } else {\n            this.valueAxisRangeTracker.reset(axisName);\n            delete this.namedValueAxes[axisName];\n        }\n\n        if (axis === this.categoryAxis) {\n            delete this.categoryAxis;\n        }\n\n        if (axis === this.valueAxis) {\n            delete this.valueAxis;\n        }\n    }\n\n    trendlineFactory(options, series) {\n        const categoryAxis = this.seriesCategoryAxis(options);\n        const seriesValues = this.seriesValues.bind(this, series.index);\n\n        const trendline = trendlineFactory(trendlineRegistry, options.type, {\n            options,\n            categoryAxis,\n            seriesValues\n        });\n\n        if (trendline) {\n            // Inherit settings\n            trendline.categoryAxis = series.categoryAxis;\n            trendline.valueAxis = series.valueAxis;\n\n            return this.filterSeries(trendline, categoryAxis);\n        }\n\n        return trendline;\n    }\n\n    trendlineAggregateForecast() {\n        return this.series\n            .map(series => (series.trendline || {}).forecast)\n            .filter(forecast => forecast !== undefined)\n            .reduce((result, forecast) => ({\n                before: Math.max(result.before, forecast.before || 0),\n                after: Math.max(result.after, forecast.after || 0)\n            }), { before: 0, after: 0 });\n    }\n\n    seriesValues(seriesIx, range) {\n        const result = [];\n\n        let series = this.srcSeries[seriesIx];\n        const categoryAxis = this.seriesCategoryAxis(series);\n        const dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);\n        if (dateAxis) {\n            this._seriesPointsCache = {};\n            this._currentPointsCache = {};\n            categoryAxis.options.dataItems = [];\n            series = this.aggregateSeries(series, categoryAxis, categoryAxis.totalRangeIndices());\n        }\n\n        const min = range ? range.min : 0;\n        const max = range ? range.max : series.data.length;\n        for (let categoryIx = min; categoryIx < max; categoryIx++) {\n            const data = this.bindPoint(series, categoryIx);\n            result.push({ categoryIx, category: data.fields.category, valueFields: data.valueFields });\n        }\n\n        return result;\n    }\n\n    createCharts(panes) {\n        const seriesByPane = this.groupSeriesByPane();\n\n        for (let i = 0; i < panes.length; i++) {\n            const pane = panes[i];\n            const paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n            this.addToLegend(paneSeries);\n\n            const visibleSeries = this.filterVisibleSeries(paneSeries);\n            if (!visibleSeries) {\n                continue;\n            }\n\n            const groups = this.groupSeriesByCategoryAxis(visibleSeries);\n            for (let groupIx = 0; groupIx < groups.length; groupIx++) {\n                this.createChartGroup(groups[groupIx], pane);\n            }\n        }\n    }\n\n    createChartGroup(series, pane) {\n        this.createAreaChart(\n            filterSeriesByType(series, [ AREA, VERTICAL_AREA ]), pane\n        );\n\n        this.createRangeAreaChart(\n            filterSeriesByType(series, [ RANGE_AREA, VERTICAL_RANGE_AREA ]), pane\n        );\n\n        this.createBarChart(\n            filterSeriesByType(series, [ COLUMN, BAR ]), pane\n        );\n\n        this.createRangeBarChart(\n            filterSeriesByType(series, [ RANGE_COLUMN, RANGE_BAR ]), pane\n        );\n\n        this.createBulletChart(\n            filterSeriesByType(series, [ BULLET, VERTICAL_BULLET ]), pane\n        );\n\n        this.createCandlestickChart(\n            filterSeriesByType(series, CANDLESTICK), pane\n        );\n\n        this.createBoxPlotChart(\n            filterSeriesByType(series, [ BOX_PLOT, VERTICAL_BOX_PLOT ]), pane\n        );\n\n        this.createOHLCChart(\n            filterSeriesByType(series, OHLC), pane\n        );\n\n        this.createWaterfallChart(\n            filterSeriesByType(series, [ WATERFALL, HORIZONTAL_WATERFALL ]), pane\n        );\n\n        this.createLineChart(\n            filterSeriesByType(series, [ LINE, VERTICAL_LINE ]), pane\n        );\n    }\n\n    aggregateCategories(panes) {\n        const series = [...this.series];\n        const processedSeries = [];\n        this._currentPointsCache = {};\n        this._seriesPointsCache = this._seriesPointsCache || {};\n\n        for (let i = 0; i < series.length; i++) {\n            let currentSeries = series[i];\n\n            if (!this.isTrendline(currentSeries)) {\n                const categoryAxis = this.seriesCategoryAxis(currentSeries);\n                const axisPane = this.findPane(categoryAxis.options.pane);\n                const dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);\n\n                if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {\n                    currentSeries = this.aggregateSeries(currentSeries, categoryAxis, categoryAxis.currentRangeIndices());\n                } else {\n                    currentSeries = this.filterSeries(currentSeries, categoryAxis);\n                }\n            }\n\n            processedSeries.push(currentSeries);\n        }\n\n        this._seriesPointsCache = this._currentPointsCache;\n        this._currentPointsCache = null;\n\n        this.srcSeries = series;\n        this.series = processedSeries;\n    }\n\n    filterSeries(series, categoryAxis) {\n        const dataLength = (series.data || {}).length;\n        categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);\n\n        if (!(defined(categoryAxis.options.min) || defined(categoryAxis.options.max))) {\n            return series;\n        }\n\n        const range = categoryAxis.currentRangeIndices();\n        const outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);\n        const currentSeries = deepExtend({}, series);\n\n        currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);\n\n        if (outOfRangePoints) {\n            createOutOfRangePoints(currentSeries, range, dataLength, (idx) => ({\n                item: series.data[idx],\n                category: categoryAxis.categoryAt(idx, true),\n                categoryIx: idx - range.min\n            }), (idx) => defined(series.data[idx]));\n        }\n\n        return currentSeries;\n    }\n\n    clearSeriesPointsCache() {\n        this._seriesPointsCache = {};\n    }\n\n    seriesSourcePoints(series, categoryAxis) {\n        const key = `${ series.index };${ categoryAxis.categoriesHash() }`;\n        if (this._seriesPointsCache && this._seriesPointsCache[key]) {\n            this._currentPointsCache[key] = this._seriesPointsCache[key];\n            return this._seriesPointsCache[key];\n        }\n\n        const axisOptions = categoryAxis.options;\n        const srcCategories = axisOptions.srcCategories;\n        const dateAxis = equalsIgnoreCase(axisOptions.type, DATE);\n        const srcData = series.data;\n        const getFn = dateAxis ? getDateField : getField;\n        const result = [];\n        if (!dateAxis) {\n            categoryAxis.mapCategories(); //fixes major performance issue caused by searching for the index for large data\n        }\n\n        for (let idx = 0; idx < srcData.length; idx++) {\n            let category;\n            if (series.categoryField) {\n                category = getFn(series.categoryField, srcData[idx], this.chartService.intl);\n            } else {\n                category = srcCategories[idx];\n            }\n\n            if (defined(category) && category !== null) {\n                const categoryIx = categoryAxis.totalIndex(category);\n                result[categoryIx] = result[categoryIx] || { items: [], category: category };\n                result[categoryIx].items.push(idx);\n            }\n        }\n\n        this._currentPointsCache[key] = result;\n\n        return result;\n    }\n\n    aggregateSeries(series, categoryAxis, range) {\n        const srcData = series.data;\n        if (!srcData.length) {\n            return series;\n        }\n\n        const srcPoints = this.seriesSourcePoints(series, categoryAxis);\n        const result = deepExtend({}, series);\n        const aggregator = new SeriesAggregator(deepExtend({}, series), SeriesBinder.current, DefaultAggregates.current);\n        const data = result.data = [];\n\n        const dataItems = categoryAxis.options.dataItems || [];\n\n        const categoryItem = (idx) => {\n            const categoryIdx = idx - range.min;\n            let point = srcPoints[idx];\n            if (!point) {\n                point = srcPoints[idx] = {};\n            }\n\n            point.categoryIx = categoryIdx;\n\n            if (!point.item) {\n                const category = categoryAxis.categoryAt(idx, true);\n                point.category = category;\n                point.item = aggregator.aggregatePoints(point.items, category);\n            }\n\n            return point;\n        };\n\n        for (let idx = range.min; idx <= range.max; idx++) {\n            const point = categoryItem(idx);\n            data[point.categoryIx] = point.item;\n\n            if (point.items && point.items.length) {\n                dataItems[point.categoryIx] = point.item;\n            }\n        }\n\n        if (inArray(result.type, OUT_OF_RANGE_SERIES)) {\n            createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, (idx) => srcPoints[idx]);\n        }\n\n        categoryAxis.options.dataItems = dataItems;\n\n        return result;\n    }\n\n    appendChart(chart, pane) {\n        const series = chart.options.series;\n        const categoryAxis = this.seriesCategoryAxis(series[0]);\n        let categories = categoryAxis.options.categories;\n        let categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);\n\n        if (categoriesToAdd > 0) {//consider setting an option to axis instead of adding fake categories\n            categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);\n            while (categoriesToAdd--) {\n                categories.push(\"\");\n            }\n        }\n\n        this.valueAxisRangeTracker.update(chart.valueAxisRanges);\n\n        super.appendChart(chart, pane);\n    }\n\n    // TODO: Refactor, optionally use series.pane option\n    seriesPaneName(series) {\n        const options = this.options;\n        const axisName = series.axis;\n        const axisOptions = [].concat(options.valueAxis);\n        const axis = grep(axisOptions, function(a) { return a.name === axisName; })[0];\n        const panes = options.panes || [ {} ];\n        const defaultPaneName = (panes[0] || {}).name || \"default\";\n        const paneName = (axis || {}).pane || defaultPaneName;\n\n        return paneName;\n    }\n\n    seriesCategoryAxis(series) {\n        const axisName = series.categoryAxis;\n        const axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;\n\n        if (!axis) {\n            throw new Error(\"Unable to locate category axis with name \" + axisName);\n        }\n\n        return axis;\n    }\n\n    stackableChartOptions(firstSeries, pane) {\n        const stack = firstSeries.stack;\n        const isStacked100 = stack && stack.type === \"100%\";\n        const clip = pane.options.clip;\n\n        return {\n            isStacked: stack,\n            isStacked100: isStacked100,\n            clip: clip\n        };\n    }\n\n    groupSeriesByCategoryAxis(series) {\n        const categoryAxes = [];\n        const unique = {};\n        for (let idx = 0; idx < series.length; idx++) {\n            const name = series[idx].categoryAxis || \"$$default$$\";\n            if (!unique.hasOwnProperty(name)) {\n                unique[name] = true;\n                categoryAxes.push(name);\n            }\n        }\n\n        const groups = [];\n        for (let axisIx = 0; axisIx < categoryAxes.length; axisIx++) {\n            const axis = categoryAxes[axisIx];\n            const axisSeries = groupSeries(series, axis, axisIx);\n            if (axisSeries.length === 0) {\n                continue;\n            }\n\n            groups.push(axisSeries);\n        }\n\n        return groups;\n    }\n\n    createBarChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const barChart = new BarChart(this, Object.assign({\n            series: series,\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            spacing: firstSeries.spacing\n        }, this.stackableChartOptions(firstSeries, pane)));\n\n        this.appendChart(barChart, pane);\n    }\n\n    createRangeBarChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const rangeColumnChart = new RangeBarChart(this, {\n            series: series,\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            spacing: firstSeries.spacing\n        });\n\n        this.appendChart(rangeColumnChart, pane);\n    }\n\n    createBulletChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const bulletChart = new BulletChart(this, {\n            series: series,\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            spacing: firstSeries.spacing,\n            clip: pane.options.clip\n        });\n\n        this.appendChart(bulletChart, pane);\n    }\n\n    createLineChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const lineChart = new LineChart(this, Object.assign({\n            invertAxes: this.invertAxes,\n            series: series\n        }, this.stackableChartOptions(firstSeries, pane)));\n\n        this.appendChart(lineChart, pane);\n    }\n\n    createAreaChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const areaChart = new AreaChart(this, Object.assign({\n            invertAxes: this.invertAxes,\n            series: series\n        }, this.stackableChartOptions(firstSeries, pane)));\n\n        this.appendChart(areaChart, pane);\n    }\n\n    createRangeAreaChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const rangeAreaChart = new RangeAreaChart(this, {\n            invertAxes: this.invertAxes,\n            series: series,\n            clip: pane.options.clip\n        });\n\n        this.appendChart(rangeAreaChart, pane);\n    }\n\n    createOHLCChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const chart = new OHLCChart(this, {\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            series: series,\n            spacing: firstSeries.spacing,\n            clip: pane.options.clip\n        });\n\n        this.appendChart(chart, pane);\n    }\n\n    createCandlestickChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const chart = new CandlestickChart(this, {\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            series: series,\n            spacing: firstSeries.spacing,\n            clip: pane.options.clip\n        });\n\n        this.appendChart(chart, pane);\n    }\n\n    createBoxPlotChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const chart = new BoxPlotChart(this, {\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            series: series,\n            spacing: firstSeries.spacing,\n            clip: pane.options.clip\n        });\n\n        this.appendChart(chart, pane);\n    }\n\n    createWaterfallChart(series, pane) {\n        if (series.length === 0) {\n            return;\n        }\n\n        const firstSeries = series[0];\n        const waterfallChart = new WaterfallChart(this, {\n            series: series,\n            invertAxes: this.invertAxes,\n            gap: firstSeries.gap,\n            spacing: firstSeries.spacing\n        });\n\n        this.appendChart(waterfallChart, pane);\n    }\n\n    axisRequiresRounding(categoryAxisName, categoryAxisIndex) {\n        const centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);\n\n        for (let seriesIx = 0; seriesIx < this.series.length; seriesIx++) {\n            const currentSeries = this.series[seriesIx];\n            if (inArray(currentSeries.type, AREA_SERIES)) {\n                const line = currentSeries.line;\n                if (line && line.style === STEP) {\n                    centeredSeries.push(currentSeries);\n                }\n            }\n        }\n\n        for (let seriesIx = 0; seriesIx < centeredSeries.length; seriesIx++) {\n            const seriesAxis = centeredSeries[seriesIx].categoryAxis || \"\";\n            if (seriesAxis === categoryAxisName || (!seriesAxis && categoryAxisIndex === 0)) {\n                return true;\n            }\n        }\n    }\n\n    aggregatedAxis(categoryAxisName, categoryAxisIndex) {\n        const series = this.series;\n\n        for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            const seriesAxis = series[seriesIx].categoryAxis || \"\";\n            if ((seriesAxis === categoryAxisName || (!seriesAxis && categoryAxisIndex === 0)) && series[seriesIx].categoryField) {\n                return true;\n            }\n        }\n    }\n\n    createCategoryAxesLabels() {\n        const axes = this.axes;\n        for (let i = 0; i < axes.length; i++) {\n            if (axes[i] instanceof CategoryAxis) {\n                axes[i].createLabels();\n            }\n        }\n    }\n\n    createCategoryAxes(panes) {\n        const invertAxes = this.invertAxes;\n        const definitions = [].concat(this.options.categoryAxis);\n        const axes = [];\n\n        for (let i = 0; i < definitions.length; i++) {\n            let axisOptions = definitions[i];\n            const axisPane = this.findPane(axisOptions.pane);\n\n            if (inArray(axisPane, panes)) {\n                const { name, categories = [] } = axisOptions;\n                axisOptions = deepExtend({\n                    vertical: invertAxes,\n                    reverse: !invertAxes && this.chartService.rtl,\n                    axisCrossingValue: invertAxes ? MAX_VALUE : 0\n                }, axisOptions);\n\n                if (!defined(axisOptions.justified)) {\n                    axisOptions.justified = this.isJustified();\n                }\n\n                if (this.axisRequiresRounding(name, i)) {\n                    axisOptions.justified = false;\n                }\n\n                let categoryAxis;\n\n                if (isDateAxis(axisOptions, categories[0])) {\n                    axisOptions._forecast = this.trendlineAggregateForecast();\n                    categoryAxis = new DateCategoryAxis(axisOptions, this.chartService);\n                } else {\n                    categoryAxis = new CategoryAxis(axisOptions, this.chartService);\n                }\n\n                definitions[i].categories = categoryAxis.options.srcCategories;\n\n                if (name) {\n                    if (this.namedCategoryAxes[name]) {\n                        throw new Error(`Category axis with name ${ name } is already defined`);\n                    }\n                    this.namedCategoryAxes[name] = categoryAxis;\n                }\n\n                categoryAxis.axisIndex = i;\n                axes.push(categoryAxis);\n                this.appendAxis(categoryAxis);\n            }\n        }\n\n        const primaryAxis = this.categoryAxis || axes[0];\n        this.categoryAxis = primaryAxis;\n\n        if (invertAxes) {\n            this.axisY = primaryAxis;\n        } else {\n            this.axisX = primaryAxis;\n        }\n    }\n\n    isJustified() {\n        const series = this.series;\n\n        for (let i = 0; i < series.length; i++) {\n            const currentSeries = series[i];\n            if (!inArray(currentSeries.type, AREA_SERIES)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    createValueAxes(panes) {\n        const tracker = this.valueAxisRangeTracker;\n        const defaultRange = tracker.query();\n        const definitions = [].concat(this.options.valueAxis);\n        const invertAxes = this.invertAxes;\n        const baseOptions = { vertical: !invertAxes, reverse: invertAxes && this.chartService.rtl };\n        const axes = [];\n\n        if (this.stack100) {\n            baseOptions.roundToMajorUnit = false;\n            baseOptions.labels = { format: \"P0\" };\n        }\n\n        for (let i = 0; i < definitions.length; i++) {\n            const axisOptions = definitions[i];\n            const axisPane = this.findPane(axisOptions.pane);\n\n            if (inArray(axisPane, panes)) {\n                const name = axisOptions.name;\n                const defaultAxisRange = equalsIgnoreCase(axisOptions.type, LOGARITHMIC) ? { min: 0.1, max: 1 } : { min: 0, max: 1 };\n                const range = tracker.query(name) || defaultRange || defaultAxisRange;\n\n                if (i === 0 && range && defaultRange) {\n                    range.min = Math.min(range.min, defaultRange.min);\n                    range.max = Math.max(range.max, defaultRange.max);\n                }\n\n                let axisType;\n                if (equalsIgnoreCase(axisOptions.type, LOGARITHMIC)) {\n                    axisType = LogarithmicAxis;\n                } else {\n                    axisType = NumericAxis;\n                }\n\n                const valueAxis = new axisType(range.min, range.max,\n                    deepExtend({}, baseOptions, axisOptions),\n                    this.chartService\n                );\n\n                if (name) {\n                    if (this.namedValueAxes[name]) {\n                        throw new Error(`Value axis with name ${ name } is already defined`);\n                    }\n                    this.namedValueAxes[name] = valueAxis;\n                }\n                valueAxis.axisIndex = i;\n\n                axes.push(valueAxis);\n                this.appendAxis(valueAxis);\n            }\n        }\n\n        const primaryAxis = this.valueAxis || axes[0];\n        this.valueAxis = primaryAxis;\n\n        if (invertAxes) {\n            this.axisX = primaryAxis;\n        } else {\n            this.axisY = primaryAxis;\n        }\n    }\n\n    _dispatchEvent(chart, e, eventType) {\n        const coords = chart._eventCoordinates(e);\n        const point = new Point(coords.x, coords.y);\n        const pane = this.pointPane(point);\n        const categories = [];\n        const values = [];\n\n        if (!pane) {\n            return;\n        }\n\n        const allAxes = pane.axes;\n        for (let i = 0; i < allAxes.length; i++) {\n            const axis = allAxes[i];\n            if (axis.getValue) {\n                appendIfNotNull(values, axis.getValue(point));\n            } else {\n                appendIfNotNull(categories, axis.getCategory(point));\n            }\n        }\n\n        if (categories.length === 0) {\n            appendIfNotNull(categories, this.categoryAxis.getCategory(point));\n        }\n\n        if (categories.length > 0 && values.length > 0) {\n            chart.trigger(eventType, {\n                element: eventElement(e),\n                originalEvent: e,\n                category: singleItemOrArray(categories),\n                value: singleItemOrArray(values)\n            });\n        }\n    }\n\n    pointPane(point) {\n        const panes = this.panes;\n\n        for (let i = 0; i < panes.length; i++) {\n            const currentPane = panes[i];\n            if (currentPane.contentBox.containsPoint(point)) {\n                return currentPane;\n            }\n        }\n    }\n\n    updateAxisOptions(axis, options) {\n        updateAxisOptions(this.options, axis, options);\n        updateAxisOptions(this.originalOptions, axis, options);\n    }\n}\n\nfunction updateAxisOptions(targetOptions, axis, options) {\n    const axesOptions = axis instanceof CategoryAxis ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);\n    deepExtend(axesOptions[axis.axisIndex], options);\n}\n\nfunction groupSeries(series, axis, axisIx) {\n    return grep(series, function(s) {\n        return (axisIx === 0 && !s.categoryAxis) || (s.categoryAxis === axis);\n    });\n}\n\nsetDefaultOptions(CategoricalPlotArea, {\n    categoryAxis: {},\n    valueAxis: {}\n});\n\ndeepExtend(CategoricalPlotArea.prototype, PlotAreaEventsMixin);\n\nexport default CategoricalPlotArea;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}