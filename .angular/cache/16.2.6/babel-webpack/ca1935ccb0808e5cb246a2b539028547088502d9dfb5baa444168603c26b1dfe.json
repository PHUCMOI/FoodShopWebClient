{"ast":null,"code":"import BarChart from '../bar-chart/bar-chart';\nimport SeriesBinder from '../series-binder';\nimport WaterfallSegment from './waterfall-segment';\nimport categoriesCount from '../utils/categories-count';\nimport { isNumber } from '../../common';\nclass WaterfallChart extends BarChart {\n  render() {\n    super.render();\n    this.createSegments();\n  }\n  traverseDataPoints(callback) {\n    const series = this.options.series;\n    const totalCategories = categoriesCount(series);\n    const isVertical = !this.options.invertAxes;\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      let total = 0;\n      let runningTotal = 0;\n      for (let categoryIx = 0; categoryIx < totalCategories; categoryIx++) {\n        const data = SeriesBinder.current.bindPoint(currentSeries, categoryIx);\n        const value = data.valueFields.value;\n        const summary = data.fields.summary;\n        let from = total;\n        let to;\n        if (summary) {\n          if (summary.toLowerCase() === \"total\") {\n            data.valueFields.value = total;\n            from = 0;\n            to = total;\n          } else {\n            data.valueFields.value = runningTotal;\n            to = from - runningTotal;\n            runningTotal = 0;\n          }\n        } else if (isNumber(value)) {\n          runningTotal += value;\n          total += value;\n          to = total;\n        }\n        callback(data, {\n          category: this.categoryAxis.categoryAt(categoryIx),\n          categoryIx: categoryIx,\n          series: currentSeries,\n          seriesIx: seriesIx,\n          total: total,\n          runningTotal: runningTotal,\n          from: from,\n          to: to,\n          isVertical: isVertical\n        });\n      }\n    }\n  }\n  updateRange(value, fields) {\n    super.updateRange({\n      value: fields.to\n    }, fields);\n  }\n  aboveAxis(point) {\n    return point.value >= 0;\n  }\n  plotRange(point) {\n    return [point.from, point.to];\n  }\n  createSegments() {\n    const series = this.options.series;\n    const seriesPoints = this.seriesPoints;\n    const segments = this.segments = [];\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      const points = seriesPoints[seriesIx];\n      if (points) {\n        let prevPoint;\n        for (let pointIx = 0; pointIx < points.length; pointIx++) {\n          const point = points[pointIx];\n          if (point && prevPoint) {\n            const segment = new WaterfallSegment(prevPoint, point, currentSeries);\n            segments.push(segment);\n            this.append(segment);\n          }\n          prevPoint = point;\n        }\n      }\n    }\n  }\n}\nexport default WaterfallChart;","map":{"version":3,"names":["BarChart","SeriesBinder","WaterfallSegment","categoriesCount","isNumber","WaterfallChart","render","createSegments","traverseDataPoints","callback","series","options","totalCategories","isVertical","invertAxes","seriesIx","length","currentSeries","total","runningTotal","categoryIx","data","current","bindPoint","value","valueFields","summary","fields","from","to","toLowerCase","category","categoryAxis","categoryAt","updateRange","aboveAxis","point","plotRange","seriesPoints","segments","points","prevPoint","pointIx","segment","push","append"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/waterfall-chart/waterfall-chart.js"],"sourcesContent":["import BarChart from '../bar-chart/bar-chart';\nimport SeriesBinder from '../series-binder';\nimport WaterfallSegment from './waterfall-segment';\n\nimport categoriesCount from '../utils/categories-count';\n\nimport { isNumber } from '../../common';\n\nclass WaterfallChart extends BarChart {\n    render() {\n        super.render();\n        this.createSegments();\n    }\n\n    traverseDataPoints(callback) {\n        const series = this.options.series;\n        const totalCategories = categoriesCount(series);\n        const isVertical = !this.options.invertAxes;\n\n        for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            const currentSeries = series[seriesIx];\n            let total = 0;\n            let runningTotal = 0;\n\n            for (let categoryIx = 0; categoryIx < totalCategories; categoryIx++) {\n                const data = SeriesBinder.current.bindPoint(currentSeries, categoryIx);\n                const value = data.valueFields.value;\n                const summary = data.fields.summary;\n                let from = total;\n                let to;\n\n                if (summary) {\n                    if (summary.toLowerCase() === \"total\") {\n                        data.valueFields.value = total;\n                        from = 0;\n                        to = total;\n                    } else {\n                        data.valueFields.value = runningTotal;\n                        to = from - runningTotal;\n                        runningTotal = 0;\n                    }\n                } else if (isNumber(value)) {\n                    runningTotal += value;\n                    total += value;\n                    to = total;\n                }\n\n                callback(data, {\n                    category: this.categoryAxis.categoryAt(categoryIx),\n                    categoryIx: categoryIx,\n                    series: currentSeries,\n                    seriesIx: seriesIx,\n                    total: total,\n                    runningTotal: runningTotal,\n                    from: from,\n                    to: to,\n                    isVertical: isVertical\n                });\n            }\n        }\n    }\n\n    updateRange(value, fields) {\n        super.updateRange({ value: fields.to }, fields);\n    }\n\n    aboveAxis(point) {\n        return point.value >= 0;\n    }\n\n    plotRange(point) {\n        return [ point.from, point.to ];\n    }\n\n    createSegments() {\n        const series = this.options.series;\n        const seriesPoints = this.seriesPoints;\n        const segments = this.segments = [];\n\n        for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            const currentSeries = series[seriesIx];\n            const points = seriesPoints[seriesIx];\n\n            if (points) {\n                let prevPoint;\n                for (let pointIx = 0; pointIx < points.length; pointIx++) {\n                    const point = points[pointIx];\n\n                    if (point && prevPoint) {\n                        const segment = new WaterfallSegment(prevPoint, point, currentSeries);\n                        segments.push(segment);\n                        this.append(segment);\n                    }\n\n                    prevPoint = point;\n                }\n            }\n        }\n    }\n}\n\nexport default WaterfallChart;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}