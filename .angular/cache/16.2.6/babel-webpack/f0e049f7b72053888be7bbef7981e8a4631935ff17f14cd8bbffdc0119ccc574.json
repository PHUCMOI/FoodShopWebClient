{"ast":null,"code":"import ErrorRangeCalculator from './error-bars/error-range-calculator';\nimport CategoricalErrorBar from './error-bars/categorical-error-bar';\nimport { ERROR_LOW_FIELD, ERROR_HIGH_FIELD } from './constants';\nimport { evalOptions, categoriesCount } from './utils';\nimport { ChartElement, Box } from '../core';\nimport { VALUE, STRING, MIN_VALUE, MAX_VALUE } from '../common/constants';\nimport { convertableToNumber, deepExtend, defined, isNumber, last, setDefaultOptions, sparseArrayLimits } from '../common';\nclass CategoricalChart extends ChartElement {\n  constructor(plotArea, options) {\n    super(options);\n    this.plotArea = plotArea;\n    this.chartService = plotArea.chartService;\n    this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);\n\n    // Value axis ranges grouped by axis name, e.g.:\n    // primary: { min: 0, max: 1 }\n    this.valueAxisRanges = {};\n    this.points = [];\n    this.categoryPoints = [];\n    this.seriesPoints = [];\n    this.seriesOptions = [];\n    this._evalSeries = [];\n    this.render();\n  }\n  render() {\n    this.traverseDataPoints(this.addValue.bind(this));\n  }\n  pointOptions(series, seriesIx) {\n    let options = this.seriesOptions[seriesIx];\n    if (!options) {\n      const defaults = this.pointType().prototype.defaults;\n      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {\n        vertical: !this.options.invertAxes\n      }, series);\n    }\n    return options;\n  }\n  plotValue(point) {\n    if (!point) {\n      return 0;\n    }\n    if (this.options.isStacked100 && isNumber(point.value)) {\n      const categoryIx = point.categoryIx;\n      const categoryPoints = this.categoryPoints[categoryIx];\n      const otherValues = [];\n      let categorySum = 0;\n      for (let i = 0; i < categoryPoints.length; i++) {\n        const other = categoryPoints[i];\n        if (other) {\n          const stack = point.series.stack;\n          const otherStack = other.series.stack;\n          if (stack && otherStack && stack.group !== otherStack.group) {\n            continue;\n          }\n          if (isNumber(other.value)) {\n            categorySum += Math.abs(other.value);\n            otherValues.push(Math.abs(other.value));\n          }\n        }\n      }\n      if (categorySum > 0) {\n        return point.value / categorySum;\n      }\n    }\n    return point.value;\n  }\n  plotRange(point, startValue = 0) {\n    const categoryPoints = this.categoryPoints[point.categoryIx];\n    if (this.options.isStacked) {\n      let plotValue = this.plotValue(point);\n      const positive = plotValue >= 0;\n      let prevValue = startValue;\n      let isStackedBar = false;\n      for (let i = 0; i < categoryPoints.length; i++) {\n        const other = categoryPoints[i];\n        if (point === other) {\n          break;\n        }\n        const stack = point.series.stack;\n        const otherStack = other.series.stack;\n        if (stack && otherStack) {\n          if (typeof stack === STRING && stack !== otherStack) {\n            continue;\n          }\n          if (stack.group && stack.group !== otherStack.group) {\n            continue;\n          }\n        }\n        const otherValue = this.plotValue(other);\n        if (otherValue >= 0 && positive || otherValue < 0 && !positive) {\n          prevValue += otherValue;\n          plotValue += otherValue;\n          isStackedBar = true;\n          if (this.options.isStacked100) {\n            plotValue = Math.min(plotValue, 1);\n          }\n        }\n      }\n      if (isStackedBar) {\n        prevValue -= startValue;\n      }\n      return [prevValue, plotValue];\n    }\n    const series = point.series;\n    const valueAxis = this.seriesValueAxis(series);\n    const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n    return [axisCrossingValue, convertableToNumber(point.value) ? point.value : axisCrossingValue];\n  }\n  stackLimits(axisName, stackName) {\n    let min = MAX_VALUE;\n    let max = MIN_VALUE;\n    for (let i = 0; i < this.categoryPoints.length; i++) {\n      const categoryPoints = this.categoryPoints[i];\n      if (!categoryPoints) {\n        continue;\n      }\n      for (let pIx = 0; pIx < categoryPoints.length; pIx++) {\n        const point = categoryPoints[pIx];\n        if (point) {\n          if (point.series.stack === stackName || point.series.axis === axisName) {\n            const to = this.plotRange(point, 0)[1];\n            if (defined(to) && isFinite(to)) {\n              max = Math.max(max, to);\n              min = Math.min(min, to);\n            }\n          }\n        }\n      }\n    }\n    return {\n      min: min,\n      max: max\n    };\n  }\n  updateStackRange() {\n    const {\n      isStacked,\n      series: chartSeries\n    } = this.options;\n    const limitsCache = {};\n    if (isStacked) {\n      for (let i = 0; i < chartSeries.length; i++) {\n        const series = chartSeries[i];\n        const axisName = series.axis;\n        const key = axisName + series.stack;\n        let limits = limitsCache[key];\n        if (!limits) {\n          limits = this.stackLimits(axisName, series.stack);\n          const errorTotals = this.errorTotals;\n          if (errorTotals) {\n            if (errorTotals.negative.length) {\n              limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);\n            }\n            if (errorTotals.positive.length) {\n              limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);\n            }\n          }\n          if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {\n            limitsCache[key] = limits;\n          } else {\n            limits = null;\n          }\n        }\n        if (limits) {\n          this.valueAxisRanges[axisName] = limits;\n        }\n      }\n    }\n  }\n  addErrorBar(point, data, categoryIx) {\n    const {\n      value,\n      series,\n      seriesIx\n    } = point;\n    const errorBars = point.options.errorBars;\n    const lowValue = data.fields[ERROR_LOW_FIELD];\n    const highValue = data.fields[ERROR_HIGH_FIELD];\n    let errorRange;\n    if (isNumber(lowValue) && isNumber(highValue)) {\n      errorRange = {\n        low: lowValue,\n        high: highValue\n      };\n    } else if (errorBars && defined(errorBars.value)) {\n      this.seriesErrorRanges = this.seriesErrorRanges || [];\n      this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new ErrorRangeCalculator(errorBars.value, series, VALUE);\n      errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);\n    }\n    if (errorRange) {\n      point.low = errorRange.low;\n      point.high = errorRange.high;\n      this.addPointErrorBar(point, categoryIx);\n    }\n  }\n  addPointErrorBar(point, categoryIx) {\n    const isVertical = !this.options.invertAxes;\n    const options = point.options.errorBars;\n    let {\n      series,\n      low,\n      high\n    } = point;\n    if (this.options.isStacked) {\n      const stackedErrorRange = this.stackedErrorRange(point, categoryIx);\n      low = stackedErrorRange.low;\n      high = stackedErrorRange.high;\n    } else {\n      const fields = {\n        categoryIx: categoryIx,\n        series: series\n      };\n      this.updateRange({\n        value: low\n      }, fields);\n      this.updateRange({\n        value: high\n      }, fields);\n    }\n    const errorBar = new CategoricalErrorBar(low, high, isVertical, this, series, options);\n    point.errorBars = [errorBar];\n    point.append(errorBar);\n  }\n  stackedErrorRange(point, categoryIx) {\n    const plotValue = this.plotRange(point, 0)[1] - point.value;\n    const low = point.low + plotValue;\n    const high = point.high + plotValue;\n    this.errorTotals = this.errorTotals || {\n      positive: [],\n      negative: []\n    };\n    if (low < 0) {\n      this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);\n    }\n    if (high > 0) {\n      this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);\n    }\n    return {\n      low: low,\n      high: high\n    };\n  }\n  addValue(data, fields) {\n    const {\n      categoryIx,\n      series,\n      seriesIx\n    } = fields;\n    let categoryPoints = this.categoryPoints[categoryIx];\n    if (!categoryPoints) {\n      this.categoryPoints[categoryIx] = categoryPoints = [];\n    }\n    let seriesPoints = this.seriesPoints[seriesIx];\n    if (!seriesPoints) {\n      this.seriesPoints[seriesIx] = seriesPoints = [];\n    }\n    const point = this.createPoint(data, fields);\n    if (point) {\n      Object.assign(point, fields);\n      point.owner = this;\n      point.noteText = data.fields.noteText;\n      if (!defined(point.dataItem)) {\n        point.dataItem = series.data[categoryIx];\n      }\n      this.addErrorBar(point, data, categoryIx);\n    }\n    this.points.push(point);\n    seriesPoints.push(point);\n    categoryPoints.push(point);\n    this.updateRange(data.valueFields, fields);\n  }\n  evalPointOptions(options, value, fields) {\n    const categoryIx = fields.categoryIx;\n    const category = fields.category;\n    const series = fields.series;\n    const seriesIx = fields.seriesIx;\n    const state = {\n      defaults: series._defaults,\n      excluded: [\"data\", \"aggregate\", \"_events\", \"tooltip\", \"content\", \"template\", \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\", \"drilldownSeriesFactory\"]\n    };\n    let doEval = this._evalSeries[seriesIx];\n    if (!defined(doEval)) {\n      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n    }\n    let pointOptions = options;\n    if (doEval) {\n      pointOptions = deepExtend({}, pointOptions);\n      evalOptions(pointOptions, {\n        value: value,\n        category: category,\n        index: categoryIx,\n        series: series,\n        dataItem: series.data[categoryIx]\n      }, state);\n    }\n    return pointOptions;\n  }\n  updateRange(data, fields) {\n    const axisName = fields.series.axis;\n    const value = data.value;\n    let axisRange = this.valueAxisRanges[axisName];\n    if (isFinite(value) && value !== null) {\n      axisRange = this.valueAxisRanges[axisName] = axisRange || {\n        min: MAX_VALUE,\n        max: MIN_VALUE\n      };\n      axisRange.min = Math.min(axisRange.min, value);\n      axisRange.max = Math.max(axisRange.max, value);\n    }\n  }\n  seriesValueAxis(series) {\n    const plotArea = this.plotArea;\n    const axisName = series.axis;\n    const axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;\n    if (!axis) {\n      throw new Error(\"Unable to locate value axis with name \" + axisName);\n    }\n    return axis;\n  }\n  reflow(targetBox) {\n    const categorySlots = this.categorySlots = [];\n    const chartPoints = this.points;\n    const categoryAxis = this.categoryAxis;\n    let pointIx = 0;\n    this.traverseDataPoints((data, fields) => {\n      const {\n        categoryIx,\n        series: currentSeries\n      } = fields;\n      const valueAxis = this.seriesValueAxis(currentSeries);\n      const point = chartPoints[pointIx++];\n      let categorySlot = categorySlots[categoryIx];\n      if (!categorySlot) {\n        categorySlots[categoryIx] = categorySlot = this.categorySlot(categoryAxis, categoryIx, valueAxis);\n      }\n      if (point) {\n        const plotRange = this.plotRange(point, valueAxis.startValue());\n        const valueSlot = this.valueSlot(valueAxis, plotRange);\n        if (valueSlot) {\n          const pointSlot = this.pointSlot(categorySlot, valueSlot);\n          point.aboveAxis = this.aboveAxis(point, valueAxis);\n          point.stackValue = plotRange[1];\n          if (this.options.isStacked100) {\n            point.percentage = this.plotValue(point);\n          }\n          this.reflowPoint(point, pointSlot);\n        } else {\n          point.visible = false;\n        }\n      }\n    });\n    this.reflowCategories(categorySlots);\n    if (!this.options.clip && this.options.limitPoints && this.points.length) {\n      this.limitPoints();\n    }\n    this.box = targetBox;\n  }\n  valueSlot(valueAxis, plotRange) {\n    return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);\n  }\n  limitPoints() {\n    const categoryPoints = this.categoryPoints;\n    const points = categoryPoints[0].concat(last(categoryPoints));\n    for (let idx = 0; idx < points.length; idx++) {\n      if (points[idx]) {\n        this.limitPoint(points[idx]);\n      }\n    }\n  }\n  limitPoint(point) {\n    const limitedSlot = this.categoryAxis.limitSlot(point.box);\n    if (!limitedSlot.equals(point.box)) {\n      point.reflow(limitedSlot);\n    }\n  }\n  aboveAxis(point, valueAxis) {\n    const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n    const value = point.value;\n    return valueAxis.options.reverse ? value < axisCrossingValue : value >= axisCrossingValue;\n  }\n  categoryAxisCrossingValue(valueAxis) {\n    const categoryAxis = this.categoryAxis;\n    const options = valueAxis.options;\n    const crossingValues = [].concat(options.axisCrossingValues || options.axisCrossingValue);\n    return crossingValues[categoryAxis.axisIndex || 0] || 0;\n  }\n  reflowPoint(point, pointSlot) {\n    point.reflow(pointSlot);\n  }\n  reflowCategories() {}\n  pointSlot(categorySlot, valueSlot) {\n    const options = this.options;\n    const invertAxes = options.invertAxes;\n    const slotX = invertAxes ? valueSlot : categorySlot;\n    const slotY = invertAxes ? categorySlot : valueSlot;\n    return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n  }\n  categorySlot(categoryAxis, categoryIx) {\n    return categoryAxis.getSlot(categoryIx);\n  }\n  traverseDataPoints(callback) {\n    const series = this.options.series;\n    const count = categoriesCount(series);\n    const seriesCount = series.length;\n    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n      this._outOfRangeCallback(series[seriesIx], \"_outOfRangeMinPoint\", seriesIx, callback);\n    }\n    for (let categoryIx = 0; categoryIx < count; categoryIx++) {\n      for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n        const currentSeries = series[seriesIx];\n        const currentCategory = this.categoryAxis.categoryAt(categoryIx);\n        const pointData = this.plotArea.bindPoint(currentSeries, categoryIx);\n        callback(pointData, {\n          category: currentCategory,\n          categoryIx: categoryIx,\n          categoriesCount: count,\n          series: currentSeries,\n          seriesIx: seriesIx\n        });\n      }\n    }\n    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n      this._outOfRangeCallback(series[seriesIx], \"_outOfRangeMaxPoint\", seriesIx, callback);\n    }\n  }\n  _outOfRangeCallback(series, field, seriesIx, callback) {\n    const outOfRangePoint = series[field];\n    if (outOfRangePoint) {\n      const categoryIx = outOfRangePoint.categoryIx;\n      const pointData = this.plotArea.bindPoint(series, categoryIx, outOfRangePoint.item);\n      callback(pointData, {\n        category: outOfRangePoint.category,\n        categoryIx: categoryIx,\n        series: series,\n        seriesIx: seriesIx,\n        dataItem: outOfRangePoint.item\n      });\n    }\n  }\n  formatPointValue(point, format) {\n    if (point.value === null) {\n      return \"\";\n    }\n    return this.chartService.format.auto(format, point.value);\n  }\n  pointValue(data) {\n    return data.valueFields.value;\n  }\n}\nsetDefaultOptions(CategoricalChart, {\n  series: [],\n  invertAxes: false,\n  isStacked: false,\n  clip: true,\n  limitPoints: true\n});\nexport default CategoricalChart;","map":{"version":3,"names":["ErrorRangeCalculator","CategoricalErrorBar","ERROR_LOW_FIELD","ERROR_HIGH_FIELD","evalOptions","categoriesCount","ChartElement","Box","VALUE","STRING","MIN_VALUE","MAX_VALUE","convertableToNumber","deepExtend","defined","isNumber","last","setDefaultOptions","sparseArrayLimits","CategoricalChart","constructor","plotArea","options","chartService","categoryAxis","seriesCategoryAxis","series","valueAxisRanges","points","categoryPoints","seriesPoints","seriesOptions","_evalSeries","render","traverseDataPoints","addValue","bind","pointOptions","seriesIx","defaults","pointType","prototype","vertical","invertAxes","plotValue","point","isStacked100","value","categoryIx","otherValues","categorySum","i","length","other","stack","otherStack","group","Math","abs","push","plotRange","startValue","isStacked","positive","prevValue","isStackedBar","otherValue","min","valueAxis","seriesValueAxis","axisCrossingValue","categoryAxisCrossingValue","stackLimits","axisName","stackName","max","pIx","axis","to","isFinite","updateStackRange","chartSeries","limitsCache","key","limits","errorTotals","negative","addErrorBar","data","errorBars","lowValue","fields","highValue","errorRange","low","high","seriesErrorRanges","getErrorRange","addPointErrorBar","isVertical","stackedErrorRange","updateRange","errorBar","append","createPoint","Object","assign","owner","noteText","dataItem","valueFields","evalPointOptions","category","state","_defaults","excluded","doEval","index","axisRange","namedValueAxes","Error","reflow","targetBox","categorySlots","chartPoints","pointIx","currentSeries","categorySlot","valueSlot","pointSlot","aboveAxis","stackValue","percentage","reflowPoint","visible","reflowCategories","clip","limitPoints","box","getSlot","concat","idx","limitPoint","limitedSlot","limitSlot","equals","reverse","crossingValues","axisCrossingValues","axisIndex","slotX","slotY","x1","y1","x2","y2","callback","count","seriesCount","_outOfRangeCallback","currentCategory","categoryAt","pointData","bindPoint","field","outOfRangePoint","item","formatPointValue","format","auto","pointValue"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/categorical-chart.js"],"sourcesContent":["import ErrorRangeCalculator from './error-bars/error-range-calculator';\nimport CategoricalErrorBar from './error-bars/categorical-error-bar';\n\nimport { ERROR_LOW_FIELD, ERROR_HIGH_FIELD } from './constants';\n\nimport { evalOptions, categoriesCount } from './utils';\n\nimport { ChartElement, Box } from '../core';\n\nimport { VALUE, STRING, MIN_VALUE, MAX_VALUE } from '../common/constants';\nimport { convertableToNumber, deepExtend, defined, isNumber, last, setDefaultOptions, sparseArrayLimits } from '../common';\n\nclass CategoricalChart extends ChartElement {\n    constructor(plotArea, options) {\n        super(options);\n\n        this.plotArea = plotArea;\n        this.chartService = plotArea.chartService;\n        this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);\n\n        // Value axis ranges grouped by axis name, e.g.:\n        // primary: { min: 0, max: 1 }\n        this.valueAxisRanges = {};\n\n        this.points = [];\n        this.categoryPoints = [];\n        this.seriesPoints = [];\n        this.seriesOptions = [];\n        this._evalSeries = [];\n\n        this.render();\n    }\n\n    render() {\n        this.traverseDataPoints(this.addValue.bind(this));\n    }\n\n    pointOptions(series, seriesIx) {\n        let options = this.seriesOptions[seriesIx];\n        if (!options) {\n            const defaults = this.pointType().prototype.defaults;\n            this.seriesOptions[seriesIx] = options = deepExtend({ }, defaults, {\n                vertical: !this.options.invertAxes\n            }, series);\n        }\n\n        return options;\n    }\n\n    plotValue(point) {\n        if (!point) {\n            return 0;\n        }\n\n        if (this.options.isStacked100 && isNumber(point.value)) {\n            const categoryIx = point.categoryIx;\n            const categoryPoints = this.categoryPoints[categoryIx];\n            const otherValues = [];\n            let categorySum = 0;\n\n            for (let i = 0; i < categoryPoints.length; i++) {\n                const other = categoryPoints[i];\n                if (other) {\n                    const stack = point.series.stack;\n                    const otherStack = other.series.stack;\n\n                    if ((stack && otherStack) && stack.group !== otherStack.group) {\n                        continue;\n                    }\n\n                    if (isNumber(other.value)) {\n                        categorySum += Math.abs(other.value);\n                        otherValues.push(Math.abs(other.value));\n                    }\n                }\n            }\n\n            if (categorySum > 0) {\n                return point.value / categorySum;\n            }\n        }\n\n        return point.value;\n    }\n\n    plotRange(point, startValue = 0) {\n        const categoryPoints = this.categoryPoints[point.categoryIx];\n\n        if (this.options.isStacked) {\n            let plotValue = this.plotValue(point);\n            const positive = plotValue >= 0;\n            let prevValue = startValue;\n            let isStackedBar = false;\n\n            for (let i = 0; i < categoryPoints.length; i++) {\n                const other = categoryPoints[i];\n\n                if (point === other) {\n                    break;\n                }\n\n                const stack = point.series.stack;\n                const otherStack = other.series.stack;\n                if (stack && otherStack) {\n                    if (typeof stack === STRING && stack !== otherStack) {\n                        continue;\n                    }\n\n                    if (stack.group && stack.group !== otherStack.group) {\n                        continue;\n                    }\n                }\n\n                const otherValue = this.plotValue(other);\n                if ((otherValue >= 0 && positive) ||\n                    (otherValue < 0 && !positive)) {\n                    prevValue += otherValue;\n                    plotValue += otherValue;\n                    isStackedBar = true;\n\n                    if (this.options.isStacked100) {\n                        plotValue = Math.min(plotValue, 1);\n                    }\n                }\n            }\n\n            if (isStackedBar) {\n                prevValue -= startValue;\n            }\n\n            return [ prevValue, plotValue ];\n        }\n\n        const series = point.series;\n        const valueAxis = this.seriesValueAxis(series);\n        const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n\n        return [ axisCrossingValue, convertableToNumber(point.value) ? point.value : axisCrossingValue ];\n    }\n\n    stackLimits(axisName, stackName) {\n        let min = MAX_VALUE;\n        let max = MIN_VALUE;\n\n        for (let i = 0; i < this.categoryPoints.length; i++) {\n            const categoryPoints = this.categoryPoints[i];\n            if (!categoryPoints) {\n                continue;\n            }\n\n            for (let pIx = 0; pIx < categoryPoints.length; pIx++) {\n                const point = categoryPoints[pIx];\n                if (point) {\n                    if (point.series.stack === stackName || point.series.axis === axisName) {\n                        const to = this.plotRange(point, 0)[1];\n                        if (defined(to) && isFinite(to)) {\n                            max = Math.max(max, to);\n                            min = Math.min(min, to);\n                        }\n                    }\n                }\n            }\n        }\n\n        return { min: min, max: max };\n    }\n\n    updateStackRange() {\n        const { isStacked, series: chartSeries } = this.options;\n        const limitsCache = {};\n\n        if (isStacked) {\n            for (let i = 0; i < chartSeries.length; i++) {\n                const series = chartSeries[i];\n                const axisName = series.axis;\n                const key = axisName + series.stack;\n\n                let limits = limitsCache[key];\n                if (!limits) {\n                    limits = this.stackLimits(axisName, series.stack);\n\n                    const errorTotals = this.errorTotals;\n                    if (errorTotals) {\n                        if (errorTotals.negative.length) {\n                            limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);\n                        }\n                        if (errorTotals.positive.length) {\n                            limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);\n                        }\n                    }\n\n                    if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {\n                        limitsCache[key] = limits;\n                    } else {\n                        limits = null;\n                    }\n                }\n\n                if (limits) {\n                    this.valueAxisRanges[axisName] = limits;\n                }\n            }\n        }\n    }\n\n    addErrorBar(point, data, categoryIx) {\n        const { value, series, seriesIx } = point;\n        const errorBars = point.options.errorBars;\n        const lowValue = data.fields[ERROR_LOW_FIELD];\n        const highValue = data.fields[ERROR_HIGH_FIELD];\n        let errorRange;\n\n        if (isNumber(lowValue) && isNumber(highValue)) {\n            errorRange = { low: lowValue, high: highValue };\n        } else if (errorBars && defined(errorBars.value)) {\n            this.seriesErrorRanges = this.seriesErrorRanges || [];\n            this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] ||\n                new ErrorRangeCalculator(errorBars.value, series, VALUE);\n\n            errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);\n        }\n\n        if (errorRange) {\n            point.low = errorRange.low;\n            point.high = errorRange.high;\n            this.addPointErrorBar(point, categoryIx);\n        }\n    }\n\n    addPointErrorBar(point, categoryIx) {\n        const isVertical = !this.options.invertAxes;\n        const options = point.options.errorBars;\n        let { series, low, high } = point;\n\n        if (this.options.isStacked) {\n            const stackedErrorRange = this.stackedErrorRange(point, categoryIx);\n            low = stackedErrorRange.low;\n            high = stackedErrorRange.high;\n        } else {\n            const fields = { categoryIx: categoryIx, series: series };\n            this.updateRange({ value: low }, fields);\n            this.updateRange({ value: high }, fields);\n        }\n\n        const errorBar = new CategoricalErrorBar(low, high, isVertical, this, series, options);\n        point.errorBars = [ errorBar ];\n        point.append(errorBar);\n    }\n\n    stackedErrorRange(point, categoryIx) {\n        const plotValue = this.plotRange(point, 0)[1] - point.value;\n        const low = point.low + plotValue;\n        const high = point.high + plotValue;\n\n        this.errorTotals = this.errorTotals || { positive: [], negative: [] };\n\n        if (low < 0) {\n            this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);\n        }\n\n        if (high > 0) {\n            this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);\n        }\n\n        return { low: low, high: high };\n    }\n\n    addValue(data, fields) {\n        const { categoryIx, series, seriesIx } = fields;\n\n        let categoryPoints = this.categoryPoints[categoryIx];\n        if (!categoryPoints) {\n            this.categoryPoints[categoryIx] = categoryPoints = [];\n        }\n\n        let seriesPoints = this.seriesPoints[seriesIx];\n        if (!seriesPoints) {\n            this.seriesPoints[seriesIx] = seriesPoints = [];\n        }\n\n        const point = this.createPoint(data, fields);\n        if (point) {\n            Object.assign(point, fields);\n\n            point.owner = this;\n            point.noteText = data.fields.noteText;\n            if (!defined(point.dataItem)) {\n                point.dataItem = series.data[categoryIx];\n            }\n            this.addErrorBar(point, data, categoryIx);\n        }\n\n        this.points.push(point);\n        seriesPoints.push(point);\n        categoryPoints.push(point);\n\n        this.updateRange(data.valueFields, fields);\n    }\n\n    evalPointOptions(options, value, fields) {\n        const categoryIx = fields.categoryIx;\n        const category = fields.category;\n        const series = fields.series;\n        const seriesIx = fields.seriesIx;\n        const state = {\n            defaults: series._defaults,\n            excluded: [\n                \"data\", \"aggregate\", \"_events\", \"tooltip\", \"content\", \"template\",\n                \"visual\", \"toggle\", \"_outOfRangeMinPoint\", \"_outOfRangeMaxPoint\",\n                \"drilldownSeriesFactory\"\n            ]\n        };\n\n        let doEval = this._evalSeries[seriesIx];\n        if (!defined(doEval)) {\n            this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);\n        }\n\n        let pointOptions = options;\n        if (doEval) {\n            pointOptions = deepExtend({}, pointOptions);\n            evalOptions(pointOptions, {\n                value: value,\n                category: category,\n                index: categoryIx,\n                series: series,\n                dataItem: series.data[categoryIx]\n            }, state);\n        }\n\n        return pointOptions;\n    }\n\n    updateRange(data, fields) {\n        const axisName = fields.series.axis;\n        const value = data.value;\n        let axisRange = this.valueAxisRanges[axisName];\n\n        if (isFinite(value) && value !== null) {\n            axisRange = this.valueAxisRanges[axisName] =\n                axisRange || { min: MAX_VALUE, max: MIN_VALUE };\n\n            axisRange.min = Math.min(axisRange.min, value);\n            axisRange.max = Math.max(axisRange.max, value);\n        }\n    }\n\n    seriesValueAxis(series) {\n        const plotArea = this.plotArea;\n        const axisName = series.axis;\n        const axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;\n\n        if (!axis) {\n            throw new Error(\"Unable to locate value axis with name \" + axisName);\n        }\n\n        return axis;\n    }\n\n    reflow(targetBox) {\n        const categorySlots = this.categorySlots = [];\n        const chartPoints = this.points;\n        const categoryAxis = this.categoryAxis;\n        let pointIx = 0;\n\n        this.traverseDataPoints((data, fields) => {\n            const { categoryIx, series: currentSeries } = fields;\n\n            const valueAxis = this.seriesValueAxis(currentSeries);\n            const point = chartPoints[pointIx++];\n\n            let categorySlot = categorySlots[categoryIx];\n            if (!categorySlot) {\n                categorySlots[categoryIx] = categorySlot =\n                    this.categorySlot(categoryAxis, categoryIx, valueAxis);\n            }\n\n            if (point) {\n                const plotRange = this.plotRange(point, valueAxis.startValue());\n                const valueSlot = this.valueSlot(valueAxis, plotRange);\n                if (valueSlot) {\n                    const pointSlot = this.pointSlot(categorySlot, valueSlot);\n\n                    point.aboveAxis = this.aboveAxis(point, valueAxis);\n                    point.stackValue = plotRange[1];\n\n                    if (this.options.isStacked100) {\n                        point.percentage = this.plotValue(point);\n                    }\n\n                    this.reflowPoint(point, pointSlot);\n                } else {\n                    point.visible = false;\n                }\n            }\n        });\n\n        this.reflowCategories(categorySlots);\n        if (!this.options.clip && this.options.limitPoints && this.points.length) {\n            this.limitPoints();\n        }\n\n        this.box = targetBox;\n    }\n\n    valueSlot(valueAxis, plotRange) {\n        return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);\n    }\n\n    limitPoints() {\n        const categoryPoints = this.categoryPoints;\n        const points = categoryPoints[0].concat(last(categoryPoints));\n        for (let idx = 0; idx < points.length; idx++) {\n            if (points[idx]) {\n                this.limitPoint(points[idx]);\n            }\n        }\n    }\n\n    limitPoint(point) {\n        const limitedSlot = this.categoryAxis.limitSlot(point.box);\n        if (!limitedSlot.equals(point.box)) {\n            point.reflow(limitedSlot);\n        }\n    }\n\n    aboveAxis(point, valueAxis) {\n        const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);\n        const value = point.value;\n\n        return valueAxis.options.reverse ?\n            value < axisCrossingValue : value >= axisCrossingValue;\n    }\n\n    categoryAxisCrossingValue(valueAxis) {\n        const categoryAxis = this.categoryAxis;\n        const options = valueAxis.options;\n        const crossingValues = [].concat(\n            options.axisCrossingValues || options.axisCrossingValue\n        );\n\n        return crossingValues[categoryAxis.axisIndex || 0] || 0;\n    }\n\n    reflowPoint(point, pointSlot) {\n        point.reflow(pointSlot);\n    }\n\n    reflowCategories() { }\n\n    pointSlot(categorySlot, valueSlot) {\n        const options = this.options;\n        const invertAxes = options.invertAxes;\n        const slotX = invertAxes ? valueSlot : categorySlot;\n        const slotY = invertAxes ? categorySlot : valueSlot;\n\n        return new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2);\n    }\n\n    categorySlot(categoryAxis, categoryIx) {\n        return categoryAxis.getSlot(categoryIx);\n    }\n\n    traverseDataPoints(callback) {\n        const series = this.options.series;\n        const count = categoriesCount(series);\n        const seriesCount = series.length;\n\n        for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n            this._outOfRangeCallback(series[seriesIx], \"_outOfRangeMinPoint\", seriesIx, callback);\n        }\n\n        for (let categoryIx = 0; categoryIx < count; categoryIx++) {\n            for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n                const currentSeries = series[seriesIx];\n                const currentCategory = this.categoryAxis.categoryAt(categoryIx);\n                const pointData = this.plotArea.bindPoint(currentSeries, categoryIx);\n\n                callback(pointData, {\n                    category: currentCategory,\n                    categoryIx: categoryIx,\n                    categoriesCount: count,\n                    series: currentSeries,\n                    seriesIx: seriesIx\n                });\n            }\n        }\n\n        for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {\n            this._outOfRangeCallback(series[seriesIx], \"_outOfRangeMaxPoint\", seriesIx, callback);\n        }\n    }\n\n    _outOfRangeCallback(series, field, seriesIx, callback) {\n        const outOfRangePoint = series[field];\n        if (outOfRangePoint) {\n            const categoryIx = outOfRangePoint.categoryIx;\n            const pointData = this.plotArea.bindPoint(series, categoryIx, outOfRangePoint.item);\n\n            callback(pointData, {\n                category: outOfRangePoint.category,\n                categoryIx: categoryIx,\n                series: series,\n                seriesIx: seriesIx,\n                dataItem: outOfRangePoint.item\n            });\n        }\n    }\n\n    formatPointValue(point, format) {\n        if (point.value === null) {\n            return \"\";\n        }\n\n        return this.chartService.format.auto(format, point.value);\n    }\n\n    pointValue(data) {\n        return data.valueFields.value;\n    }\n}\n\nsetDefaultOptions(CategoricalChart, {\n    series: [],\n    invertAxes: false,\n    isStacked: false,\n    clip: true,\n    limitPoints: true\n});\n\nexport default CategoricalChart;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}