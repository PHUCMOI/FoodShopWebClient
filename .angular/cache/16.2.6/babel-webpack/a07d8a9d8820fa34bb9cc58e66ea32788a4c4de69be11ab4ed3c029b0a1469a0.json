{"ast":null,"code":"import { exportImage, geometry, Group, MultiPath, Path, Image, Surface } from '@progress/kendo-drawing';\nimport { elementOffset, limitValue } from '../common';\nconst {\n  Point,\n  Rect,\n  transform\n} = geometry;\nconst noop = () => {};\nconst DECIMAL_DIGITS = 3;\nconst DEFAULT_COLOR = '#000';\nconst DEFAULT_BACKGROUND_COLOR = '#fff';\nconst DEFAULT_PRECISION = 1;\nconst DEFAULT_SAMPLING_RATE = 200; // Updates per second\nconst DEFAULT_STROKE_WIDTH = 1;\nconst DEFAULT_WIDTH = 750;\nconst DEFAULT_HEIGHT = 250;\nconst DEFAULT_SCALE = 1;\n// Export images at maximized scale (3x) and 2x pixel density to cover HiDPI screens.\nconst DEFAULT_EXPORT_SCALE = 6;\nexport class SignaturePad {\n  constructor(element, options = {}) {\n    this.element = element;\n    this.lastMoveTime = 0;\n    this.options = Object.assign({\n      scale: DEFAULT_SCALE,\n      precision: DEFAULT_PRECISION,\n      samplingRate: DEFAULT_SAMPLING_RATE,\n      smooth: options.smooth !== false,\n      color: options.color || DEFAULT_COLOR,\n      backgroundColor: options.backgroundColor || DEFAULT_BACKGROUND_COLOR,\n      strokeWidth: DEFAULT_STROKE_WIDTH,\n      onChange: noop,\n      onDraw: noop,\n      onDrawEnd: noop\n    }, options);\n    this.pathOptions = {\n      stroke: {\n        color: this.options.color,\n        width: this.options.strokeWidth,\n        lineCap: 'round',\n        lineJoin: 'round'\n      }\n    };\n    this.initSurface();\n    this.attachEvents();\n  }\n  destroy() {\n    this.detachEvents();\n  }\n  clear() {\n    this.rootGroup.clear();\n    this.path = null;\n  }\n  get isDrawing() {\n    return Boolean(this.points);\n  }\n  get pathData() {\n    var _a;\n    return (_a = this.path) === null || _a === void 0 ? void 0 : _a.toString(DECIMAL_DIGITS);\n  }\n  set pathData(value) {\n    this.clear();\n    this.path = MultiPath.parse(value, this.pathOptions);\n    this.rootGroup.append(this.path);\n  }\n  loadImage(data, size = []) {\n    if (!data) {\n      this.clear();\n      return;\n    }\n    const [width, height] = this.size;\n    const contentWidth = width / this.options.scale;\n    const contentHeight = height / this.options.scale;\n    const importWidth = size[0] || contentWidth * DEFAULT_EXPORT_SCALE;\n    const importHeight = size[1] || contentHeight * DEFAULT_EXPORT_SCALE;\n    const scaleX = contentWidth / importWidth;\n    const scaleY = contentHeight / importHeight;\n    const scale = Math.min(scaleX, scaleY);\n    const img = new Image(data, new geometry.Rect([0, 0], [importWidth, importHeight]));\n    img.transform(transform().scale(scale, scale));\n    this.clear();\n    this.rootGroup.append(img);\n  }\n  exportImage(options) {\n    const [width, height] = this.size;\n    const contentWidth = width / this.options.scale;\n    const contentHeight = height / this.options.scale;\n    const exportWidth = (options === null || options === void 0 ? void 0 : options.width) || contentWidth * DEFAULT_EXPORT_SCALE;\n    const exportHeight = (options === null || options === void 0 ? void 0 : options.height) || contentHeight * DEFAULT_EXPORT_SCALE;\n    const scaleX = exportWidth / contentWidth;\n    const scaleY = exportHeight / contentHeight;\n    const scale = Math.min(scaleX, scaleY);\n    const exportRect = new Rect([0, 0], [exportWidth, exportHeight]);\n    const exportGroup = new Group({\n      clip: Path.fromRect(exportRect)\n    });\n    const contentGroup = new Group({\n      transform: transform().scale(scale, scale)\n    });\n    const frame = Path.fromRect(exportRect, {\n      fill: {\n        color: this.options.backgroundColor\n      }\n    });\n    exportGroup.append(frame);\n    exportGroup.append(contentGroup);\n    contentGroup.children.push(...this.rootGroup.children);\n    return exportImage(exportGroup, Object.assign({\n      width: exportWidth,\n      height: exportHeight\n    }, options));\n  }\n  resize() {\n    this.surface.resize(true);\n  }\n  setOptions(options) {\n    Object.assign(this.options, options);\n    this.pathOptions.stroke.color = this.options.color;\n    this.pathOptions.stroke.width = this.options.strokeWidth;\n    if (this.path) {\n      this.path.options.set('stroke.color', this.options.color);\n      this.path.options.set('stroke.width', this.options.strokeWidth);\n    }\n    this.background.options.set('fill.color', this.options.backgroundColor);\n  }\n  initSurface() {\n    this.surface = Surface.create(this.element, {\n      type: 'canvas'\n    });\n    this.element.style.touchAction = 'none';\n    const scale = this.options.scale;\n    this.rootGroup = new Group({\n      transform: transform().scale(scale, scale)\n    });\n    // The signature is not resizable, store initial dimensions.\n    const width = this.element.offsetWidth || DEFAULT_WIDTH;\n    const height = this.element.offsetHeight || DEFAULT_HEIGHT;\n    this.size = [width, height];\n    this.background = Path.fromRect(new Rect([0, 0], this.size), {\n      fill: {\n        color: this.options.backgroundColor\n      }\n    });\n    this.surface.draw(this.background);\n    this.surface.draw(this.rootGroup);\n  }\n  attachEvents() {\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.element.addEventListener('pointerdown', this.onPointerDown);\n    this.element.addEventListener('pointermove', this.onPointerMove);\n    this.element.addEventListener('pointerup', this.onPointerUp);\n  }\n  detachEvents() {\n    this.element.removeEventListener('pointerdown', this.onPointerDown);\n    this.element.removeEventListener('pointermove', this.onPointerMove);\n    this.element.removeEventListener('pointerup', this.onPointerUp);\n  }\n  touchPoint(e) {\n    const offset = elementOffset(this.element);\n    const pageX = e.pageX;\n    const pageY = e.pageY;\n    const scale = 1 / this.options.scale;\n    return new Point(pageX - offset.left, pageY - offset.top).scale(scale, scale);\n  }\n  onPointerDown(e) {\n    if (this.options.readonly || !e.isPrimary || !isMainButton(e)) {\n      return;\n    }\n    if (!this.path) {\n      this.path = new MultiPath(this.pathOptions);\n      this.rootGroup.append(this.path);\n    }\n    this.options.onDraw();\n    this.element.setPointerCapture(e.pointerId);\n    const point = this.touchPoint(e);\n    this.points = [point];\n    this.path.moveTo(point);\n  }\n  onPointerMove(e) {\n    if (!this.points || !e.isPrimary) {\n      return;\n    }\n    const now = new Date().getTime();\n    const elapsed = now - this.lastMoveTime;\n    const minTimeDelta = 1000 / limitValue(this.options.samplingRate, 1, 10000);\n    if (elapsed < minTimeDelta) {\n      return;\n    } else {\n      this.lastMoveTime = now;\n    }\n    const point = this.touchPoint(e);\n    const lastPoint = this.points[this.points.length - 1];\n    const minDelta = 1 / limitValue(this.options.precision, 0.01, 100);\n    if (point.distanceTo(lastPoint) < minDelta) {\n      return;\n    }\n    this.points.push(point);\n    this.path.lineTo(point);\n  }\n  onPointerUp(e) {\n    if (!e.isPrimary || !this.path || !this.points || this.options.readonly) {\n      return;\n    }\n    if (this.options.smooth) {\n      const segments = Path.curveFromPoints(this.points);\n      this.path.paths.splice(this.path.paths.length - 1, 1, segments);\n    }\n    this.points = null;\n    this.options.onDrawEnd();\n    this.options.onChange(this.pathData);\n  }\n}\nfunction isMainButton(e) {\n  return typeof e.button !== 'number' || e.button === 0;\n}","map":{"version":3,"names":["exportImage","geometry","Group","MultiPath","Path","Image","Surface","elementOffset","limitValue","Point","Rect","transform","noop","DECIMAL_DIGITS","DEFAULT_COLOR","DEFAULT_BACKGROUND_COLOR","DEFAULT_PRECISION","DEFAULT_SAMPLING_RATE","DEFAULT_STROKE_WIDTH","DEFAULT_WIDTH","DEFAULT_HEIGHT","DEFAULT_SCALE","DEFAULT_EXPORT_SCALE","SignaturePad","constructor","element","options","lastMoveTime","Object","assign","scale","precision","samplingRate","smooth","color","backgroundColor","strokeWidth","onChange","onDraw","onDrawEnd","pathOptions","stroke","width","lineCap","lineJoin","initSurface","attachEvents","destroy","detachEvents","clear","rootGroup","path","isDrawing","Boolean","points","pathData","_a","toString","value","parse","append","loadImage","data","size","height","contentWidth","contentHeight","importWidth","importHeight","scaleX","scaleY","Math","min","img","exportWidth","exportHeight","exportRect","exportGroup","clip","fromRect","contentGroup","frame","fill","children","push","resize","surface","setOptions","set","background","create","type","style","touchAction","offsetWidth","offsetHeight","draw","onPointerDown","bind","onPointerMove","onPointerUp","addEventListener","removeEventListener","touchPoint","e","offset","pageX","pageY","left","top","readonly","isPrimary","isMainButton","setPointerCapture","pointerId","point","moveTo","now","Date","getTime","elapsed","minTimeDelta","lastPoint","length","minDelta","distanceTo","lineTo","segments","curveFromPoints","paths","splice","button"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-inputs-common/dist/es2015/signature/signature-pad.js"],"sourcesContent":["import { exportImage, geometry, Group, MultiPath, Path, Image, Surface, } from '@progress/kendo-drawing';\nimport { elementOffset, limitValue } from '../common';\nconst { Point, Rect, transform } = geometry;\nconst noop = () => { };\nconst DECIMAL_DIGITS = 3;\nconst DEFAULT_COLOR = '#000';\nconst DEFAULT_BACKGROUND_COLOR = '#fff';\nconst DEFAULT_PRECISION = 1;\nconst DEFAULT_SAMPLING_RATE = 200; // Updates per second\nconst DEFAULT_STROKE_WIDTH = 1;\nconst DEFAULT_WIDTH = 750;\nconst DEFAULT_HEIGHT = 250;\nconst DEFAULT_SCALE = 1;\n// Export images at maximized scale (3x) and 2x pixel density to cover HiDPI screens.\nconst DEFAULT_EXPORT_SCALE = 6;\nexport class SignaturePad {\n    constructor(element, options = {}) {\n        this.element = element;\n        this.lastMoveTime = 0;\n        this.options = Object.assign({\n            scale: DEFAULT_SCALE,\n            precision: DEFAULT_PRECISION,\n            samplingRate: DEFAULT_SAMPLING_RATE,\n            smooth: options.smooth !== false,\n            color: options.color || DEFAULT_COLOR,\n            backgroundColor: options.backgroundColor || DEFAULT_BACKGROUND_COLOR,\n            strokeWidth: DEFAULT_STROKE_WIDTH,\n            onChange: noop,\n            onDraw: noop,\n            onDrawEnd: noop\n        }, options);\n        this.pathOptions = {\n            stroke: {\n                color: this.options.color,\n                width: this.options.strokeWidth,\n                lineCap: 'round',\n                lineJoin: 'round'\n            }\n        };\n        this.initSurface();\n        this.attachEvents();\n    }\n    destroy() {\n        this.detachEvents();\n    }\n    clear() {\n        this.rootGroup.clear();\n        this.path = null;\n    }\n    get isDrawing() {\n        return Boolean(this.points);\n    }\n    get pathData() {\n        var _a;\n        return (_a = this.path) === null || _a === void 0 ? void 0 : _a.toString(DECIMAL_DIGITS);\n    }\n    set pathData(value) {\n        this.clear();\n        this.path = MultiPath.parse(value, this.pathOptions);\n        this.rootGroup.append(this.path);\n    }\n    loadImage(data, size = []) {\n        if (!data) {\n            this.clear();\n            return;\n        }\n        const [width, height] = this.size;\n        const contentWidth = width / this.options.scale;\n        const contentHeight = height / this.options.scale;\n        const importWidth = size[0] || contentWidth * DEFAULT_EXPORT_SCALE;\n        const importHeight = size[1] || contentHeight * DEFAULT_EXPORT_SCALE;\n        const scaleX = contentWidth / importWidth;\n        const scaleY = contentHeight / importHeight;\n        const scale = Math.min(scaleX, scaleY);\n        const img = new Image(data, new geometry.Rect([0, 0], [importWidth, importHeight]));\n        img.transform(transform().scale(scale, scale));\n        this.clear();\n        this.rootGroup.append(img);\n    }\n    exportImage(options) {\n        const [width, height] = this.size;\n        const contentWidth = width / this.options.scale;\n        const contentHeight = height / this.options.scale;\n        const exportWidth = (options === null || options === void 0 ? void 0 : options.width) || contentWidth * DEFAULT_EXPORT_SCALE;\n        const exportHeight = (options === null || options === void 0 ? void 0 : options.height) || contentHeight * DEFAULT_EXPORT_SCALE;\n        const scaleX = exportWidth / contentWidth;\n        const scaleY = exportHeight / contentHeight;\n        const scale = Math.min(scaleX, scaleY);\n        const exportRect = new Rect([0, 0], [exportWidth, exportHeight]);\n        const exportGroup = new Group({\n            clip: Path.fromRect(exportRect)\n        });\n        const contentGroup = new Group({\n            transform: transform().scale(scale, scale)\n        });\n        const frame = Path.fromRect(exportRect, {\n            fill: {\n                color: this.options.backgroundColor\n            }\n        });\n        exportGroup.append(frame);\n        exportGroup.append(contentGroup);\n        contentGroup.children.push(...this.rootGroup.children);\n        return exportImage(exportGroup, Object.assign({\n            width: exportWidth,\n            height: exportHeight\n        }, options));\n    }\n    resize() {\n        this.surface.resize(true);\n    }\n    setOptions(options) {\n        Object.assign(this.options, options);\n        this.pathOptions.stroke.color = this.options.color;\n        this.pathOptions.stroke.width = this.options.strokeWidth;\n        if (this.path) {\n            this.path.options.set('stroke.color', this.options.color);\n            this.path.options.set('stroke.width', this.options.strokeWidth);\n        }\n        this.background.options.set('fill.color', this.options.backgroundColor);\n    }\n    initSurface() {\n        this.surface = Surface.create(this.element, { type: 'canvas' });\n        this.element.style.touchAction = 'none';\n        const scale = this.options.scale;\n        this.rootGroup = new Group({\n            transform: transform().scale(scale, scale)\n        });\n        // The signature is not resizable, store initial dimensions.\n        const width = this.element.offsetWidth || DEFAULT_WIDTH;\n        const height = this.element.offsetHeight || DEFAULT_HEIGHT;\n        this.size = [width, height];\n        this.background = Path.fromRect(new Rect([0, 0], this.size), {\n            fill: {\n                color: this.options.backgroundColor\n            }\n        });\n        this.surface.draw(this.background);\n        this.surface.draw(this.rootGroup);\n    }\n    attachEvents() {\n        this.onPointerDown = this.onPointerDown.bind(this);\n        this.onPointerMove = this.onPointerMove.bind(this);\n        this.onPointerUp = this.onPointerUp.bind(this);\n        this.element.addEventListener('pointerdown', this.onPointerDown);\n        this.element.addEventListener('pointermove', this.onPointerMove);\n        this.element.addEventListener('pointerup', this.onPointerUp);\n    }\n    detachEvents() {\n        this.element.removeEventListener('pointerdown', this.onPointerDown);\n        this.element.removeEventListener('pointermove', this.onPointerMove);\n        this.element.removeEventListener('pointerup', this.onPointerUp);\n    }\n    touchPoint(e) {\n        const offset = elementOffset(this.element);\n        const pageX = e.pageX;\n        const pageY = e.pageY;\n        const scale = 1 / this.options.scale;\n        return new Point(pageX - offset.left, pageY - offset.top).scale(scale, scale);\n    }\n    onPointerDown(e) {\n        if (this.options.readonly || !e.isPrimary || !isMainButton(e)) {\n            return;\n        }\n        if (!this.path) {\n            this.path = new MultiPath(this.pathOptions);\n            this.rootGroup.append(this.path);\n        }\n        this.options.onDraw();\n        this.element.setPointerCapture(e.pointerId);\n        const point = this.touchPoint(e);\n        this.points = [point];\n        this.path.moveTo(point);\n    }\n    onPointerMove(e) {\n        if (!this.points || !e.isPrimary) {\n            return;\n        }\n        const now = (new Date()).getTime();\n        const elapsed = now - this.lastMoveTime;\n        const minTimeDelta = 1000 / limitValue(this.options.samplingRate, 1, 10000);\n        if (elapsed < minTimeDelta) {\n            return;\n        }\n        else {\n            this.lastMoveTime = now;\n        }\n        const point = this.touchPoint(e);\n        const lastPoint = this.points[this.points.length - 1];\n        const minDelta = 1 / limitValue(this.options.precision, 0.01, 100);\n        if (point.distanceTo(lastPoint) < minDelta) {\n            return;\n        }\n        this.points.push(point);\n        this.path.lineTo(point);\n    }\n    onPointerUp(e) {\n        if (!e.isPrimary || !this.path || !this.points || this.options.readonly) {\n            return;\n        }\n        if (this.options.smooth) {\n            const segments = Path.curveFromPoints(this.points);\n            this.path.paths.splice(this.path.paths.length - 1, 1, segments);\n        }\n        this.points = null;\n        this.options.onDrawEnd();\n        this.options.onChange(this.pathData);\n    }\n}\nfunction isMainButton(e) {\n    return typeof (e.button) !== 'number' || e.button === 0;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}