{"ast":null,"code":"import { geometry as geom, drawing as draw } from '@progress/kendo-drawing';\nimport ShapeBuilder from '../shape-builder';\nimport Ring from '../ring';\nimport Point from '../point';\nimport { ARC } from '../../common/constants';\nimport { append, deg, rad } from '../../common';\nconst RadarNumericAxisMixin = {\n  options: {\n    majorGridLines: {\n      visible: true\n    }\n  },\n  createPlotBands: function () {\n    const {\n      majorGridLines: {\n        type\n      },\n      plotBands = []\n    } = this.options;\n    const altAxis = this.plotArea.polarAxis;\n    const majorAngles = altAxis.majorAngles();\n    const center = altAxis.box.center();\n    const group = this._plotbandGroup = new draw.Group({\n      zIndex: -1\n    });\n    for (let i = 0; i < plotBands.length; i++) {\n      const band = plotBands[i];\n      const bandStyle = {\n        fill: {\n          color: band.color,\n          opacity: band.opacity\n        },\n        stroke: {\n          opacity: band.opacity\n        }\n      };\n      const slot = this.getSlot(band.from, band.to, true);\n      const ring = new Ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);\n      let shape;\n      if (type === ARC) {\n        shape = ShapeBuilder.current.createRing(ring, bandStyle);\n      } else {\n        shape = draw.Path.fromPoints(this.plotBandPoints(ring, majorAngles), bandStyle).close();\n      }\n      group.append(shape);\n    }\n    this.appendVisual(group);\n  },\n  plotBandPoints: function (ring, angles) {\n    const innerPoints = [];\n    const outerPoints = [];\n    const center = [ring.center.x, ring.center.y];\n    const innerCircle = new geom.Circle(center, ring.innerRadius);\n    const outerCircle = new geom.Circle(center, ring.radius);\n    for (let i = 0; i < angles.length; i++) {\n      innerPoints.push(innerCircle.pointAt(angles[i] + 180));\n      outerPoints.push(outerCircle.pointAt(angles[i] + 180));\n    }\n    innerPoints.reverse();\n    innerPoints.push(innerPoints[0]);\n    outerPoints.push(outerPoints[0]);\n    return outerPoints.concat(innerPoints);\n  },\n  createGridLines: function (altAxis) {\n    const options = this.options;\n    const majorTicks = this.radarMajorGridLinePositions();\n    const majorAngles = altAxis.majorAngles();\n    const center = altAxis.box.center();\n    let gridLines = [];\n    if (options.majorGridLines.visible) {\n      gridLines = this.renderGridLines(center, majorTicks, majorAngles, options.majorGridLines);\n    }\n    if (options.minorGridLines.visible) {\n      const minorTicks = this.radarMinorGridLinePositions();\n      append(gridLines, this.renderGridLines(center, minorTicks, majorAngles, options.minorGridLines));\n    }\n    return gridLines;\n  },\n  renderGridLines: function (center, ticks, angles, options) {\n    const style = {\n      stroke: {\n        width: options.width,\n        color: options.color,\n        dashType: options.dashType\n      }\n    };\n    const {\n      skip = 0,\n      step = 0\n    } = options;\n    const container = this.gridLinesVisual();\n    for (let tickIx = skip; tickIx < ticks.length; tickIx += step) {\n      const tickRadius = center.y - ticks[tickIx];\n      if (tickRadius > 0) {\n        const circle = new geom.Circle([center.x, center.y], tickRadius);\n        if (options.type === ARC) {\n          container.append(new draw.Circle(circle, style));\n        } else {\n          const line = new draw.Path(style);\n          for (let angleIx = 0; angleIx < angles.length; angleIx++) {\n            line.lineTo(circle.pointAt(angles[angleIx] + 180));\n          }\n          line.close();\n          container.append(line);\n        }\n      }\n    }\n    return container.children;\n  },\n  getValue: function (point) {\n    const lineBox = this.lineBox();\n    const altAxis = this.plotArea.polarAxis;\n    const majorAngles = altAxis.majorAngles();\n    const center = altAxis.box.center();\n    const radius = point.distanceTo(center);\n    let distance = radius;\n    if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {\n      const dx = point.x - center.x;\n      const dy = point.y - center.y;\n      const theta = (deg(Math.atan2(dy, dx)) + 540) % 360;\n      majorAngles.sort(function (a, b) {\n        return angularDistance(a, theta) - angularDistance(b, theta);\n      });\n\n      // Solve triangle (center, point, axis X) using one side (radius) and two angles.\n      // Angles are derived from triangle (center, point, gridline X)\n      const midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;\n      const alpha = angularDistance(theta, majorAngles[0]);\n      const gamma = 90 - midAngle;\n      const beta = 180 - alpha - gamma;\n      distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));\n    }\n    return this.axisType().prototype.getValue.call(this, new Point(lineBox.x1, lineBox.y2 - distance));\n  }\n};\nfunction angularDistance(a, b) {\n  return 180 - Math.abs(Math.abs(a - b) - 180);\n}\nexport default RadarNumericAxisMixin;","map":{"version":3,"names":["geometry","geom","drawing","draw","ShapeBuilder","Ring","Point","ARC","append","deg","rad","RadarNumericAxisMixin","options","majorGridLines","visible","createPlotBands","type","plotBands","altAxis","plotArea","polarAxis","majorAngles","center","box","group","_plotbandGroup","Group","zIndex","i","length","band","bandStyle","fill","color","opacity","stroke","slot","getSlot","from","to","ring","y","y2","y1","shape","current","createRing","Path","fromPoints","plotBandPoints","close","appendVisual","angles","innerPoints","outerPoints","x","innerCircle","Circle","innerRadius","outerCircle","radius","push","pointAt","reverse","concat","createGridLines","majorTicks","radarMajorGridLinePositions","gridLines","renderGridLines","minorGridLines","minorTicks","radarMinorGridLinePositions","ticks","style","width","dashType","skip","step","container","gridLinesVisual","tickIx","tickRadius","circle","line","angleIx","lineTo","children","getValue","point","lineBox","distanceTo","distance","dx","dy","theta","Math","atan2","sort","a","b","angularDistance","midAngle","alpha","gamma","beta","sin","axisType","prototype","call","x1","abs"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/core/mixins/radar-numeric-axis-mixin.js"],"sourcesContent":["import { geometry as geom, drawing as draw } from '@progress/kendo-drawing';\n\nimport ShapeBuilder from '../shape-builder';\nimport Ring from '../ring';\nimport Point from '../point';\n\nimport { ARC } from '../../common/constants';\nimport { append, deg, rad } from '../../common';\n\nconst RadarNumericAxisMixin = {\n    options: {\n        majorGridLines: {\n            visible: true\n        }\n    },\n\n    createPlotBands: function() {\n        const { majorGridLines: { type }, plotBands = [] } = this.options;\n        const altAxis = this.plotArea.polarAxis;\n        const majorAngles = altAxis.majorAngles();\n        const center = altAxis.box.center();\n        const group = this._plotbandGroup = new draw.Group({\n            zIndex: -1\n        });\n\n        for (let i = 0; i < plotBands.length; i++) {\n            const band = plotBands[i];\n            const bandStyle = {\n                fill: {\n                    color: band.color,\n                    opacity: band.opacity\n                },\n                stroke: {\n                    opacity: band.opacity\n                }\n            };\n\n            const slot = this.getSlot(band.from, band.to, true);\n            const ring = new Ring(center, center.y - slot.y2, center.y - slot.y1, 0, 360);\n\n            let shape;\n            if (type === ARC) {\n                shape = ShapeBuilder.current.createRing(ring, bandStyle);\n            } else {\n                shape = draw.Path.fromPoints(this.plotBandPoints(ring, majorAngles), bandStyle).close();\n            }\n\n            group.append(shape);\n        }\n\n        this.appendVisual(group);\n    },\n\n    plotBandPoints: function(ring, angles) {\n        const innerPoints = [];\n        const outerPoints = [];\n        const center = [ ring.center.x, ring.center.y ];\n        const innerCircle = new geom.Circle(center, ring.innerRadius);\n        const outerCircle = new geom.Circle(center, ring.radius);\n\n        for (let i = 0; i < angles.length; i++) {\n            innerPoints.push(innerCircle.pointAt(angles[i] + 180));\n            outerPoints.push(outerCircle.pointAt(angles[i] + 180));\n        }\n\n        innerPoints.reverse();\n        innerPoints.push(innerPoints[0]);\n        outerPoints.push(outerPoints[0]);\n\n        return outerPoints.concat(innerPoints);\n    },\n\n    createGridLines: function(altAxis) {\n        const options = this.options;\n        const majorTicks = this.radarMajorGridLinePositions();\n        const majorAngles = altAxis.majorAngles();\n        const center = altAxis.box.center();\n        let gridLines = [];\n\n        if (options.majorGridLines.visible) {\n            gridLines = this.renderGridLines(\n                center, majorTicks, majorAngles, options.majorGridLines\n            );\n        }\n\n        if (options.minorGridLines.visible) {\n            const minorTicks = this.radarMinorGridLinePositions();\n            append(gridLines, this.renderGridLines(\n                center, minorTicks, majorAngles, options.minorGridLines\n            ));\n        }\n\n        return gridLines;\n    },\n\n    renderGridLines: function(center, ticks, angles, options) {\n        const style = {\n            stroke: {\n                width: options.width,\n                color: options.color,\n                dashType: options.dashType\n            }\n        };\n        const { skip = 0, step = 0 } = options;\n        const container = this.gridLinesVisual();\n\n        for (let tickIx = skip; tickIx < ticks.length; tickIx += step) {\n            const tickRadius = center.y - ticks[tickIx];\n            if (tickRadius > 0) {\n                const circle = new geom.Circle([ center.x, center.y ], tickRadius);\n                if (options.type === ARC) {\n                    container.append(new draw.Circle(circle, style));\n                } else {\n                    const line = new draw.Path(style);\n                    for (let angleIx = 0; angleIx < angles.length; angleIx++) {\n                        line.lineTo(circle.pointAt(angles[angleIx] + 180));\n                    }\n\n                    line.close();\n                    container.append(line);\n                }\n            }\n        }\n\n        return container.children;\n    },\n\n    getValue: function(point) {\n        const lineBox = this.lineBox();\n        const altAxis = this.plotArea.polarAxis;\n        const majorAngles = altAxis.majorAngles();\n        const center = altAxis.box.center();\n        const radius = point.distanceTo(center);\n        let distance = radius;\n\n        if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {\n            const dx = point.x - center.x;\n            const dy = point.y - center.y;\n            const theta = (deg(Math.atan2(dy, dx)) + 540) % 360;\n\n            majorAngles.sort(function(a, b) {\n                return angularDistance(a, theta) - angularDistance(b, theta);\n            });\n\n            // Solve triangle (center, point, axis X) using one side (radius) and two angles.\n            // Angles are derived from triangle (center, point, gridline X)\n            const midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;\n            const alpha = angularDistance(theta, majorAngles[0]);\n            const gamma = 90 - midAngle;\n            const beta = 180 - alpha - gamma;\n\n            distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));\n        }\n\n        return this.axisType().prototype.getValue.call(\n            this, new Point(lineBox.x1, lineBox.y2 - distance)\n        );\n    }\n};\n\nfunction angularDistance(a, b) {\n    return 180 - Math.abs(Math.abs(a - b) - 180);\n}\n\nexport default RadarNumericAxisMixin;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}