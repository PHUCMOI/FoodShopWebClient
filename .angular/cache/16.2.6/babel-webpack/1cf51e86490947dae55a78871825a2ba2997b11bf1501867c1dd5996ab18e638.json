{"ast":null,"code":"import { geometry as geom } from '@progress/kendo-drawing';\nimport { ChartElement, TextBox } from '../../core';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport FunnelSegment from './funnel-segment';\nimport { bindSegments, evalOptions } from '../utils';\nimport { CENTER, LEFT } from '../../common/constants';\nimport { autoTextColor, deepExtend, isFunction, getTemplate, limitValue, setDefaultOptions } from '../../common';\nclass FunnelChart extends ChartElement {\n  constructor(plotArea, options) {\n    super(options);\n    this.plotArea = plotArea;\n    this.points = [];\n    this.labels = [];\n    this.legendItems = [];\n    this.render();\n  }\n  formatPointValue(point, format) {\n    return this.chartService.format.auto(format, point.value);\n  }\n  render() {\n    const {\n      options,\n      plotArea: {\n        options: {\n          seriesColors = []\n        }\n      }\n    } = this;\n    const series = options.series[0];\n    const data = series.data;\n    if (!data) {\n      return;\n    }\n    const {\n      total,\n      points\n    } = bindSegments(series);\n    for (let i = 0; i < points.length; i++) {\n      const pointData = points[i];\n      if (!pointData) {\n        continue;\n      }\n      let fields = pointData.fields;\n      if (!isFunction(series.color)) {\n        series.color = fields.color || seriesColors[i % seriesColors.length];\n      }\n      fields = deepExtend({\n        index: i,\n        owner: this,\n        series: series,\n        dataItem: data[i],\n        percentage: pointData.value / total\n      }, fields, {\n        visible: pointData.visible\n      });\n      const value = pointData.valueFields.value;\n      const segment = this.createSegment(value, fields);\n      const label = this.createLabel(value, fields);\n      if (segment && label) {\n        segment.append(label);\n      }\n    }\n  }\n  evalSegmentOptions(options, value, fields) {\n    const series = fields.series;\n    evalOptions(options, {\n      value: value,\n      series: series,\n      dataItem: fields.dataItem,\n      index: fields.index\n    }, {\n      defaults: series._defaults,\n      excluded: [\"data\", \"content\", \"template\", \"toggle\", \"visual\"]\n    });\n  }\n  createSegment(value, fields) {\n    const seriesOptions = deepExtend({}, fields.series);\n    this.evalSegmentOptions(seriesOptions, value, fields);\n    this.createLegendItem(value, seriesOptions, fields);\n    if (fields.visible !== false) {\n      const segment = new FunnelSegment(value, seriesOptions, fields);\n      Object.assign(segment, fields);\n      this.append(segment);\n      this.points.push(segment);\n      return segment;\n    }\n  }\n  createLabel(value, fields) {\n    const {\n      series,\n      dataItem\n    } = fields;\n    const labels = deepExtend({}, this.options.labels, series.labels);\n    let text = value;\n    if (labels.visible) {\n      const labelTemplate = getTemplate(labels);\n      const data = {\n        dataItem: dataItem,\n        value: value,\n        percentage: fields.percentage,\n        category: fields.category,\n        series: series\n      };\n      if (labelTemplate) {\n        text = labelTemplate(data);\n      } else if (labels.format) {\n        text = this.plotArea.chartService.format.auto(labels.format, text);\n      }\n      if (!labels.color) {\n        labels.color = autoTextColor(series.color);\n        if (!labels.background) {\n          labels.background = series.color;\n        }\n      }\n      this.evalSegmentOptions(labels, value, fields);\n      const textBox = new TextBox(text, deepExtend({\n        vAlign: labels.position\n      }, labels), data);\n      this.labels.push(textBox);\n      return textBox;\n    }\n  }\n  labelPadding() {\n    const labels = this.labels;\n    const padding = {\n      left: 0,\n      right: 0\n    };\n    for (let i = 0; i < labels.length; i++) {\n      const label = labels[i];\n      const align = label.options.align;\n      if (align !== CENTER) {\n        const width = labels[i].box.width();\n        if (align === LEFT) {\n          padding.left = Math.max(padding.left, width);\n        } else {\n          padding.right = Math.max(padding.right, width);\n        }\n      }\n    }\n    return padding;\n  }\n  dynamicSlopeReflow(box, width, totalHeight) {\n    const {\n      options,\n      points: segments\n    } = this;\n    const count = segments.length;\n    const firstSegment = segments[0];\n    let maxSegment = firstSegment;\n    for (let idx = 0; idx < segments.length; idx++) {\n      if (segments[idx].percentage > maxSegment.percentage) {\n        maxSegment = segments[idx];\n      }\n    }\n    let lastUpperSide = firstSegment.percentage / maxSegment.percentage * width;\n    let previousOffset = (width - lastUpperSide) / 2;\n    let previousHeight = 0;\n    for (let idx = 0; idx < count; idx++) {\n      const percentage = segments[idx].percentage;\n      const nextSegment = segments[idx + 1];\n      const nextPercentage = nextSegment ? nextSegment.percentage : percentage;\n      const points = segments[idx].points = [];\n      const height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;\n      let offset;\n      if (!percentage) {\n        offset = nextPercentage ? 0 : width / 2;\n      } else {\n        offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;\n      }\n      offset = limitValue(offset, 0, width);\n      points.push(new geom.Point(box.x1 + previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - offset, box.y1 + height + previousHeight));\n      points.push(new geom.Point(box.x1 + offset, box.y1 + height + previousHeight));\n      previousOffset = offset;\n      previousHeight += height + options.segmentSpacing;\n      lastUpperSide = limitValue(width - 2 * offset, 0, width);\n    }\n  }\n  constantSlopeReflow(box, width, totalHeight) {\n    const {\n      options,\n      points: segments\n    } = this;\n    const count = segments.length;\n    const decreasingWidth = options.neckRatio <= 1;\n    const neckRatio = decreasingWidth ? options.neckRatio * width : width;\n    let previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;\n    const topMostWidth = decreasingWidth ? width : width - previousOffset * 2;\n    const finalNarrow = (topMostWidth - neckRatio) / 2;\n    let previousHeight = 0;\n    for (let idx = 0; idx < count; idx++) {\n      const points = segments[idx].points = [];\n      const percentage = segments[idx].percentage;\n      const offset = options.dynamicHeight ? finalNarrow * percentage : finalNarrow / count;\n      const height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;\n      points.push(new geom.Point(box.x1 + previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n      points.push(new geom.Point(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));\n      points.push(new geom.Point(box.x1 + previousOffset + offset, box.y1 + height + previousHeight));\n      previousOffset += offset;\n      previousHeight += height + options.segmentSpacing;\n    }\n  }\n  reflow(chartBox) {\n    const points = this.points;\n    const count = points.length;\n    if (!count) {\n      return;\n    }\n    const options = this.options;\n    const box = chartBox.clone().unpad(this.labelPadding());\n    const totalHeight = box.height() - options.segmentSpacing * (count - 1);\n    const width = box.width();\n    if (options.dynamicSlope) {\n      this.dynamicSlopeReflow(box, width, totalHeight);\n    } else {\n      this.constantSlopeReflow(box, width, totalHeight);\n    }\n    for (let idx = 0; idx < count; idx++) {\n      points[idx].reflow(chartBox);\n    }\n  }\n}\nsetDefaultOptions(FunnelChart, {\n  neckRatio: 0.3,\n  width: 300,\n  dynamicSlope: false,\n  dynamicHeight: true,\n  segmentSpacing: 0,\n  labels: {\n    visible: false,\n    align: CENTER,\n    position: CENTER,\n    zIndex: 1\n  }\n});\ndeepExtend(FunnelChart.prototype, PieChartMixin);\nexport default FunnelChart;","map":{"version":3,"names":["geometry","geom","ChartElement","TextBox","PieChartMixin","FunnelSegment","bindSegments","evalOptions","CENTER","LEFT","autoTextColor","deepExtend","isFunction","getTemplate","limitValue","setDefaultOptions","FunnelChart","constructor","plotArea","options","points","labels","legendItems","render","formatPointValue","point","format","chartService","auto","value","seriesColors","series","data","total","i","length","pointData","fields","color","index","owner","dataItem","percentage","visible","valueFields","segment","createSegment","label","createLabel","append","evalSegmentOptions","defaults","_defaults","excluded","seriesOptions","createLegendItem","Object","assign","push","text","labelTemplate","category","background","textBox","vAlign","position","labelPadding","padding","left","right","align","width","box","Math","max","dynamicSlopeReflow","totalHeight","segments","count","firstSegment","maxSegment","idx","lastUpperSide","previousOffset","previousHeight","nextSegment","nextPercentage","height","dynamicHeight","offset","Point","x1","y1","segmentSpacing","constantSlopeReflow","decreasingWidth","neckRatio","topMostWidth","finalNarrow","reflow","chartBox","clone","unpad","dynamicSlope","zIndex","prototype"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/funnel-chart/funnel-chart.js"],"sourcesContent":["import { geometry as geom } from '@progress/kendo-drawing';\n\nimport { ChartElement, TextBox } from '../../core';\nimport PieChartMixin from '../mixins/pie-chart-mixin';\nimport FunnelSegment from './funnel-segment';\n\nimport { bindSegments, evalOptions } from '../utils';\n\nimport { CENTER, LEFT } from '../../common/constants';\nimport { autoTextColor, deepExtend, isFunction, getTemplate, limitValue, setDefaultOptions } from '../../common';\n\nclass FunnelChart extends ChartElement {\n    constructor(plotArea, options) {\n        super(options);\n\n        this.plotArea = plotArea;\n        this.points = [];\n        this.labels = [];\n        this.legendItems = [];\n        this.render();\n    }\n\n    formatPointValue(point, format) {\n        return this.chartService.format.auto(format,point.value);\n    }\n\n    render() {\n        const { options, plotArea: { options: { seriesColors = [] } } } = this;\n        const series = options.series[0];\n        const data = series.data;\n\n        if (!data) {\n            return;\n        }\n\n        const { total, points } = bindSegments(series);\n\n        for (let i = 0; i < points.length; i++) {\n            const pointData = points[i];\n\n            if (!pointData) {\n                continue;\n            }\n\n            let fields = pointData.fields;\n\n            if (!isFunction(series.color)) {\n                series.color = fields.color || seriesColors[i % seriesColors.length];\n            }\n\n            fields = deepExtend({\n                index: i,\n                owner: this,\n                series: series,\n                dataItem: data[i],\n                percentage: pointData.value / total\n            }, fields, { visible: pointData.visible });\n\n            const value = pointData.valueFields.value;\n            const segment = this.createSegment(value, fields);\n            const label = this.createLabel(value, fields);\n\n            if (segment && label) {\n                segment.append(label);\n            }\n        }\n    }\n\n    evalSegmentOptions(options, value, fields) {\n        const series = fields.series;\n\n        evalOptions(options, {\n            value: value,\n            series: series,\n            dataItem: fields.dataItem,\n            index: fields.index\n        }, { defaults: series._defaults, excluded: [ \"data\", \"content\", \"template\", \"toggle\", \"visual\" ] });\n    }\n\n    createSegment(value, fields) {\n        const seriesOptions = deepExtend({}, fields.series);\n        this.evalSegmentOptions(seriesOptions, value, fields);\n\n        this.createLegendItem(value, seriesOptions, fields);\n\n        if (fields.visible !== false) {\n\n            const segment = new FunnelSegment(value, seriesOptions, fields);\n            Object.assign(segment, fields);\n\n            this.append(segment);\n            this.points.push(segment);\n\n            return segment;\n        }\n    }\n\n    createLabel(value, fields) {\n        const { series, dataItem } = fields;\n        const labels = deepExtend({}, this.options.labels, series.labels);\n        let text = value;\n\n        if (labels.visible) {\n            const labelTemplate = getTemplate(labels);\n            const data = {\n                dataItem: dataItem,\n                value: value,\n                percentage: fields.percentage,\n                category: fields.category,\n                series: series\n            };\n            if (labelTemplate) {\n                text = labelTemplate(data);\n            } else if (labels.format) {\n                text = this.plotArea.chartService.format.auto(labels.format, text);\n            }\n\n            if (!labels.color) {\n                labels.color = autoTextColor(series.color);\n                if (!labels.background) {\n                    labels.background = series.color;\n                }\n            }\n\n            this.evalSegmentOptions(labels, value, fields);\n            const textBox = new TextBox(text, deepExtend({\n                vAlign: labels.position\n            }, labels), data);\n\n            this.labels.push(textBox);\n\n            return textBox;\n        }\n    }\n\n    labelPadding() {\n        const labels = this.labels;\n        const padding = { left: 0, right: 0 };\n\n        for (let i = 0; i < labels.length; i++) {\n            const label = labels[i];\n            const align = label.options.align;\n            if (align !== CENTER) {\n                const width = labels[i].box.width();\n\n                if (align === LEFT) {\n                    padding.left = Math.max(padding.left, width);\n                } else {\n                    padding.right = Math.max(padding.right, width);\n                }\n            }\n        }\n\n        return padding;\n    }\n\n    dynamicSlopeReflow(box, width, totalHeight) {\n        const { options, points: segments } = this;\n        const count = segments.length;\n        const firstSegment = segments[0];\n        let maxSegment = firstSegment;\n\n        for (let idx = 0; idx < segments.length; idx++) {\n            if (segments[idx].percentage > maxSegment.percentage) {\n                maxSegment = segments[idx];\n            }\n        }\n\n        let lastUpperSide = (firstSegment.percentage / maxSegment.percentage) * width;\n        let previousOffset = (width - lastUpperSide) / 2;\n        let previousHeight = 0;\n\n        for (let idx = 0; idx < count; idx++) {\n            const percentage = segments[idx].percentage;\n            const nextSegment = segments[idx + 1];\n            const nextPercentage = (nextSegment ? nextSegment.percentage : percentage);\n            const points = segments[idx].points = [];\n            const height = (options.dynamicHeight) ? (totalHeight * percentage) : (totalHeight / count);\n            let offset;\n\n            if (!percentage) {\n                offset = nextPercentage ? 0 : width / 2;\n            } else {\n                offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;\n            }\n\n            offset = limitValue(offset, 0, width);\n\n            points.push(new geom.Point(box.x1 + previousOffset, box.y1 + previousHeight));\n            points.push(new geom.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n            points.push(new geom.Point(box.x1 + width - offset, box.y1 + height + previousHeight));\n            points.push(new geom.Point(box.x1 + offset, box.y1 + height + previousHeight));\n\n            previousOffset = offset;\n            previousHeight += height + options.segmentSpacing;\n            lastUpperSide = limitValue(width - 2 * offset, 0, width);\n        }\n    }\n\n    constantSlopeReflow(box, width, totalHeight) {\n        const { options, points: segments } = this;\n        const count = segments.length;\n        const decreasingWidth = options.neckRatio <= 1;\n        const neckRatio = decreasingWidth ? options.neckRatio * width : width;\n        let previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;\n        const topMostWidth = decreasingWidth ? width : width - previousOffset * 2;\n        const finalNarrow = (topMostWidth - neckRatio) / 2;\n        let previousHeight = 0;\n\n        for (let idx = 0; idx < count; idx++) {\n            const points = segments[idx].points = [];\n            const percentage = segments[idx].percentage;\n            const offset = (options.dynamicHeight) ? (finalNarrow * percentage) : (finalNarrow / count);\n            const height = (options.dynamicHeight) ? (totalHeight * percentage) : (totalHeight / count);\n\n            points.push(new geom.Point(box.x1 + previousOffset, box.y1 + previousHeight));\n            points.push(new geom.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));\n            points.push(new geom.Point(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));\n            points.push(new geom.Point(box.x1 + previousOffset + offset,box.y1 + height + previousHeight));\n            previousOffset += offset;\n            previousHeight += height + options.segmentSpacing;\n        }\n    }\n\n    reflow(chartBox) {\n        const points = this.points;\n        const count = points.length;\n\n        if (!count) {\n            return;\n        }\n\n        const options = this.options;\n        const box = chartBox.clone().unpad(this.labelPadding());\n        const totalHeight = box.height() - options.segmentSpacing * (count - 1);\n        const width = box.width();\n\n        if (options.dynamicSlope) {\n            this.dynamicSlopeReflow(box, width, totalHeight);\n        } else {\n            this.constantSlopeReflow(box, width, totalHeight);\n        }\n\n        for (let idx = 0; idx < count; idx++) {\n            points[idx].reflow(chartBox);\n        }\n    }\n}\n\nsetDefaultOptions(FunnelChart, {\n    neckRatio: 0.3,\n    width: 300,\n    dynamicSlope: false,\n    dynamicHeight: true,\n    segmentSpacing: 0,\n    labels: {\n        visible: false,\n        align: CENTER,\n        position: CENTER,\n        zIndex: 1\n    }\n});\n\ndeepExtend(FunnelChart.prototype, PieChartMixin);\n\nexport default FunnelChart;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}