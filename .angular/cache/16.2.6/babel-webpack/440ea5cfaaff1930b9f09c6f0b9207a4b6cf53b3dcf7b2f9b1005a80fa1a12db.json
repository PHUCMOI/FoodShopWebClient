{"ast":null,"code":"import { Constants } from '../common/constants';\nimport { Key } from '../common/key';\n/**\n * @hidden\n */\nexport const padZero = length => new Array(Math.max(length, 0)).fill('0').join('');\n/**\n * @hidden\n */\nexport const unpadZero = value => value.replace(/^0*/, '');\n/**\n * @hidden\n */\nexport const approximateStringMatching = ({\n  oldText,\n  newText,\n  formatPattern,\n  selectionStart,\n  isInCaretMode,\n  keyEvent\n}) => {\n  /*\n    Remove the right part of the cursor.\n    oldFormat = oldFormat.substring(0, caret + oldText.length - newText.length);\n  */\n  const oldIndex = selectionStart + oldText.length - newText.length;\n  const oldTextSeparator = oldText[oldIndex];\n  const oldSegmentText = oldText.substring(0, oldIndex);\n  const newSegmentText = newText.substring(0, selectionStart);\n  const diff = [];\n  /* Handle the typing of a single character over the same selection. */\n  if (oldSegmentText === newSegmentText && selectionStart > 0) {\n    diff.push([formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]);\n    return diff;\n  }\n  if (oldSegmentText.indexOf(newSegmentText) === 0 && isInCaretMode && (keyEvent.key === Key.DELETE || keyEvent.key === Key.BACKSPACE) || oldSegmentText.indexOf(newSegmentText) === 0 && !isInCaretMode && (newSegmentText.length === 0 || formatPattern[newSegmentText.length - 1] !== formatPattern[newSegmentText.length])) {\n    /* Handle Delete/Backspace. */\n    let deletedSymbol = '';\n    /*\n        The whole text is replaced by the same character.\n        A nasty patch is required to keep the selection in the first segment.\n    */\n    if (!isInCaretMode && newSegmentText.length === 1) {\n      diff.push([formatPattern[0], newSegmentText[0]]);\n    }\n    for (let i = newSegmentText.length; i < oldSegmentText.length; i++) {\n      if (formatPattern[i] !== deletedSymbol && formatPattern[i] !== Constants.formatSeparator) {\n        deletedSymbol = formatPattern[i];\n        diff.push([deletedSymbol, '']);\n      }\n    }\n    return diff;\n  }\n  /*\n      Handle the insertion of the text (the new text is longer than the previous one).\n      Handle the typing over a literal as well.\n  */\n  if (isInCaretMode && (newSegmentText.indexOf(oldSegmentText) === 0 || formatPattern[selectionStart - 1] === Constants.formatSeparator) || !isInCaretMode && (newSegmentText.indexOf(oldSegmentText) === 0 || formatPattern[selectionStart - 1] === Constants.formatSeparator)) {\n    let symbol = formatPattern[0];\n    for (let i = Math.max(0, oldSegmentText.length - 1); i < formatPattern.length; i++) {\n      if (formatPattern[i] !== Constants.formatSeparator) {\n        symbol = formatPattern[i];\n        break;\n      }\n    }\n    return [[symbol, newSegmentText[selectionStart - 1]]];\n  }\n  /* Handle the entering of a space or a separator for navigating to the next item. */\n  if (newSegmentText[newSegmentText.length - 1] === ' ' || newSegmentText[newSegmentText.length - 1] === oldTextSeparator && formatPattern[oldIndex] === '_') {\n    return [[formatPattern[selectionStart - 1], Constants.formatSeparator]];\n  }\n  /* Handle typing over a correctly selected part. */\n  const result = [[formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]];\n  return result;\n};\n/**\n * @hidden\n */\nexport const dateSymbolMap = (map, part) => {\n  map[part.pattern[0]] = part.type;\n  return map;\n};\n/**\n * @hidden\n */\nexport const isInRange = (candidate, min, max) => candidate === null || !(min && min > candidate || max && max < candidate);","map":{"version":3,"names":["Constants","Key","padZero","length","Array","Math","max","fill","join","unpadZero","value","replace","approximateStringMatching","oldText","newText","formatPattern","selectionStart","isInCaretMode","keyEvent","oldIndex","oldTextSeparator","oldSegmentText","substring","newSegmentText","diff","push","indexOf","key","DELETE","BACKSPACE","deletedSymbol","i","formatSeparator","symbol","result","dateSymbolMap","map","part","pattern","type","isInRange","candidate","min"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-dateinputs-common/dist/es2015/dateinput/utils.js"],"sourcesContent":["import { Constants } from '../common/constants';\nimport { Key } from '../common/key';\n/**\n * @hidden\n */\nexport const padZero = (length) => new Array(Math.max(length, 0)).fill('0').join('');\n/**\n * @hidden\n */\nexport const unpadZero = (value) => value.replace(/^0*/, '');\n/**\n * @hidden\n */\nexport const approximateStringMatching = ({ oldText, newText, formatPattern, selectionStart, isInCaretMode, keyEvent }) => {\n    /*\n      Remove the right part of the cursor.\n      oldFormat = oldFormat.substring(0, caret + oldText.length - newText.length);\n    */\n    const oldIndex = selectionStart + oldText.length - newText.length;\n    const oldTextSeparator = oldText[oldIndex];\n    const oldSegmentText = oldText.substring(0, oldIndex);\n    const newSegmentText = newText.substring(0, selectionStart);\n    const diff = [];\n    /* Handle the typing of a single character over the same selection. */\n    if (oldSegmentText === newSegmentText && selectionStart > 0) {\n        diff.push([formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]);\n        return diff;\n    }\n    if (oldSegmentText.indexOf(newSegmentText) === 0 && (isInCaretMode &&\n        (keyEvent.key === Key.DELETE || keyEvent.key === Key.BACKSPACE)) ||\n        (oldSegmentText.indexOf(newSegmentText) === 0 && !isInCaretMode &&\n            (newSegmentText.length === 0 ||\n                formatPattern[newSegmentText.length - 1] !== formatPattern[newSegmentText.length]))) {\n        /* Handle Delete/Backspace. */\n        let deletedSymbol = '';\n        /*\n            The whole text is replaced by the same character.\n            A nasty patch is required to keep the selection in the first segment.\n        */\n        if (!isInCaretMode && newSegmentText.length === 1) {\n            diff.push([formatPattern[0], newSegmentText[0]]);\n        }\n        for (let i = newSegmentText.length; i < oldSegmentText.length; i++) {\n            if (formatPattern[i] !== deletedSymbol && formatPattern[i] !== Constants.formatSeparator) {\n                deletedSymbol = formatPattern[i];\n                diff.push([deletedSymbol, '']);\n            }\n        }\n        return diff;\n    }\n    /*\n        Handle the insertion of the text (the new text is longer than the previous one).\n        Handle the typing over a literal as well.\n    */\n    if ((isInCaretMode &&\n        (newSegmentText.indexOf(oldSegmentText) === 0 ||\n            formatPattern[selectionStart - 1] === Constants.formatSeparator)) ||\n        (!isInCaretMode &&\n            (newSegmentText.indexOf(oldSegmentText) === 0 ||\n                formatPattern[selectionStart - 1] === Constants.formatSeparator))) {\n        let symbol = formatPattern[0];\n        for (let i = Math.max(0, oldSegmentText.length - 1); i < formatPattern.length; i++) {\n            if (formatPattern[i] !== Constants.formatSeparator) {\n                symbol = formatPattern[i];\n                break;\n            }\n        }\n        return [[symbol, newSegmentText[selectionStart - 1]]];\n    }\n    /* Handle the entering of a space or a separator for navigating to the next item. */\n    if ((newSegmentText[newSegmentText.length - 1] === ' ') ||\n        (newSegmentText[newSegmentText.length - 1] === oldTextSeparator && formatPattern[oldIndex] === '_')) {\n        return [[formatPattern[selectionStart - 1], Constants.formatSeparator]];\n    }\n    /* Handle typing over a correctly selected part. */\n    const result = [[formatPattern[selectionStart - 1], newSegmentText[selectionStart - 1]]];\n    return result;\n};\n/**\n * @hidden\n */\nexport const dateSymbolMap = (map, part) => {\n    map[part.pattern[0]] = part.type;\n    return map;\n};\n/**\n * @hidden\n */\nexport const isInRange = (candidate, min, max) => (candidate === null || !((min && min > candidate) || (max && max < candidate)));\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,qBAAqB;AAC/C,SAASC,GAAG,QAAQ,eAAe;AACnC;AACA;AACA;AACA,OAAO,MAAMC,OAAO,GAAIC,MAAM,IAAK,IAAIC,KAAK,CAACC,IAAI,CAACC,GAAG,CAACH,MAAM,EAAE,CAAC,CAAC,CAAC,CAACI,IAAI,CAAC,GAAG,CAAC,CAACC,IAAI,CAAC,EAAE,CAAC;AACpF;AACA;AACA;AACA,OAAO,MAAMC,SAAS,GAAIC,KAAK,IAAKA,KAAK,CAACC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC;AAC5D;AACA;AACA;AACA,OAAO,MAAMC,yBAAyB,GAAGA,CAAC;EAAEC,OAAO;EAAEC,OAAO;EAAEC,aAAa;EAAEC,cAAc;EAAEC,aAAa;EAAEC;AAAS,CAAC,KAAK;EACvH;AACJ;AACA;AACA;EACI,MAAMC,QAAQ,GAAGH,cAAc,GAAGH,OAAO,CAACV,MAAM,GAAGW,OAAO,CAACX,MAAM;EACjE,MAAMiB,gBAAgB,GAAGP,OAAO,CAACM,QAAQ,CAAC;EAC1C,MAAME,cAAc,GAAGR,OAAO,CAACS,SAAS,CAAC,CAAC,EAAEH,QAAQ,CAAC;EACrD,MAAMI,cAAc,GAAGT,OAAO,CAACQ,SAAS,CAAC,CAAC,EAAEN,cAAc,CAAC;EAC3D,MAAMQ,IAAI,GAAG,EAAE;EACf;EACA,IAAIH,cAAc,KAAKE,cAAc,IAAIP,cAAc,GAAG,CAAC,EAAE;IACzDQ,IAAI,CAACC,IAAI,CAAC,CAACV,aAAa,CAACC,cAAc,GAAG,CAAC,CAAC,EAAEO,cAAc,CAACP,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC;IAClF,OAAOQ,IAAI;EACf;EACA,IAAIH,cAAc,CAACK,OAAO,CAACH,cAAc,CAAC,KAAK,CAAC,IAAKN,aAAa,KAC7DC,QAAQ,CAACS,GAAG,KAAK1B,GAAG,CAAC2B,MAAM,IAAIV,QAAQ,CAACS,GAAG,KAAK1B,GAAG,CAAC4B,SAAS,CAAE,IAC/DR,cAAc,CAACK,OAAO,CAACH,cAAc,CAAC,KAAK,CAAC,IAAI,CAACN,aAAa,KAC1DM,cAAc,CAACpB,MAAM,KAAK,CAAC,IACxBY,aAAa,CAACQ,cAAc,CAACpB,MAAM,GAAG,CAAC,CAAC,KAAKY,aAAa,CAACQ,cAAc,CAACpB,MAAM,CAAC,CAAE,EAAE;IAC7F;IACA,IAAI2B,aAAa,GAAG,EAAE;IACtB;AACR;AACA;AACA;IACQ,IAAI,CAACb,aAAa,IAAIM,cAAc,CAACpB,MAAM,KAAK,CAAC,EAAE;MAC/CqB,IAAI,CAACC,IAAI,CAAC,CAACV,aAAa,CAAC,CAAC,CAAC,EAAEQ,cAAc,CAAC,CAAC,CAAC,CAAC,CAAC;IACpD;IACA,KAAK,IAAIQ,CAAC,GAAGR,cAAc,CAACpB,MAAM,EAAE4B,CAAC,GAAGV,cAAc,CAAClB,MAAM,EAAE4B,CAAC,EAAE,EAAE;MAChE,IAAIhB,aAAa,CAACgB,CAAC,CAAC,KAAKD,aAAa,IAAIf,aAAa,CAACgB,CAAC,CAAC,KAAK/B,SAAS,CAACgC,eAAe,EAAE;QACtFF,aAAa,GAAGf,aAAa,CAACgB,CAAC,CAAC;QAChCP,IAAI,CAACC,IAAI,CAAC,CAACK,aAAa,EAAE,EAAE,CAAC,CAAC;MAClC;IACJ;IACA,OAAON,IAAI;EACf;EACA;AACJ;AACA;AACA;EACI,IAAKP,aAAa,KACbM,cAAc,CAACG,OAAO,CAACL,cAAc,CAAC,KAAK,CAAC,IACzCN,aAAa,CAACC,cAAc,GAAG,CAAC,CAAC,KAAKhB,SAAS,CAACgC,eAAe,CAAC,IACnE,CAACf,aAAa,KACVM,cAAc,CAACG,OAAO,CAACL,cAAc,CAAC,KAAK,CAAC,IACzCN,aAAa,CAACC,cAAc,GAAG,CAAC,CAAC,KAAKhB,SAAS,CAACgC,eAAe,CAAE,EAAE;IAC3E,IAAIC,MAAM,GAAGlB,aAAa,CAAC,CAAC,CAAC;IAC7B,KAAK,IAAIgB,CAAC,GAAG1B,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEe,cAAc,CAAClB,MAAM,GAAG,CAAC,CAAC,EAAE4B,CAAC,GAAGhB,aAAa,CAACZ,MAAM,EAAE4B,CAAC,EAAE,EAAE;MAChF,IAAIhB,aAAa,CAACgB,CAAC,CAAC,KAAK/B,SAAS,CAACgC,eAAe,EAAE;QAChDC,MAAM,GAAGlB,aAAa,CAACgB,CAAC,CAAC;QACzB;MACJ;IACJ;IACA,OAAO,CAAC,CAACE,MAAM,EAAEV,cAAc,CAACP,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC;EACzD;EACA;EACA,IAAKO,cAAc,CAACA,cAAc,CAACpB,MAAM,GAAG,CAAC,CAAC,KAAK,GAAG,IACjDoB,cAAc,CAACA,cAAc,CAACpB,MAAM,GAAG,CAAC,CAAC,KAAKiB,gBAAgB,IAAIL,aAAa,CAACI,QAAQ,CAAC,KAAK,GAAI,EAAE;IACrG,OAAO,CAAC,CAACJ,aAAa,CAACC,cAAc,GAAG,CAAC,CAAC,EAAEhB,SAAS,CAACgC,eAAe,CAAC,CAAC;EAC3E;EACA;EACA,MAAME,MAAM,GAAG,CAAC,CAACnB,aAAa,CAACC,cAAc,GAAG,CAAC,CAAC,EAAEO,cAAc,CAACP,cAAc,GAAG,CAAC,CAAC,CAAC,CAAC;EACxF,OAAOkB,MAAM;AACjB,CAAC;AACD;AACA;AACA;AACA,OAAO,MAAMC,aAAa,GAAGA,CAACC,GAAG,EAAEC,IAAI,KAAK;EACxCD,GAAG,CAACC,IAAI,CAACC,OAAO,CAAC,CAAC,CAAC,CAAC,GAAGD,IAAI,CAACE,IAAI;EAChC,OAAOH,GAAG;AACd,CAAC;AACD;AACA;AACA;AACA,OAAO,MAAMI,SAAS,GAAGA,CAACC,SAAS,EAAEC,GAAG,EAAEpC,GAAG,KAAMmC,SAAS,KAAK,IAAI,IAAI,EAAGC,GAAG,IAAIA,GAAG,GAAGD,SAAS,IAAMnC,GAAG,IAAIA,GAAG,GAAGmC,SAAU,CAAE"},"metadata":{},"sourceType":"module","externalDependencies":[]}