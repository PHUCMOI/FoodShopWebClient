{"ast":null,"code":"import { Class } from '../../../common';\nimport { EncodingResult } from '../encoding-result';\nimport { DataModeInstances } from '../data-modes/data-mode-instances';\nimport { extend } from '../../utils';\nimport { toBitsString } from '../../utils';\nimport { getVersion } from '../encoding';\nconst BYTE = \"byte\";\nexport class Utf8Encoder extends Class {\n  constructor() {\n    super();\n    this.initProperties();\n    this.mode = DataModeInstances[this.encodingMode];\n  }\n  initProperties() {\n    extend(this, {\n      encodingMode: BYTE,\n      utfBOM: \"111011111011101110111111\",\n      initialModeCountStringLength: 20,\n      ranges: [128, 2048, 65536, 2097152, 67108864]\n    });\n  }\n  getEncodingResult(inputString, errorCorrectionLevel) {\n    let data = this.encode(inputString),\n      dataCodewordsCount = this.getDataCodewordsCount(data),\n      version = getVersion(dataCodewordsCount, errorCorrectionLevel),\n      dataString = this.mode.getModeCountString(data.length / 8, version) + data;\n    return new EncodingResult(dataString, version);\n  }\n  getDataCodewordsCount(data) {\n    let dataLength = data.length,\n      dataCodewordsCount = Math.ceil((this.initialModeCountStringLength + dataLength) / 8);\n    return dataCodewordsCount;\n  }\n  encode(str) {\n    let result = this.utfBOM;\n    for (let i = 0; i < str.length; i++) {\n      result += this.encodeCharacter(str.charCodeAt(i));\n    }\n    return result;\n  }\n  encodeCharacter(code) {\n    let bytesCount = this.getBytesCount(code),\n      bc = bytesCount - 1,\n      result = \"\";\n    if (bytesCount === 1) {\n      result = toBitsString(code, 8);\n    } else {\n      let significantOnes = 8 - bytesCount;\n      for (let i = 0; i < bc; i++) {\n        result = toBitsString(code >> i * 6 & 63 | 128, 8) + result;\n      }\n      result = (code >> bc * 6 | 255 >> significantOnes << significantOnes).toString(2) + result;\n    }\n    return result;\n  }\n  getBytesCount(code) {\n    let ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      if (code < ranges[i]) {\n        return i + 1;\n      }\n    }\n  }\n}","map":{"version":3,"names":["Class","EncodingResult","DataModeInstances","extend","toBitsString","getVersion","BYTE","Utf8Encoder","constructor","initProperties","mode","encodingMode","utfBOM","initialModeCountStringLength","ranges","getEncodingResult","inputString","errorCorrectionLevel","data","encode","dataCodewordsCount","getDataCodewordsCount","version","dataString","getModeCountString","length","dataLength","Math","ceil","str","result","i","encodeCharacter","charCodeAt","code","bytesCount","getBytesCount","bc","significantOnes","toString"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/qrcode/encodings/encoders/utf8-encoder.js"],"sourcesContent":["import { Class } from '../../../common';\nimport { EncodingResult } from '../encoding-result';\nimport { DataModeInstances } from '../data-modes/data-mode-instances';\nimport { extend } from '../../utils';\nimport { toBitsString } from '../../utils';\nimport { getVersion } from '../encoding';\n\nconst BYTE = \"byte\";\n\nexport class Utf8Encoder extends Class {\n    constructor() {\n        super();\n\n        this.initProperties();\n\n        this.mode = DataModeInstances[this.encodingMode];\n    }\n\n    initProperties() {\n        extend(this, {\n            encodingMode: BYTE,\n            utfBOM: \"111011111011101110111111\",\n            initialModeCountStringLength: 20,\n            ranges: [128, 2048, 65536, 2097152, 67108864]\n        });\n    }\n\n    getEncodingResult(inputString, errorCorrectionLevel) {\n        let data = this.encode(inputString),\n            dataCodewordsCount = this.getDataCodewordsCount(data),\n            version = getVersion(dataCodewordsCount, errorCorrectionLevel),\n            dataString = this.mode.getModeCountString(data.length / 8, version) + data;\n\n        return new EncodingResult(dataString, version);\n    }\n\n    getDataCodewordsCount(data) {\n        let dataLength = data.length,\n            dataCodewordsCount = Math.ceil((this.initialModeCountStringLength + dataLength) / 8);\n\n        return dataCodewordsCount;\n    }\n\n    encode(str) {\n        let result = this.utfBOM;\n\n        for (let i = 0; i < str.length; i++) {\n            result += this.encodeCharacter(str.charCodeAt(i));\n        }\n\n        return result;\n    }\n\n    encodeCharacter(code) {\n        let bytesCount = this.getBytesCount(code),\n            bc = bytesCount - 1,\n            result = \"\";\n\n        if (bytesCount === 1) {\n            result = toBitsString(code, 8);\n        } else {\n            let significantOnes = 8 - bytesCount;\n\n            for (let i = 0; i < bc; i++) {\n                result = toBitsString(code >> (i * 6) & 63 | 128, 8) + result;\n            }\n\n            result = ((code >> bc * 6) | ((255 >> significantOnes) << significantOnes)).toString(2) + result;\n        }\n\n        return result;\n    }\n\n    getBytesCount(code) {\n        let ranges = this.ranges;\n\n        for (let i = 0; i < ranges.length; i++) {\n            if (code < ranges[i]) {\n                return i + 1;\n            }\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}