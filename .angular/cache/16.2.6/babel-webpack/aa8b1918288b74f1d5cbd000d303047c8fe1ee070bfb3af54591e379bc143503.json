{"ast":null,"code":"import { addMonths, cloneDate, createDate, isEqual, getDate, lastDayOfMonth } from '@progress/kendo-date-math';\nimport { Mask } from './mask';\nimport { dateSymbolMap, padZero, unpadZero } from '../dateinput/utils';\nimport { extend, isPresent, cropTwoDigitYear, setYears, parseToInt, clamp, areDatePartsEqualTo, isNumber, isValidDate } from './utils';\nimport { Constants } from './constants';\nconst PREVIOUS_CENTURY_BASE = 1900;\nconst CURRENT_CENTURY_BASE = 2000;\nconst SHORT_PATTERN_LENGTH_REGEXP = /d|M|H|h|m|s/;\nconst MONTH_PART_WITH_WORDS_THRESHOLD = 2;\nconst MONTH_SYMBOL = \"M\";\n// JS months start from 0 (January) instead of 1 (January)\nconst JS_MONTH_OFFSET = 1;\nexport class DateObject {\n  constructor({\n    intlService,\n    formatPlaceholder,\n    format,\n    cycleTime = false,\n    twoDigitYearMax = Constants.twoDigitYearMax,\n    value = null,\n    autoCorrectParts = true\n  }) {\n    this.year = true;\n    this.month = true;\n    this.date = true;\n    this.hours = true;\n    this.minutes = true;\n    this.seconds = true;\n    this.milliseconds = true;\n    this.dayperiod = true;\n    this.leadingZero = null;\n    this.typedMonthPart = '';\n    this.knownParts = 'adHhmMsEyS';\n    this.symbols = {\n      'E': 'E',\n      'H': 'H',\n      'M': 'M',\n      'a': 'a',\n      'd': 'd',\n      'h': 'h',\n      'm': 'm',\n      's': 's',\n      'y': 'y',\n      'S': 'S'\n    };\n    this._value = getDate(new Date());\n    this.cycleTime = false;\n    this._partiallyInvalidDate = {\n      startDate: null,\n      invalidDateParts: {\n        'E': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'H': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'M': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'a': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'd': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'h': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'm': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        's': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'y': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        },\n        'S': {\n          value: null,\n          date: null,\n          startDateOffset: 0\n        }\n      }\n    };\n    this.setOptions({\n      intlService,\n      formatPlaceholder,\n      format,\n      cycleTime,\n      twoDigitYearMax,\n      value,\n      autoCorrectParts\n    });\n    if (!value) {\n      this._value = getDate(new Date());\n      const sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n      for (let i = 0; i < sampleFormat.length; i++) {\n        this.setExisting(sampleFormat[i], false);\n      }\n    } else {\n      this._value = cloneDate(value);\n    }\n  }\n  set value(value) {\n    if (value && !(value instanceof Date)) {\n      // throw new Error(\"The 'value' should be a valid JavaScript Date instance.\");\n      return;\n    }\n    this._value = value;\n    this.resetInvalidDate();\n  }\n  get value() {\n    return this._value;\n  }\n  get localeId() {\n    let localeId = Constants.defaultLocaleId;\n    const cldrKeys = Object.keys(this.intl.cldr);\n    for (let i = 0; i < cldrKeys.length; i++) {\n      const key = cldrKeys[i];\n      const value = this.intl.cldr[key];\n      if (value.name && value.calendar && value.numbers && value.name !== Constants.defaultLocaleId) {\n        localeId = value.name;\n        break;\n      }\n    }\n    return localeId;\n  }\n  /**\n   * @hidden\n   */\n  setOptions(options) {\n    this.intl = options.intlService;\n    this.formatPlaceholder = options.formatPlaceholder || 'wide';\n    this.format = options.format;\n    this.cycleTime = options.cycleTime;\n    this.monthNames = this.allFormattedMonths(this.localeId);\n    this.dayPeriods = this.allDayPeriods(this.localeId);\n    this.twoDigitYearMax = options.twoDigitYearMax;\n    this.autoCorrectParts = options.autoCorrectParts;\n  }\n  setValue(value) {\n    if (!value) {\n      this._value = getDate(new Date());\n      this.modifyExisting(false);\n    } else if (!isEqual(value, this._value)) {\n      this._value = cloneDate(value);\n      this.modifyExisting(true);\n    }\n    this.resetInvalidDate();\n  }\n  /**\n   * @hidden\n   */\n  hasValue() {\n    const pred = (a, p) => a || p.type !== 'literal' && p.type !== 'dayperiod' && this.getExisting(p.pattern[0]);\n    return this.intl.splitDateFormat(this.format, this.localeId).reduce(pred, false);\n  }\n  /**\n   * @hidden\n   */\n  getValue() {\n    for (let i = 0; i < this.knownParts.length; i++) {\n      if (!this.getExisting(this.knownParts[i])) {\n        return null;\n      }\n    }\n    return cloneDate(this.value);\n  }\n  /**\n   * @hidden\n   */\n  getFormattedDate(format) {\n    return this.intl.formatDate(this.getValue(), format, this.localeId);\n  }\n  /**\n   * @hidden\n   */\n  getTextAndFormat(customFormat = \"\") {\n    const format = customFormat || this.format;\n    let text = this.intl.formatDate(this.value, format, this.localeId);\n    const mask = this.dateFormatString(this.value, format);\n    if (!this.autoCorrectParts && this._partiallyInvalidDate.startDate) {\n      let partiallyInvalidText = \"\";\n      const formattedDate = this.intl.formatDate(this.value, format, this.localeId);\n      const formattedDates = this.getFormattedInvalidDates(format);\n      for (let i = 0; i < formattedDate.length; i++) {\n        const symbol = mask.symbols[i];\n        if (mask.partMap[i].type === \"literal\") {\n          partiallyInvalidText += text[i];\n        } else if (this.getInvalidDatePartValue(symbol)) {\n          const partsForSegment = this.getPartsForSegment(mask, i);\n          if (symbol === \"M\") {\n            const datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();\n            if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {\n              partiallyInvalidText += formattedDates[symbol][i];\n            } else {\n              if (this.getInvalidDatePartValue(symbol)) {\n                const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n                partiallyInvalidText += formattedDatePart;\n                // add -1 as the first character in the segment is at index i\n                i += partsForSegment.length - 1;\n              } else {\n                partiallyInvalidText += formattedDates[symbol][i];\n              }\n            }\n          } else {\n            if (this.getInvalidDatePartValue(symbol)) {\n              const datePartText = this.getInvalidDatePartValue(symbol).toString();\n              const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n              partiallyInvalidText += formattedDatePart;\n              // add -1 as the first character in the segment is at index i\n              i += partsForSegment.length - 1;\n            } else {\n              partiallyInvalidText += formattedDates[symbol][i];\n            }\n          }\n        } else {\n          partiallyInvalidText += text[i];\n        }\n      }\n      text = partiallyInvalidText;\n    }\n    const result = this.merge(text, mask);\n    return result;\n  }\n  /**\n   * @hidden\n   */\n  getFormattedInvalidDates(customFormat = \"\") {\n    const format = customFormat || this.format;\n    let formattedDatesForSymbol = {\n      'E': '',\n      'H': '',\n      'M': '',\n      'a': '',\n      'd': '',\n      'h': '',\n      'm': '',\n      's': '',\n      'y': '',\n      'S': ''\n    };\n    Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n      const date = this.getInvalidDatePart(key).date;\n      if (date) {\n        const formattedInvalidDate = this.intl.formatDate(date, format, this.localeId);\n        formattedDatesForSymbol[key] = formattedInvalidDate;\n      }\n    });\n    return formattedDatesForSymbol;\n  }\n  modifyExisting(value) {\n    const sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n    for (let i = 0; i < sampleFormat.length; i++) {\n      this.setExisting(sampleFormat[i], value);\n    }\n  }\n  /**\n   * @hidden\n   */\n  getExisting(symbol) {\n    switch (symbol) {\n      case 'y':\n        return this.year;\n      case 'M':\n      case 'L':\n        return this.month;\n      case 'd':\n        return this.date;\n      case 'E':\n        return this.date && this.month && this.year;\n      case 'h':\n      case 'H':\n        return this.hours;\n      case 't':\n      case 'a':\n        return this.dayperiod;\n      case 'm':\n        return this.minutes;\n      case 's':\n        return this.seconds;\n      case \"S\":\n        return this.milliseconds;\n      default:\n        return true;\n    }\n  }\n  setExisting(symbol, value) {\n    switch (symbol) {\n      case 'y':\n        // allow 2/29 dates\n        this.year = value;\n        if (value === false) {\n          this._value.setFullYear(2000);\n        }\n        break;\n      case 'M':\n        // make sure you can type 31 in the day part\n        this.month = value;\n        if (value === false) {\n          if (this.autoCorrectParts) {\n            this._value.setMonth(0);\n          }\n        }\n        break;\n      case 'd':\n        this.date = value;\n        break;\n      case 'h':\n      case 'H':\n        this.hours = value;\n        break;\n      case 't':\n      case 'a':\n        this.dayperiod = value;\n        break;\n      case 'm':\n        this.minutes = value;\n        break;\n      case 's':\n        this.seconds = value;\n        break;\n      case \"S\":\n        this.milliseconds = value;\n        break;\n      default:\n        break;\n    }\n    if (this.getValue()) {\n      this.resetInvalidDate();\n    }\n  }\n  modifyPart(symbol, offset) {\n    if (!isPresent(symbol) || !isPresent(offset) || offset === 0) {\n      return;\n    }\n    let newValue = cloneDate(this.value);\n    let timeModified = false;\n    let invalidDateFound;\n    const isMonth = symbol === \"M\";\n    const isDay = symbol === \"d\" || symbol === \"E\";\n    const symbolExists = this.getExisting(symbol);\n    if (!this.autoCorrectParts && (isDay || isMonth)) {\n      const invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};\n      const invalidDatePartValue = this.getInvalidDatePartValue(symbol);\n      let year = invalidDateParts.y.value || newValue.getFullYear();\n      let month = invalidDateParts.M.value || newValue.getMonth();\n      let day = invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();\n      let hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();\n      let minutes = invalidDateParts.m.value || newValue.getMinutes();\n      let seconds = invalidDateParts.s.value || newValue.getSeconds();\n      let milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();\n      switch (symbol) {\n        case 'y':\n          year += offset;\n          break;\n        case 'M':\n          month += offset;\n          break;\n        case 'd':\n        case 'E':\n          day += offset;\n          break;\n        // case 'h':\n        // case 'H': hour += offset; break;\n        // case 'm': minutes += offset; break;\n        // case 's': seconds += offset; break;\n        // case 'S': milliseconds += offset; break;\n        default:\n          break;\n      }\n      if (symbol === \"M\") {\n        if (month < 0 || month > 11) {\n          if (symbolExists) {\n            this.setExisting(symbol, false);\n            this.resetInvalidDateSymbol(symbol);\n            return;\n          }\n        }\n        if (!symbolExists) {\n          if (month < 0) {\n            month = clamp(11 + (month % 11 + 1), 0, 11);\n          } else {\n            const monthValue = isPresent(invalidDatePartValue) ? month : (offset - JS_MONTH_OFFSET) % 12;\n            month = clamp(monthValue, 0, 11);\n          }\n          month = clamp(month, 0, 11);\n        }\n        month = clamp(month, 0, 11);\n      } else if (symbol === \"d\") {\n        if (symbolExists) {\n          if (day <= 0 || day > 31) {\n            this.setExisting(symbol, false);\n            this.resetInvalidDateSymbol(symbol);\n            return;\n          }\n        } else if (!symbolExists) {\n          if (isPresent(invalidDatePartValue)) {\n            if (day <= 0 || day > 31) {\n              this.setExisting(symbol, false);\n              this.resetInvalidDateSymbol(symbol);\n              return;\n            }\n          }\n          if (offset < 0) {\n            const dayValue = isPresent(invalidDatePartValue) ? day : 1 + (31 - Math.abs(offset % 31));\n            day = clamp(dayValue, 1, 31);\n          } else {\n            const dayValue = isPresent(invalidDatePartValue) ? day : offset % 31;\n            day = clamp(dayValue, 1, 31);\n          }\n          day = clamp(day, 1, 31);\n        }\n      }\n      const dateCandidate = createDate(year, month, day, hour, minutes, seconds, milliseconds);\n      const newValueCandidate = isMonth || isDay ? this.modifyDateSymbolWithValue(newValue, symbol, isMonth ? month : day) : null;\n      const dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);\n      if (this.getValue() && areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds)) {\n        newValue = cloneDate(dateCandidate);\n        this.markDatePartsAsExisting();\n      } else if (isMonth && newValueCandidate) {\n        if (newValueCandidate.getMonth() === month) {\n          if (this.getExisting(\"d\")) {\n            if (dateCandidateExists) {\n              newValue = cloneDate(dateCandidate);\n              this.resetInvalidDateSymbol(symbol);\n            } else {\n              invalidDateFound = true;\n              this.setInvalidDatePart(symbol, {\n                value: month,\n                date: cloneDate(newValueCandidate),\n                startDateOffset: offset,\n                startDate: cloneDate(this.value)\n              });\n              this.setExisting(symbol, false);\n            }\n          } else if (dateCandidateExists) {\n            this.resetInvalidDateSymbol(symbol);\n            newValue = cloneDate(dateCandidate);\n            if (this.getExisting(\"M\") && this.getExisting(\"y\")) {\n              // changing from 28/Feb to 29/Feb to 29/March\n              this.setExisting(\"d\", true);\n              this.resetInvalidDateSymbol(\"d\");\n            }\n          } else {\n            this.resetInvalidDateSymbol(symbol);\n            newValue = cloneDate(newValueCandidate);\n          }\n        } else {\n          invalidDateFound = true;\n          this.setInvalidDatePart(symbol, {\n            value: month,\n            date: cloneDate(newValueCandidate),\n            startDateOffset: offset,\n            startDate: cloneDate(this.value)\n          });\n          this.setExisting(symbol, false);\n        }\n      } else if (isDay && newValueCandidate) {\n        if (newValueCandidate.getDate() === day) {\n          if (this.getExisting(\"M\")) {\n            if (dateCandidateExists) {\n              newValue = cloneDate(dateCandidate);\n              this.resetInvalidDateSymbol(symbol);\n            } else {\n              invalidDateFound = true;\n              this.setInvalidDatePart(symbol, {\n                value: day,\n                date: cloneDate(newValueCandidate),\n                startDateOffset: offset,\n                startDate: cloneDate(this.value)\n              });\n              this.setExisting(symbol, false);\n            }\n          } else if (dateCandidateExists) {\n            newValue = cloneDate(dateCandidate);\n            this.resetInvalidDateSymbol(symbol);\n            if (this.getExisting(\"d\") && this.getExisting(\"y\")) {\n              // changing from 31/Jan to 31/Feb to 28/Feb\n              this.setExisting(\"M\", true);\n              this.resetInvalidDateSymbol(\"M\");\n            }\n          } else {\n            this.resetInvalidDateSymbol(symbol);\n            newValue = cloneDate(newValueCandidate);\n          }\n        } else {\n          invalidDateFound = true;\n          this.setInvalidDatePart(symbol, {\n            value: day,\n            date: cloneDate(this.value),\n            startDateOffset: offset,\n            startDate: cloneDate(this.value)\n          });\n          this.setExisting(symbol, false);\n        }\n      }\n    } else {\n      switch (symbol) {\n        case 'y':\n          newValue.setFullYear(newValue.getFullYear() + offset);\n          break;\n        case 'M':\n          newValue = addMonths(this.value, offset);\n          break;\n        case 'd':\n        case 'E':\n          newValue.setDate(newValue.getDate() + offset);\n          break;\n        case 'h':\n        case 'H':\n          newValue.setHours(newValue.getHours() + offset);\n          timeModified = true;\n          break;\n        case 'm':\n          newValue.setMinutes(newValue.getMinutes() + offset);\n          timeModified = true;\n          break;\n        case 's':\n          newValue.setSeconds(newValue.getSeconds() + offset);\n          timeModified = true;\n          break;\n        case \"S\":\n          newValue.setMilliseconds(newValue.getMilliseconds() + offset);\n          break;\n        case 'a':\n          newValue.setHours(newValue.getHours() + 12 * offset);\n          timeModified = true;\n          break;\n        default:\n          break;\n      }\n    }\n    if (this.shouldNormalizeCentury()) {\n      newValue = this.normalizeCentury(newValue);\n    }\n    if (timeModified && !this.cycleTime && newValue.getDate() !== this._value.getDate()) {\n      // todo: blazor has this fix, but this fails a unit test\n      // newValue.setDate(this._value.getDate());\n      // newValue.setMonth(this._value.getMonth());\n      // newValue.setFullYear(this._value.getFullYear());\n    }\n    if (!invalidDateFound) {\n      this.setExisting(symbol, true);\n      this._value = newValue;\n      if (this.getValue()) {\n        this.resetInvalidDate();\n      }\n    }\n  }\n  /**\n   * @hidden\n   */\n  parsePart({\n    symbol,\n    currentChar,\n    resetSegmentValue,\n    cycleSegmentValue,\n    rawTextValue: rawInputValue,\n    isDeleting,\n    originalFormat\n  }) {\n    const isInCaretMode = !cycleSegmentValue;\n    const dateParts = this.dateFormatString(this.value, this.format);\n    const datePartsLiterals = dateParts.partMap.filter(x => x.type === \"literal\").map((x, index) => {\n      return {\n        datePartIndex: index,\n        type: x.type,\n        pattern: x.pattern,\n        literal: \"\"\n      };\n    });\n    const flatDateParts = dateParts.partMap.map(x => {\n      return {\n        type: x.type,\n        pattern: x.pattern,\n        text: \"\"\n      };\n    });\n    for (let i = 0; i < datePartsLiterals.length; i++) {\n      const datePart = datePartsLiterals[i];\n      for (let j = 0; j < datePart.pattern.length; j++) {\n        if (datePartsLiterals[i + j]) {\n          datePartsLiterals[i + j].literal = datePart.pattern[j];\n        }\n      }\n      i += datePart.pattern.length - 1;\n    }\n    for (let i = 0; i < flatDateParts.length; i++) {\n      const datePart = flatDateParts[i];\n      for (let j = 0; j < datePart.pattern.length; j++) {\n        if (flatDateParts[i + j]) {\n          flatDateParts[i + j].text = datePart.pattern[j];\n        }\n      }\n      i += datePart.pattern.length - 1;\n    }\n    let shouldResetPart = isInCaretMode && symbol === \"M\" && dateParts.partMap.filter(x => x.type === \"month\").some(x => x.pattern.length > MONTH_PART_WITH_WORDS_THRESHOLD);\n    let parseResult = {\n      value: null,\n      switchToNext: false,\n      resetPart: shouldResetPart,\n      hasInvalidDatePart: false\n    };\n    if (!currentChar) {\n      if (isInCaretMode) {\n        for (let i = 0; i < datePartsLiterals.length; i++) {\n          const literal = datePartsLiterals[i].literal;\n          const rawValueStartsWithLiteral = rawInputValue.startsWith(literal);\n          const rawValueEndsWithLiteral = rawInputValue.endsWith(literal);\n          const rawValueHasConsecutiveLiterals = rawInputValue.indexOf(literal + literal) >= 0;\n          if (rawValueStartsWithLiteral || rawValueEndsWithLiteral || rawValueHasConsecutiveLiterals) {\n            this.resetLeadingZero();\n            this.setExisting(symbol, false);\n            this.resetInvalidDateSymbol(symbol);\n            return extend(parseResult, {\n              value: null,\n              switchToNext: false\n            });\n          }\n        }\n      } else {\n        this.resetLeadingZero();\n        this.setExisting(symbol, false);\n        this.resetInvalidDateSymbol(symbol);\n        return extend(parseResult, {\n          value: null,\n          switchToNext: false\n        });\n      }\n    }\n    const baseDate = this.intl.formatDate(this.value, this.format, this.localeId);\n    const baseFormat = dateParts.symbols;\n    let replaced = false;\n    let prefix = '';\n    let current = '';\n    let datePartText = '';\n    let basePrefix = '';\n    let baseSuffix = '';\n    let suffix = '';\n    let convertedBaseFormat = \"\";\n    for (let i = 0; i < flatDateParts.length; i++) {\n      convertedBaseFormat += flatDateParts[i].text;\n    }\n    const hasFixedFormat = this.format === baseFormat || this.format === convertedBaseFormat || this.format === originalFormat || this.format.length === originalFormat.length;\n    const datePartStartIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).indexOf(symbol);\n    const datePartEndIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).lastIndexOf(symbol);\n    const segmentLength = datePartEndIndex - datePartStartIndex + 1;\n    let formatToTextLengthDiff = originalFormat.length - rawInputValue.length;\n    if (isInCaretMode || !isInCaretMode && !this.autoCorrectParts) {\n      for (let i = 0; i < baseDate.length; i++) {\n        if (baseFormat[i] === symbol) {\n          const existing = this.getExisting(symbol);\n          current += existing ? baseDate[i] : '0';\n          if (formatToTextLengthDiff > 0) {\n            if (datePartText.length + formatToTextLengthDiff < segmentLength) {\n              datePartText += rawInputValue[i] || \"\";\n            }\n          } else {\n            datePartText += rawInputValue[i] || \"\";\n          }\n          replaced = true;\n        } else if (!replaced) {\n          prefix += baseDate[i];\n          basePrefix += baseDate[i];\n        } else {\n          suffix += baseDate[i];\n          baseSuffix += baseDate[i];\n        }\n      }\n      if (hasFixedFormat) {\n        if (convertedBaseFormat.length < rawInputValue.length) {\n          datePartText += currentChar;\n        } else if (!isDeleting && originalFormat.length > rawInputValue.length) {\n          // let the parsing to determine if the incomplete value is valid\n        }\n        if (datePartText.length > segmentLength) {\n          return extend(parseResult, {\n            value: null,\n            switchToNext: false\n          });\n        }\n      }\n      if (!hasFixedFormat || hasFixedFormat && !this.autoCorrectParts) {\n        current = \"\";\n        datePartText = \"\";\n        prefix = \"\";\n        suffix = \"\";\n        replaced = false;\n        for (let i = 0; i < originalFormat.length; i++) {\n          if (originalFormat[i] === symbol) {\n            const existing = this.getExisting(symbol);\n            current += existing ? baseDate[i] || \"\" : '0';\n            if (formatToTextLengthDiff > 0) {\n              if (datePartText.length + formatToTextLengthDiff < segmentLength) {\n                datePartText += rawInputValue[i] || \"\";\n              }\n            } else {\n              datePartText += rawInputValue[i] || \"\";\n            }\n            replaced = true;\n          } else if (!replaced) {\n            prefix += rawInputValue[i] || \"\";\n          } else {\n            suffix += rawInputValue[i - formatToTextLengthDiff] || \"\";\n          }\n        }\n        if (originalFormat.length < rawInputValue.length) {\n          datePartText += currentChar;\n        }\n      }\n    }\n    if (!isInCaretMode) {\n      if (this.autoCorrectParts) {\n        current = \"\";\n        datePartText = \"\";\n        prefix = \"\";\n        suffix = \"\";\n        replaced = false;\n        for (let i = 0; i < baseDate.length; i++) {\n          if (baseFormat[i] === symbol) {\n            const existing = this.getExisting(symbol);\n            current += existing ? baseDate[i] : '0';\n            replaced = true;\n          } else if (!replaced) {\n            prefix += baseDate[i];\n          } else {\n            suffix += baseDate[i];\n          }\n        }\n      } else {\n        current = resetSegmentValue ? datePartText : current;\n      }\n    }\n    let parsedDate = null;\n    let month = this.matchMonth(currentChar);\n    const dayPeriod = this.matchDayPeriod(currentChar, symbol);\n    const isZeroCurrentChar = currentChar === '0';\n    const leadingZero = this.leadingZero || {};\n    if (isZeroCurrentChar) {\n      if (datePartText === \"0\") {\n        datePartText = current;\n      }\n      let valueNumber = parseToInt(resetSegmentValue ? currentChar : (isInCaretMode ? datePartText : current) + currentChar);\n      if (valueNumber === 0 && !this.isAbbrMonth(dateParts.partMap, symbol)) {\n        this.incrementLeadingZero(symbol);\n      }\n    } else {\n      this.resetLeadingZero();\n    }\n    const partPattern = this.partPattern(dateParts.partMap, symbol);\n    const patternValue = partPattern ? partPattern.pattern : null;\n    const patternLength = this.patternLength(patternValue) || patternValue.length;\n    if (isInCaretMode) {\n      if (isDeleting && !datePartText) {\n        this.setExisting(symbol, false);\n        return extend(parseResult, {\n          value: null,\n          switchToNext: false\n        });\n      }\n    }\n    const currentMaxLength = current.length - 3;\n    let tryParse = true;\n    let middle = isInCaretMode ? datePartText : current;\n    for (let i = Math.max(0, currentMaxLength); i <= current.length; i++) {\n      if (!tryParse) {\n        break;\n      }\n      middle = resetSegmentValue ? currentChar : isInCaretMode ? datePartText : current.substring(i) + currentChar;\n      if (isInCaretMode || !this.autoCorrectParts) {\n        tryParse = false;\n        middle = unpadZero(middle);\n        // middle = padZero(segmentLength - middle.length) + middle;\n        middle = padZero(patternLength - middle.length) + middle;\n      }\n      let middleNumber = parseInt(middle, 10);\n      const candidateDateString = prefix + middle + suffix;\n      parsedDate = this.intl.parseDate(candidateDateString, this.format, this.localeId);\n      let autoCorrectedPrefixAndSuffix = false;\n      if (isInCaretMode && !isValidDate(parsedDate)) {\n        // if part of the date is not available, e.g. \"d\"\n        // but an expanded format like \"F\" is used\n        // the element value can be \"EEEE, February 1, 2022 3:04:05 AM\"\n        // which is not parsable by intl\n        // use the base prefix and suffix, e.g. convert the candidate date string\n        // to \"Thursday, February 1, 2022 3:04:05 AM\"\n        // as \"EEEE, February...\" is not parsable\n        if (this.autoCorrectParts) {\n          parsedDate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);\n          autoCorrectedPrefixAndSuffix = true;\n        }\n      }\n      const isCurrentCharParsable = !isNaN(parseInt(currentChar, 10)) || isInCaretMode && isDeleting && currentChar === \"\";\n      if (!parsedDate && !isNaN(middleNumber) && isCurrentCharParsable && this.autoCorrectParts) {\n        if (symbol === MONTH_SYMBOL && !month) {\n          // JS months start from 0 (January) instead of 1 (January)\n          const monthNumber = middleNumber - JS_MONTH_OFFSET;\n          if (monthNumber > -1 && monthNumber < 12) {\n            parsedDate = cloneDate(this.value);\n            parsedDate.setMonth(monthNumber);\n            if (parsedDate.getMonth() !== monthNumber) {\n              parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n            }\n          }\n        }\n        if (symbol === 'y') {\n          parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);\n          if ((isInCaretMode && isValidDate(parsedDate) || !isInCaretMode && parsedDate) && this.date && parsedDate.getDate() !== this.value.getDate()) {\n            parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n          }\n        }\n      }\n      if (isInCaretMode && isValidDate(parsedDate) || !isInCaretMode && parsedDate) {\n        // move to next segment if the part will overflow with next char\n        // when start from empty date (01, then 010), padded zeros should be trimmed\n        const peekedValue = this.peek(middle, patternValue);\n        const peekedDateString = autoCorrectedPrefixAndSuffix ? `${basePrefix}${peekedValue}${baseSuffix}` : `${prefix}${peekedValue}${suffix}`;\n        const peekedDate = this.intl.parseDate(peekedDateString, this.format, this.localeId);\n        const leadingZeroOffset = (this.leadingZero || {})[symbol] || 0;\n        const patternSatisfied = leadingZeroOffset + unpadZero(middle).length >= patternLength;\n        let switchToNext = peekedDate === null || (leadingZero[symbol] ? patternValue.length <= middle.length : patternSatisfied);\n        if (this.shouldNormalizeCentury()) {\n          parsedDate = this.normalizeCentury(parsedDate);\n        }\n        this._value = parsedDate;\n        this.setExisting(symbol, true);\n        this.resetInvalidDateSymbol(symbol);\n        if (!this.autoCorrectParts) {\n          if (symbol === \"M\") {\n            if (this.getExisting(\"M\") && this.getExisting(\"y\")) {\n              // changing from 28/Feb to 29/Feb to 29/March\n              this.setExisting(\"d\", true);\n              this.resetInvalidDateSymbol(\"d\");\n            }\n          } else if (symbol === \"d\") {\n            if (this.getExisting(\"d\") && this.getExisting(\"y\")) {\n              // changing from 31/Jan to 31/Feb to 28/Feb\n              this.setExisting(\"M\", true);\n              this.resetInvalidDateSymbol(\"M\");\n            }\n          }\n          if (!this.hasInvalidDatePart()) {\n            this.markDatePartsAsExisting();\n          }\n        }\n        return extend(parseResult, {\n          value: this.value,\n          switchToNext: switchToNext\n        });\n      }\n    }\n    if (month) {\n      parsedDate = this.intl.parseDate(prefix + month + suffix, this.format, this.localeId);\n      if (parsedDate) {\n        this._value = parsedDate;\n        this.setExisting(symbol, true);\n        return extend(parseResult, {\n          value: this.value,\n          switchToNext: false\n        });\n      }\n    }\n    if (dayPeriod) {\n      parsedDate = this.intl.parseDate(prefix + dayPeriod + suffix, this.format);\n      if (parsedDate) {\n        this._value = parsedDate;\n        return extend(parseResult, {\n          value: this.value,\n          switchToNext: true\n        });\n      }\n    }\n    if (isZeroCurrentChar) {\n      this.setExisting(symbol, false);\n    }\n    if (!this.autoCorrectParts) {\n      let datePartValue;\n      const textToParse = isInCaretMode ? datePartText : middle;\n      const parsedValue = parseToInt(textToParse);\n      if (isNumber(parsedValue)) {\n        if (symbol === \"d\" && (parsedValue <= 0 || parsedValue > 31) || symbol === \"M\" && (parsedValue < 0 || parsedValue > 11)) {\n          return extend(parseResult, {\n            value: null,\n            switchToNext: false\n          });\n        }\n        datePartValue = symbol === \"M\" ? parsedValue - JS_MONTH_OFFSET : parsedValue;\n        const isMonth = symbol === \"M\";\n        const isDay = symbol === \"d\";\n        let newValue = cloneDate(this._value);\n        const invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};\n        let year = invalidDateParts.y.value || newValue.getFullYear();\n        /* tslint:disable:no-shadowed-variable */\n        let month = isMonth ? datePartValue : invalidDateParts.M.value || newValue.getMonth();\n        /* tslint:enable:no-shadowed-variable */\n        let day = isDay ? datePartValue : invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();\n        let hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();\n        let minutes = invalidDateParts.m.value || newValue.getMinutes();\n        let seconds = invalidDateParts.s.value || newValue.getSeconds();\n        let milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();\n        const dateCandidate = createDate(year, month, day, hour, minutes, seconds, milliseconds);\n        const dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);\n        const newValueCandidate = isMonth || isDay ? this.modifyDateSymbolWithValue(newValue, symbol, isMonth ? month : day) : null;\n        let invalidDateFound = false;\n        if (isMonth && newValueCandidate) {\n          if (newValueCandidate.getMonth() === month) {\n            if (this.getExisting(\"d\")) {\n              if (dateCandidateExists) {\n                newValue = cloneDate(dateCandidate);\n                this.resetInvalidDateSymbol(symbol);\n              } else {\n                invalidDateFound = true;\n                this.setInvalidDatePart(symbol, {\n                  value: month,\n                  date: cloneDate(newValueCandidate),\n                  startDate: cloneDate(this.value)\n                });\n                this.setExisting(symbol, false);\n              }\n            } else if (dateCandidateExists) {\n              this.resetInvalidDateSymbol(symbol);\n              newValue = cloneDate(dateCandidate);\n              if (this.getExisting(\"M\") && this.getExisting(\"y\")) {\n                // changing from 28/Feb to 29/Feb to 29/March\n                this.setExisting(\"d\", true);\n                this.resetInvalidDateSymbol(\"d\");\n              }\n            } else {\n              this.resetInvalidDateSymbol(symbol);\n              newValue = cloneDate(newValueCandidate);\n            }\n          } else {\n            invalidDateFound = true;\n            this.setInvalidDatePart(symbol, {\n              value: month,\n              date: cloneDate(newValueCandidate),\n              startDate: cloneDate(this.value)\n            });\n            this.setExisting(symbol, false);\n          }\n        } else if (isDay && newValueCandidate) {\n          if (newValueCandidate.getDate() === day) {\n            if (this.getExisting(\"M\")) {\n              if (dateCandidateExists) {\n                newValue = cloneDate(dateCandidate);\n                this.resetInvalidDateSymbol(symbol);\n              } else {\n                invalidDateFound = true;\n                this.setInvalidDatePart(symbol, {\n                  value: day,\n                  date: cloneDate(newValueCandidate),\n                  startDate: cloneDate(this.value)\n                });\n                this.setExisting(symbol, false);\n              }\n            } else if (dateCandidateExists) {\n              newValue = cloneDate(dateCandidate);\n              this.resetInvalidDateSymbol(symbol);\n              if (this.getExisting(\"d\") && this.getExisting(\"y\")) {\n                // changing from 31/Jan to 31/Feb to 28/Feb\n                this.setExisting(\"M\", true);\n                this.resetInvalidDateSymbol(\"M\");\n              }\n            } else {\n              this.resetInvalidDateSymbol(symbol);\n              newValue = cloneDate(newValueCandidate);\n            }\n          } else {\n            invalidDateFound = true;\n            this.setInvalidDatePart(symbol, {\n              value: day,\n              date: cloneDate(this.value),\n              startDate: cloneDate(this.value)\n            });\n            this.setExisting(symbol, false);\n          }\n        }\n        if (!invalidDateFound) {\n          this.setExisting(symbol, true);\n          if (isInCaretMode && !isValidDate(parsedDate)) {\n            const valueCandidate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);\n            if (isValidDate(valueCandidate)) {\n              this._value = valueCandidate;\n            }\n          } else {\n            this._value = newValue;\n          }\n          if (this.getValue()) {\n            this.resetInvalidDate();\n          }\n        }\n        let switchToNext = false;\n        if (symbol === \"M\") {\n          if (parsedValue >= 2 || textToParse.length >= 2) {\n            switchToNext = true;\n          } else {\n            switchToNext = false;\n          }\n        } else {\n          switchToNext = hasFixedFormat ? textToParse.length === segmentLength : textToParse.length > segmentLength;\n        }\n        return extend(parseResult, {\n          value: null,\n          switchToNext: switchToNext,\n          hasInvalidDatePart: invalidDateFound\n        });\n      }\n    }\n    return extend(parseResult, {\n      value: null,\n      switchToNext: false\n    });\n  }\n  /**\n   * @hidden\n   */\n  symbolMap(symbol) {\n    return this.intl.splitDateFormat(this.format, this.localeId).reduce(dateSymbolMap, {})[symbol];\n  }\n  /**\n   * @hidden\n   */\n  resetLeadingZero() {\n    const hasLeadingZero = this.leadingZero !== null;\n    this.setLeadingZero(null);\n    return hasLeadingZero;\n  }\n  setLeadingZero(leadingZero) {\n    this.leadingZero = leadingZero;\n  }\n  /**\n   * @hidden\n   */\n  getLeadingZero() {\n    return this.leadingZero || {};\n  }\n  /**\n   * @hidden\n   */\n  normalizeCentury(date) {\n    if (!isPresent(date)) {\n      return date;\n    }\n    const twoDigitYear = cropTwoDigitYear(date);\n    const centuryBase = this.getNormalizedCenturyBase(twoDigitYear);\n    const normalizedDate = setYears(date, centuryBase + twoDigitYear);\n    return normalizedDate;\n  }\n  incrementLeadingZero(symbol) {\n    const leadingZero = this.leadingZero || {};\n    leadingZero[symbol] = (leadingZero[symbol] || 0) + 1;\n    this.leadingZero = leadingZero;\n  }\n  /**\n   * @hidden\n   */\n  isAbbrMonth(parts, symbol) {\n    const pattern = this.partPattern(parts, symbol);\n    return pattern.type === 'month' && pattern.names;\n  }\n  /**\n   * @hidden\n   */\n  partPattern(parts, symbol) {\n    return parts.filter(part => part.pattern.indexOf(symbol) !== -1)[0];\n  }\n  /**\n   * @hidden\n   */\n  peek(value, pattern) {\n    const peekValue = value.replace(/^0*/, '') + '0';\n    return padZero(pattern.length - peekValue.length) + peekValue;\n  }\n  /**\n   * @hidden\n   */\n  matchMonth(typedChar) {\n    this.typedMonthPart += typedChar.toLowerCase();\n    if (this.monthNames.length === 0) {\n      return '';\n    }\n    while (this.typedMonthPart.length > 0) {\n      for (let i = 0; i < this.monthNames.length; i++) {\n        if (this.monthNames[i].toLowerCase().indexOf(this.typedMonthPart) === 0) {\n          return this.monthNames[i];\n        }\n      }\n      const monthAsNum = parseInt(this.typedMonthPart, 10);\n      /* ensure they exact match */\n      if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString() === this.typedMonthPart) {\n        return this.monthNames[monthAsNum - 1];\n      }\n      this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);\n    }\n    return '';\n  }\n  /**\n   * @hidden\n   */\n  matchDayPeriod(typedChar, symbol) {\n    const lowerChart = typedChar.toLowerCase();\n    if (symbol === 'a' && this.dayPeriods) {\n      if (this.dayPeriods.am.toLowerCase().startsWith(lowerChart)) {\n        return this.dayPeriods.am;\n      } else if (this.dayPeriods.pm.toLowerCase().startsWith(lowerChart)) {\n        return this.dayPeriods.pm;\n      }\n    }\n    return '';\n  }\n  /**\n   * @hidden\n   */\n  allFormattedMonths(locale = \"en\") {\n    const dateFormatParts = this.intl.splitDateFormat(this.format, this.localeId);\n    for (let i = 0; i < dateFormatParts.length; i++) {\n      if (dateFormatParts[i].type === 'month' && dateFormatParts[i].names) {\n        return this.intl.dateFormatNames(locale, dateFormatParts[i].names);\n      }\n    }\n    return [];\n  }\n  /**\n   * @hidden\n   */\n  allDayPeriods(locale = \"en\") {\n    const dateFormatParts = this.intl.splitDateFormat(this.format);\n    for (let i = 0; i < dateFormatParts.length; i++) {\n      if (dateFormatParts[i].type === \"dayperiod\" && dateFormatParts[i].names) {\n        return this.intl.dateFormatNames(locale, dateFormatParts[i].names);\n      }\n    }\n    return null;\n  }\n  /**\n   * @hidden\n   */\n  patternLength(pattern) {\n    if (pattern[0] === 'y') {\n      return 4;\n    }\n    if (SHORT_PATTERN_LENGTH_REGEXP.test(pattern)) {\n      return 2;\n    }\n    return 0;\n  }\n  /**\n   * @hidden\n   */\n  dateFormatString(date, format) {\n    const dateFormatParts = this.intl.splitDateFormat(format, this.localeId);\n    const parts = [];\n    const partMap = [];\n    for (let i = 0; i < dateFormatParts.length; i++) {\n      let partLength = this.intl.formatDate(date, {\n        pattern: dateFormatParts[i].pattern\n      }, this.localeId).length;\n      while (partLength > 0) {\n        parts.push(this.symbols[dateFormatParts[i].pattern[0]] || Constants.formatSeparator);\n        partMap.push(dateFormatParts[i]);\n        partLength--;\n      }\n    }\n    const returnValue = new Mask();\n    returnValue.symbols = parts.join('');\n    returnValue.partMap = partMap;\n    return returnValue;\n  }\n  /**\n   * @hidden\n   */\n  merge(text, mask) {\n    // Important: right to left.\n    let resultText = '';\n    let resultFormat = '';\n    let format = mask.symbols;\n    let processTextSymbolsEnded = false;\n    let ignoreFormatSymbolsCount = 0;\n    const formattedDates = this.getFormattedInvalidDates(format);\n    for (let formatSymbolIndex = format.length - 1; formatSymbolIndex >= 0; formatSymbolIndex--) {\n      const partsForSegment = this.getPartsForSegment(mask, formatSymbolIndex);\n      if (this.knownParts.indexOf(format[formatSymbolIndex]) === -1 || this.getExisting(format[formatSymbolIndex])) {\n        if (this.autoCorrectParts) {\n          resultText = text[formatSymbolIndex] + resultText;\n        } else {\n          if (text.length !== format.length) {\n            if (processTextSymbolsEnded) {\n              resultText = text[formatSymbolIndex] + resultText;\n            } else if (ignoreFormatSymbolsCount > 0) {\n              resultText = text[formatSymbolIndex] + resultText;\n              ignoreFormatSymbolsCount--;\n              if (ignoreFormatSymbolsCount <= 0) {\n                processTextSymbolsEnded = true;\n              }\n            } else {\n              resultText = (text[formatSymbolIndex + text.length - format.length] || \"\") + resultText;\n            }\n          } else {\n            resultText = text[formatSymbolIndex] + resultText;\n          }\n        }\n        resultFormat = format[formatSymbolIndex] + resultFormat;\n      } else {\n        const symbol = format[formatSymbolIndex];\n        let formatSymbolIndexModifier = 0;\n        if (this.autoCorrectParts || !this.autoCorrectParts && !this.getInvalidDatePartValue(symbol)) {\n          while (formatSymbolIndex >= 0 && symbol === format[formatSymbolIndex]) {\n            formatSymbolIndex--;\n          }\n          formatSymbolIndex++;\n        }\n        if (this.leadingZero && this.leadingZero[symbol]) {\n          resultText = '0' + resultText;\n        } else {\n          if (!this.autoCorrectParts && this.getInvalidDatePartValue(symbol)) {\n            let datePartText = this.getInvalidDatePartValue(symbol).toString();\n            if (symbol === \"M\") {\n              datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();\n              if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {\n                resultText = formattedDates[symbol][formatSymbolIndex] + resultText;\n              } else {\n                datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();\n                const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n                resultText = formattedDatePart + resultText;\n                formatSymbolIndexModifier = partsForSegment.length - 1;\n                ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;\n              }\n            } else {\n              const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n              resultText = formattedDatePart + resultText;\n              formatSymbolIndexModifier = partsForSegment.length - 1;\n              ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;\n            }\n          } else {\n            resultText = this.dateFieldName(mask.partMap[formatSymbolIndex]) + resultText;\n          }\n        }\n        while (resultFormat.length < resultText.length) {\n          resultFormat = format[formatSymbolIndex] + resultFormat;\n        }\n        if (formatSymbolIndexModifier !== 0) {\n          formatSymbolIndex = formatSymbolIndex - formatSymbolIndexModifier + (text.length - format.length);\n        }\n      }\n    }\n    return {\n      text: resultText,\n      format: resultFormat\n    };\n  }\n  /**\n   * @hidden\n   */\n  dateFieldName(part) {\n    const formatPlaceholder = this.formatPlaceholder || 'wide';\n    if (formatPlaceholder[part.type]) {\n      return formatPlaceholder[part.type];\n    }\n    if (formatPlaceholder === 'formatPattern') {\n      return part.pattern;\n    }\n    return this.intl.dateFieldName(Object.assign(part, {\n      nameType: formatPlaceholder\n    }));\n  }\n  /**\n   * @hidden\n   */\n  getNormalizedCenturyBase(twoDigitYear) {\n    return twoDigitYear > this.twoDigitYearMax ? PREVIOUS_CENTURY_BASE : CURRENT_CENTURY_BASE;\n  }\n  /**\n   * @hidden\n   */\n  shouldNormalizeCentury() {\n    return this.intl.splitDateFormat(this.format).some(part => part.pattern === 'yy');\n  }\n  resetInvalidDate() {\n    this._partiallyInvalidDate.startDate = null;\n    Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n      this.resetInvalidDatePart(key);\n    });\n  }\n  resetInvalidDateSymbol(symbol) {\n    this.resetInvalidDatePart(symbol);\n    let shouldResetInvalidDate = true;\n    Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n      if (this._partiallyInvalidDate.invalidDateParts[key] && isPresent(this._partiallyInvalidDate.invalidDateParts[key].value)) {\n        shouldResetInvalidDate = false;\n      }\n    });\n    if (shouldResetInvalidDate) {\n      this.resetInvalidDate();\n    }\n  }\n  resetInvalidDatePart(symbol) {\n    if (this._partiallyInvalidDate.invalidDateParts[symbol]) {\n      this._partiallyInvalidDate.invalidDateParts[symbol] = {\n        value: null,\n        date: null,\n        startDateOffset: 0\n      };\n    }\n  }\n  /**\n   * @hidden\n   */\n  getInvalidDatePart(symbol) {\n    const invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];\n    return invalidDatePart || {};\n  }\n  /**\n   * @hidden\n   */\n  getInvalidDatePartValue(symbol) {\n    const invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];\n    return (invalidDatePart || {}).value;\n  }\n  setInvalidDatePart(symbol, {\n    value = null,\n    date = null,\n    startDateOffset = 0,\n    startDate = null\n  }) {\n    if (this._partiallyInvalidDate.invalidDateParts[symbol]) {\n      this._partiallyInvalidDate.invalidDateParts[symbol].value = value;\n      this._partiallyInvalidDate.invalidDateParts[symbol].date = date;\n      this._partiallyInvalidDate.invalidDateParts[symbol].startDateOffset = startDateOffset;\n      this._partiallyInvalidDate.startDate = startDate;\n    }\n  }\n  /**\n   * @hidden\n   */\n  hasInvalidDatePart() {\n    let hasInvalidDatePart = false;\n    Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n      if (this._partiallyInvalidDate.invalidDateParts[key] && isPresent(this._partiallyInvalidDate.invalidDateParts[key].value)) {\n        hasInvalidDatePart = true;\n      }\n    });\n    return hasInvalidDatePart;\n  }\n  /**\n   * @hidden\n   */\n  modifyDateSymbolWithOffset(date, symbol, offset) {\n    let newValue = cloneDate(date);\n    let timeModified = false;\n    switch (symbol) {\n      case 'y':\n        newValue.setFullYear(newValue.getFullYear() + offset);\n        break;\n      case 'M':\n        newValue = addMonths(this.value, offset);\n        break;\n      case 'd':\n      case 'E':\n        newValue.setDate(newValue.getDate() + offset);\n        break;\n      case 'h':\n      case 'H':\n        newValue.setHours(newValue.getHours() + offset);\n        timeModified = true;\n        break;\n      case 'm':\n        newValue.setMinutes(newValue.getMinutes() + offset);\n        timeModified = true;\n        break;\n      case 's':\n        newValue.setSeconds(newValue.getSeconds() + offset);\n        timeModified = true;\n        break;\n      case \"S\":\n        newValue.setMilliseconds(newValue.getMilliseconds() + offset);\n        break;\n      case 'a':\n        newValue.setHours(newValue.getHours() + 12 * offset);\n        timeModified = true;\n        break;\n      default:\n        break;\n    }\n    return {\n      date: newValue,\n      timeModified: timeModified\n    };\n  }\n  /**\n   * @hidden\n   */\n  modifyDateSymbolWithValue(date, symbol, value) {\n    let newValue = cloneDate(date);\n    switch (symbol) {\n      case 'y':\n        newValue.setFullYear(value);\n        break;\n      case 'M':\n        newValue = addMonths(date, value - date.getMonth());\n        break;\n      case 'd':\n      case 'E':\n        newValue.setDate(value);\n        break;\n      case 'h':\n      case 'H':\n        newValue.setHours(value);\n        break;\n      case 'm':\n        newValue.setMinutes(value);\n        break;\n      case 's':\n        newValue.setSeconds(value);\n        break;\n      case \"S\":\n        newValue.setMilliseconds(value);\n        break;\n      case 'a':\n        newValue.setHours(value);\n        break;\n      default:\n        break;\n    }\n    return newValue;\n  }\n  markDatePartsAsExisting() {\n    this.modifyExisting(true);\n  }\n  /**\n   * @hidden\n   */\n  getPartsForSegment(mask, partIndex) {\n    const segmentPart = mask.partMap[partIndex];\n    const partsForSegment = [];\n    for (let maskPartIndex = partIndex; maskPartIndex < mask.partMap.length; maskPartIndex++) {\n      const part = mask.partMap[maskPartIndex];\n      if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {\n        partsForSegment.push(part);\n      } else {\n        break;\n      }\n    }\n    for (let maskPartIndex = partIndex - 1; maskPartIndex >= 0; maskPartIndex--) {\n      const part = mask.partMap[maskPartIndex];\n      if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {\n        partsForSegment.unshift(part);\n      } else {\n        break;\n      }\n    }\n    return partsForSegment;\n  }\n}","map":{"version":3,"names":["addMonths","cloneDate","createDate","isEqual","getDate","lastDayOfMonth","Mask","dateSymbolMap","padZero","unpadZero","extend","isPresent","cropTwoDigitYear","setYears","parseToInt","clamp","areDatePartsEqualTo","isNumber","isValidDate","Constants","PREVIOUS_CENTURY_BASE","CURRENT_CENTURY_BASE","SHORT_PATTERN_LENGTH_REGEXP","MONTH_PART_WITH_WORDS_THRESHOLD","MONTH_SYMBOL","JS_MONTH_OFFSET","DateObject","constructor","intlService","formatPlaceholder","format","cycleTime","twoDigitYearMax","value","autoCorrectParts","year","month","date","hours","minutes","seconds","milliseconds","dayperiod","leadingZero","typedMonthPart","knownParts","symbols","_value","Date","_partiallyInvalidDate","startDate","invalidDateParts","startDateOffset","setOptions","sampleFormat","dateFormatString","i","length","setExisting","resetInvalidDate","localeId","defaultLocaleId","cldrKeys","Object","keys","intl","cldr","key","name","calendar","numbers","options","monthNames","allFormattedMonths","dayPeriods","allDayPeriods","setValue","modifyExisting","hasValue","pred","a","p","type","getExisting","pattern","splitDateFormat","reduce","getValue","getFormattedDate","formatDate","getTextAndFormat","customFormat","text","mask","partiallyInvalidText","formattedDate","formattedDates","getFormattedInvalidDates","symbol","partMap","getInvalidDatePartValue","partsForSegment","getPartsForSegment","datePartText","toString","formattedDatePart","result","merge","formattedDatesForSymbol","forEach","getInvalidDatePart","formattedInvalidDate","setFullYear","setMonth","modifyPart","offset","newValue","timeModified","invalidDateFound","isMonth","isDay","symbolExists","invalidDatePartValue","y","getFullYear","M","getMonth","day","d","E","hour","h","H","getHours","m","getMinutes","s","getSeconds","S","getMilliseconds","resetInvalidDateSymbol","monthValue","dayValue","Math","abs","dateCandidate","newValueCandidate","modifyDateSymbolWithValue","dateCandidateExists","markDatePartsAsExisting","setInvalidDatePart","setDate","setHours","setMinutes","setSeconds","setMilliseconds","shouldNormalizeCentury","normalizeCentury","parsePart","currentChar","resetSegmentValue","cycleSegmentValue","rawTextValue","rawInputValue","isDeleting","originalFormat","isInCaretMode","dateParts","datePartsLiterals","filter","x","map","index","datePartIndex","literal","flatDateParts","datePart","j","shouldResetPart","some","parseResult","switchToNext","resetPart","hasInvalidDatePart","rawValueStartsWithLiteral","startsWith","rawValueEndsWithLiteral","endsWith","rawValueHasConsecutiveLiterals","indexOf","resetLeadingZero","baseDate","baseFormat","replaced","prefix","current","basePrefix","baseSuffix","suffix","convertedBaseFormat","hasFixedFormat","datePartStartIndex","datePartEndIndex","lastIndexOf","segmentLength","formatToTextLengthDiff","existing","parsedDate","matchMonth","dayPeriod","matchDayPeriod","isZeroCurrentChar","valueNumber","isAbbrMonth","incrementLeadingZero","partPattern","patternValue","patternLength","currentMaxLength","tryParse","middle","max","substring","middleNumber","parseInt","candidateDateString","parseDate","autoCorrectedPrefixAndSuffix","isCurrentCharParsable","isNaN","monthNumber","peekedValue","peek","peekedDateString","peekedDate","leadingZeroOffset","patternSatisfied","datePartValue","textToParse","parsedValue","valueCandidate","symbolMap","hasLeadingZero","setLeadingZero","getLeadingZero","twoDigitYear","centuryBase","getNormalizedCenturyBase","normalizedDate","parts","names","part","peekValue","replace","typedChar","toLowerCase","monthAsNum","lowerChart","am","pm","locale","dateFormatParts","dateFormatNames","test","partLength","push","formatSeparator","returnValue","join","resultText","resultFormat","processTextSymbolsEnded","ignoreFormatSymbolsCount","formatSymbolIndex","formatSymbolIndexModifier","dateFieldName","assign","nameType","resetInvalidDatePart","shouldResetInvalidDate","invalidDatePart","modifyDateSymbolWithOffset","partIndex","segmentPart","maskPartIndex","unshift"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-dateinputs-common/dist/es2015/common/dateobject.js"],"sourcesContent":["import { addMonths, cloneDate, createDate, isEqual, getDate, lastDayOfMonth } from '@progress/kendo-date-math';\nimport { Mask } from './mask';\nimport { dateSymbolMap, padZero, unpadZero } from '../dateinput/utils';\nimport { extend, isPresent, cropTwoDigitYear, setYears, parseToInt, clamp, areDatePartsEqualTo, isNumber, isValidDate } from './utils';\nimport { Constants } from './constants';\nconst PREVIOUS_CENTURY_BASE = 1900;\nconst CURRENT_CENTURY_BASE = 2000;\nconst SHORT_PATTERN_LENGTH_REGEXP = /d|M|H|h|m|s/;\nconst MONTH_PART_WITH_WORDS_THRESHOLD = 2;\nconst MONTH_SYMBOL = \"M\";\n// JS months start from 0 (January) instead of 1 (January)\nconst JS_MONTH_OFFSET = 1;\nexport class DateObject {\n    constructor({ intlService, formatPlaceholder, format, cycleTime = false, twoDigitYearMax = Constants.twoDigitYearMax, value = null, autoCorrectParts = true }) {\n        this.year = true;\n        this.month = true;\n        this.date = true;\n        this.hours = true;\n        this.minutes = true;\n        this.seconds = true;\n        this.milliseconds = true;\n        this.dayperiod = true;\n        this.leadingZero = null;\n        this.typedMonthPart = '';\n        this.knownParts = 'adHhmMsEyS';\n        this.symbols = {\n            'E': 'E',\n            'H': 'H',\n            'M': 'M',\n            'a': 'a',\n            'd': 'd',\n            'h': 'h',\n            'm': 'm',\n            's': 's',\n            'y': 'y',\n            'S': 'S'\n        };\n        this._value = getDate(new Date());\n        this.cycleTime = false;\n        this._partiallyInvalidDate = {\n            startDate: null,\n            invalidDateParts: {\n                'E': { value: null, date: null, startDateOffset: 0 },\n                'H': { value: null, date: null, startDateOffset: 0 },\n                'M': { value: null, date: null, startDateOffset: 0 },\n                'a': { value: null, date: null, startDateOffset: 0 },\n                'd': { value: null, date: null, startDateOffset: 0 },\n                'h': { value: null, date: null, startDateOffset: 0 },\n                'm': { value: null, date: null, startDateOffset: 0 },\n                's': { value: null, date: null, startDateOffset: 0 },\n                'y': { value: null, date: null, startDateOffset: 0 },\n                'S': { value: null, date: null, startDateOffset: 0 }\n            }\n        };\n        this.setOptions({\n            intlService,\n            formatPlaceholder,\n            format,\n            cycleTime,\n            twoDigitYearMax,\n            value,\n            autoCorrectParts\n        });\n        if (!value) {\n            this._value = getDate(new Date());\n            const sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n            for (let i = 0; i < sampleFormat.length; i++) {\n                this.setExisting(sampleFormat[i], false);\n            }\n        }\n        else {\n            this._value = cloneDate(value);\n        }\n    }\n    set value(value) {\n        if (value && !(value instanceof Date)) {\n            // throw new Error(\"The 'value' should be a valid JavaScript Date instance.\");\n            return;\n        }\n        this._value = value;\n        this.resetInvalidDate();\n    }\n    get value() {\n        return this._value;\n    }\n    get localeId() {\n        let localeId = Constants.defaultLocaleId;\n        const cldrKeys = Object.keys(this.intl.cldr);\n        for (let i = 0; i < cldrKeys.length; i++) {\n            const key = cldrKeys[i];\n            const value = this.intl.cldr[key];\n            if (value.name && value.calendar && value.numbers &&\n                value.name !== Constants.defaultLocaleId) {\n                localeId = value.name;\n                break;\n            }\n        }\n        return localeId;\n    }\n    /**\n     * @hidden\n     */\n    setOptions(options) {\n        this.intl = options.intlService;\n        this.formatPlaceholder = options.formatPlaceholder || 'wide';\n        this.format = options.format;\n        this.cycleTime = options.cycleTime;\n        this.monthNames = this.allFormattedMonths(this.localeId);\n        this.dayPeriods = this.allDayPeriods(this.localeId);\n        this.twoDigitYearMax = options.twoDigitYearMax;\n        this.autoCorrectParts = options.autoCorrectParts;\n    }\n    setValue(value) {\n        if (!value) {\n            this._value = getDate(new Date());\n            this.modifyExisting(false);\n        }\n        else if (!isEqual(value, this._value)) {\n            this._value = cloneDate(value);\n            this.modifyExisting(true);\n        }\n        this.resetInvalidDate();\n    }\n    /**\n     * @hidden\n     */\n    hasValue() {\n        const pred = (a, p) => a || p.type !== 'literal' && p.type !== 'dayperiod' && this.getExisting(p.pattern[0]);\n        return this.intl.splitDateFormat(this.format, this.localeId).reduce(pred, false);\n    }\n    /**\n     * @hidden\n     */\n    getValue() {\n        for (let i = 0; i < this.knownParts.length; i++) {\n            if (!this.getExisting(this.knownParts[i])) {\n                return null;\n            }\n        }\n        return cloneDate(this.value);\n    }\n    /**\n     * @hidden\n     */\n    getFormattedDate(format) {\n        return this.intl.formatDate(this.getValue(), format, this.localeId);\n    }\n    /**\n     * @hidden\n     */\n    getTextAndFormat(customFormat = \"\") {\n        const format = customFormat || this.format;\n        let text = this.intl.formatDate(this.value, format, this.localeId);\n        const mask = this.dateFormatString(this.value, format);\n        if (!this.autoCorrectParts && this._partiallyInvalidDate.startDate) {\n            let partiallyInvalidText = \"\";\n            const formattedDate = this.intl.formatDate(this.value, format, this.localeId);\n            const formattedDates = this.getFormattedInvalidDates(format);\n            for (let i = 0; i < formattedDate.length; i++) {\n                const symbol = mask.symbols[i];\n                if (mask.partMap[i].type === \"literal\") {\n                    partiallyInvalidText += text[i];\n                }\n                else if (this.getInvalidDatePartValue(symbol)) {\n                    const partsForSegment = this.getPartsForSegment(mask, i);\n                    if (symbol === \"M\") {\n                        const datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();\n                        if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {\n                            partiallyInvalidText += formattedDates[symbol][i];\n                        }\n                        else {\n                            if (this.getInvalidDatePartValue(symbol)) {\n                                const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n                                partiallyInvalidText += formattedDatePart;\n                                // add -1 as the first character in the segment is at index i\n                                i += partsForSegment.length - 1;\n                            }\n                            else {\n                                partiallyInvalidText += formattedDates[symbol][i];\n                            }\n                        }\n                    }\n                    else {\n                        if (this.getInvalidDatePartValue(symbol)) {\n                            const datePartText = this.getInvalidDatePartValue(symbol).toString();\n                            const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n                            partiallyInvalidText += formattedDatePart;\n                            // add -1 as the first character in the segment is at index i\n                            i += partsForSegment.length - 1;\n                        }\n                        else {\n                            partiallyInvalidText += formattedDates[symbol][i];\n                        }\n                    }\n                }\n                else {\n                    partiallyInvalidText += text[i];\n                }\n            }\n            text = partiallyInvalidText;\n        }\n        const result = this.merge(text, mask);\n        return result;\n    }\n    /**\n     * @hidden\n     */\n    getFormattedInvalidDates(customFormat = \"\") {\n        const format = customFormat || this.format;\n        let formattedDatesForSymbol = {\n            'E': '',\n            'H': '',\n            'M': '',\n            'a': '',\n            'd': '',\n            'h': '',\n            'm': '',\n            's': '',\n            'y': '',\n            'S': ''\n        };\n        Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n            const date = this.getInvalidDatePart(key).date;\n            if (date) {\n                const formattedInvalidDate = this.intl.formatDate(date, format, this.localeId);\n                formattedDatesForSymbol[key] = formattedInvalidDate;\n            }\n        });\n        return formattedDatesForSymbol;\n    }\n    modifyExisting(value) {\n        const sampleFormat = this.dateFormatString(this.value, this.format).symbols;\n        for (let i = 0; i < sampleFormat.length; i++) {\n            this.setExisting(sampleFormat[i], value);\n        }\n    }\n    /**\n     * @hidden\n     */\n    getExisting(symbol) {\n        switch (symbol) {\n            case 'y': return this.year;\n            case 'M':\n            case 'L': return this.month;\n            case 'd': return this.date;\n            case 'E': return this.date && this.month && this.year;\n            case 'h':\n            case 'H': return this.hours;\n            case 't':\n            case 'a': return this.dayperiod;\n            case 'm': return this.minutes;\n            case 's': return this.seconds;\n            case \"S\": return this.milliseconds;\n            default:\n                return true;\n        }\n    }\n    setExisting(symbol, value) {\n        switch (symbol) {\n            case 'y':\n                // allow 2/29 dates\n                this.year = value;\n                if (value === false) {\n                    this._value.setFullYear(2000);\n                }\n                break;\n            case 'M':\n                // make sure you can type 31 in the day part\n                this.month = value;\n                if (value === false) {\n                    if (this.autoCorrectParts) {\n                        this._value.setMonth(0);\n                    }\n                }\n                break;\n            case 'd':\n                this.date = value;\n                break;\n            case 'h':\n            case 'H':\n                this.hours = value;\n                break;\n            case 't':\n            case 'a':\n                this.dayperiod = value;\n                break;\n            case 'm':\n                this.minutes = value;\n                break;\n            case 's':\n                this.seconds = value;\n                break;\n            case \"S\":\n                this.milliseconds = value;\n                break;\n            default:\n                break;\n        }\n        if (this.getValue()) {\n            this.resetInvalidDate();\n        }\n    }\n    modifyPart(symbol, offset) {\n        if (!isPresent(symbol) || !isPresent(offset) || offset === 0) {\n            return;\n        }\n        let newValue = cloneDate(this.value);\n        let timeModified = false;\n        let invalidDateFound;\n        const isMonth = symbol === \"M\";\n        const isDay = symbol === \"d\" || symbol === \"E\";\n        const symbolExists = this.getExisting(symbol);\n        if (!this.autoCorrectParts && (isDay || isMonth)) {\n            const invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};\n            const invalidDatePartValue = this.getInvalidDatePartValue(symbol);\n            let year = invalidDateParts.y.value || newValue.getFullYear();\n            let month = invalidDateParts.M.value || newValue.getMonth();\n            let day = invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();\n            let hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();\n            let minutes = invalidDateParts.m.value || newValue.getMinutes();\n            let seconds = invalidDateParts.s.value || newValue.getSeconds();\n            let milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();\n            switch (symbol) {\n                case 'y':\n                    year += offset;\n                    break;\n                case 'M':\n                    month += offset;\n                    break;\n                case 'd':\n                case 'E':\n                    day += offset;\n                    break;\n                // case 'h':\n                // case 'H': hour += offset; break;\n                // case 'm': minutes += offset; break;\n                // case 's': seconds += offset; break;\n                // case 'S': milliseconds += offset; break;\n                default: break;\n            }\n            if (symbol === \"M\") {\n                if ((month < 0 || month > 11)) {\n                    if (symbolExists) {\n                        this.setExisting(symbol, false);\n                        this.resetInvalidDateSymbol(symbol);\n                        return;\n                    }\n                }\n                if (!symbolExists) {\n                    if (month < 0) {\n                        month = clamp(11 + ((month % 11) + 1), 0, 11);\n                    }\n                    else {\n                        const monthValue = isPresent(invalidDatePartValue) ?\n                            month :\n                            ((offset - JS_MONTH_OFFSET) % 12);\n                        month = clamp(monthValue, 0, 11);\n                    }\n                    month = clamp(month, 0, 11);\n                }\n                month = clamp(month, 0, 11);\n            }\n            else if (symbol === \"d\") {\n                if (symbolExists) {\n                    if (day <= 0 || day > 31) {\n                        this.setExisting(symbol, false);\n                        this.resetInvalidDateSymbol(symbol);\n                        return;\n                    }\n                }\n                else if (!symbolExists) {\n                    if (isPresent(invalidDatePartValue)) {\n                        if (day <= 0 || day > 31) {\n                            this.setExisting(symbol, false);\n                            this.resetInvalidDateSymbol(symbol);\n                            return;\n                        }\n                    }\n                    if (offset < 0) {\n                        const dayValue = isPresent(invalidDatePartValue) ? day : 1 + (31 - Math.abs(offset % 31));\n                        day = clamp(dayValue, 1, 31);\n                    }\n                    else {\n                        const dayValue = isPresent(invalidDatePartValue) ? day : offset % 31;\n                        day = clamp(dayValue, 1, 31);\n                    }\n                    day = clamp(day, 1, 31);\n                }\n            }\n            const dateCandidate = createDate(year, month, day, hour, minutes, seconds, milliseconds);\n            const newValueCandidate = isMonth || isDay ?\n                this.modifyDateSymbolWithValue(newValue, symbol, isMonth ? month : day) :\n                null;\n            const dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);\n            if (this.getValue() && areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds)) {\n                newValue = cloneDate(dateCandidate);\n                this.markDatePartsAsExisting();\n            }\n            else if (isMonth && newValueCandidate) {\n                if (newValueCandidate.getMonth() === month) {\n                    if (this.getExisting(\"d\")) {\n                        if (dateCandidateExists) {\n                            newValue = cloneDate(dateCandidate);\n                            this.resetInvalidDateSymbol(symbol);\n                        }\n                        else {\n                            invalidDateFound = true;\n                            this.setInvalidDatePart(symbol, {\n                                value: month,\n                                date: cloneDate(newValueCandidate),\n                                startDateOffset: offset,\n                                startDate: cloneDate(this.value)\n                            });\n                            this.setExisting(symbol, false);\n                        }\n                    }\n                    else if (dateCandidateExists) {\n                        this.resetInvalidDateSymbol(symbol);\n                        newValue = cloneDate(dateCandidate);\n                        if (this.getExisting(\"M\") && this.getExisting(\"y\")) {\n                            // changing from 28/Feb to 29/Feb to 29/March\n                            this.setExisting(\"d\", true);\n                            this.resetInvalidDateSymbol(\"d\");\n                        }\n                    }\n                    else {\n                        this.resetInvalidDateSymbol(symbol);\n                        newValue = cloneDate(newValueCandidate);\n                    }\n                }\n                else {\n                    invalidDateFound = true;\n                    this.setInvalidDatePart(symbol, {\n                        value: month,\n                        date: cloneDate(newValueCandidate),\n                        startDateOffset: offset,\n                        startDate: cloneDate(this.value)\n                    });\n                    this.setExisting(symbol, false);\n                }\n            }\n            else if (isDay && newValueCandidate) {\n                if (newValueCandidate.getDate() === day) {\n                    if (this.getExisting(\"M\")) {\n                        if (dateCandidateExists) {\n                            newValue = cloneDate(dateCandidate);\n                            this.resetInvalidDateSymbol(symbol);\n                        }\n                        else {\n                            invalidDateFound = true;\n                            this.setInvalidDatePart(symbol, {\n                                value: day,\n                                date: cloneDate(newValueCandidate),\n                                startDateOffset: offset,\n                                startDate: cloneDate(this.value)\n                            });\n                            this.setExisting(symbol, false);\n                        }\n                    }\n                    else if (dateCandidateExists) {\n                        newValue = cloneDate(dateCandidate);\n                        this.resetInvalidDateSymbol(symbol);\n                        if (this.getExisting(\"d\") && this.getExisting(\"y\")) {\n                            // changing from 31/Jan to 31/Feb to 28/Feb\n                            this.setExisting(\"M\", true);\n                            this.resetInvalidDateSymbol(\"M\");\n                        }\n                    }\n                    else {\n                        this.resetInvalidDateSymbol(symbol);\n                        newValue = cloneDate(newValueCandidate);\n                    }\n                }\n                else {\n                    invalidDateFound = true;\n                    this.setInvalidDatePart(symbol, {\n                        value: day,\n                        date: cloneDate(this.value),\n                        startDateOffset: offset,\n                        startDate: cloneDate(this.value)\n                    });\n                    this.setExisting(symbol, false);\n                }\n            }\n        }\n        else {\n            switch (symbol) {\n                case 'y':\n                    newValue.setFullYear(newValue.getFullYear() + offset);\n                    break;\n                case 'M':\n                    newValue = addMonths(this.value, offset);\n                    break;\n                case 'd':\n                case 'E':\n                    newValue.setDate(newValue.getDate() + offset);\n                    break;\n                case 'h':\n                case 'H':\n                    newValue.setHours(newValue.getHours() + offset);\n                    timeModified = true;\n                    break;\n                case 'm':\n                    newValue.setMinutes(newValue.getMinutes() + offset);\n                    timeModified = true;\n                    break;\n                case 's':\n                    newValue.setSeconds(newValue.getSeconds() + offset);\n                    timeModified = true;\n                    break;\n                case \"S\":\n                    newValue.setMilliseconds(newValue.getMilliseconds() + offset);\n                    break;\n                case 'a':\n                    newValue.setHours(newValue.getHours() + (12 * offset));\n                    timeModified = true;\n                    break;\n                default: break;\n            }\n        }\n        if (this.shouldNormalizeCentury()) {\n            newValue = this.normalizeCentury(newValue);\n        }\n        if (timeModified && !this.cycleTime && newValue.getDate() !== this._value.getDate()) {\n            // todo: blazor has this fix, but this fails a unit test\n            // newValue.setDate(this._value.getDate());\n            // newValue.setMonth(this._value.getMonth());\n            // newValue.setFullYear(this._value.getFullYear());\n        }\n        if (!invalidDateFound) {\n            this.setExisting(symbol, true);\n            this._value = newValue;\n            if (this.getValue()) {\n                this.resetInvalidDate();\n            }\n        }\n    }\n    /**\n     * @hidden\n     */\n    parsePart({ symbol, currentChar, resetSegmentValue, cycleSegmentValue, rawTextValue: rawInputValue, isDeleting, originalFormat }) {\n        const isInCaretMode = !cycleSegmentValue;\n        const dateParts = this.dateFormatString(this.value, this.format);\n        const datePartsLiterals = dateParts.partMap\n            .filter(x => x.type === \"literal\")\n            .map((x, index) => {\n            return {\n                datePartIndex: index,\n                type: x.type,\n                pattern: x.pattern,\n                literal: \"\"\n            };\n        });\n        const flatDateParts = dateParts.partMap\n            .map((x) => {\n            return {\n                type: x.type,\n                pattern: x.pattern,\n                text: \"\"\n            };\n        });\n        for (let i = 0; i < datePartsLiterals.length; i++) {\n            const datePart = datePartsLiterals[i];\n            for (let j = 0; j < datePart.pattern.length; j++) {\n                if (datePartsLiterals[i + j]) {\n                    datePartsLiterals[i + j].literal = datePart.pattern[j];\n                }\n            }\n            i += datePart.pattern.length - 1;\n        }\n        for (let i = 0; i < flatDateParts.length; i++) {\n            const datePart = flatDateParts[i];\n            for (let j = 0; j < datePart.pattern.length; j++) {\n                if (flatDateParts[i + j]) {\n                    flatDateParts[i + j].text = datePart.pattern[j];\n                }\n            }\n            i += datePart.pattern.length - 1;\n        }\n        let shouldResetPart = isInCaretMode && symbol === \"M\" && dateParts.partMap\n            .filter(x => x.type === \"month\")\n            .some(x => x.pattern.length > MONTH_PART_WITH_WORDS_THRESHOLD);\n        let parseResult = {\n            value: null,\n            switchToNext: false,\n            resetPart: shouldResetPart,\n            hasInvalidDatePart: false\n        };\n        if (!currentChar) {\n            if (isInCaretMode) {\n                for (let i = 0; i < datePartsLiterals.length; i++) {\n                    const literal = datePartsLiterals[i].literal;\n                    const rawValueStartsWithLiteral = rawInputValue.startsWith(literal);\n                    const rawValueEndsWithLiteral = rawInputValue.endsWith(literal);\n                    const rawValueHasConsecutiveLiterals = rawInputValue.indexOf(literal + literal) >= 0;\n                    if (rawValueStartsWithLiteral || rawValueEndsWithLiteral || rawValueHasConsecutiveLiterals) {\n                        this.resetLeadingZero();\n                        this.setExisting(symbol, false);\n                        this.resetInvalidDateSymbol(symbol);\n                        return extend(parseResult, { value: null, switchToNext: false });\n                    }\n                }\n            }\n            else {\n                this.resetLeadingZero();\n                this.setExisting(symbol, false);\n                this.resetInvalidDateSymbol(symbol);\n                return extend(parseResult, { value: null, switchToNext: false });\n            }\n        }\n        const baseDate = this.intl.formatDate(this.value, this.format, this.localeId);\n        const baseFormat = dateParts.symbols;\n        let replaced = false;\n        let prefix = '';\n        let current = '';\n        let datePartText = '';\n        let basePrefix = '';\n        let baseSuffix = '';\n        let suffix = '';\n        let convertedBaseFormat = \"\";\n        for (let i = 0; i < flatDateParts.length; i++) {\n            convertedBaseFormat += flatDateParts[i].text;\n        }\n        const hasFixedFormat = (this.format === baseFormat) ||\n            (this.format === convertedBaseFormat) ||\n            (this.format === originalFormat) ||\n            (this.format.length === originalFormat.length);\n        const datePartStartIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).indexOf(symbol);\n        const datePartEndIndex = (hasFixedFormat ? convertedBaseFormat : originalFormat).lastIndexOf(symbol);\n        const segmentLength = datePartEndIndex - datePartStartIndex + 1;\n        let formatToTextLengthDiff = originalFormat.length - rawInputValue.length;\n        if (isInCaretMode || (!isInCaretMode && !this.autoCorrectParts)) {\n            for (let i = 0; i < baseDate.length; i++) {\n                if (baseFormat[i] === symbol) {\n                    const existing = this.getExisting(symbol);\n                    current += existing ? baseDate[i] : '0';\n                    if (formatToTextLengthDiff > 0) {\n                        if (datePartText.length + formatToTextLengthDiff < segmentLength) {\n                            datePartText += rawInputValue[i] || \"\";\n                        }\n                    }\n                    else {\n                        datePartText += rawInputValue[i] || \"\";\n                    }\n                    replaced = true;\n                }\n                else if (!replaced) {\n                    prefix += baseDate[i];\n                    basePrefix += baseDate[i];\n                }\n                else {\n                    suffix += baseDate[i];\n                    baseSuffix += baseDate[i];\n                }\n            }\n            if (hasFixedFormat) {\n                if (convertedBaseFormat.length < rawInputValue.length) {\n                    datePartText += currentChar;\n                }\n                else if (!isDeleting && originalFormat.length > rawInputValue.length) {\n                    // let the parsing to determine if the incomplete value is valid\n                }\n                if (datePartText.length > segmentLength) {\n                    return extend(parseResult, { value: null, switchToNext: false });\n                }\n            }\n            if (!hasFixedFormat || (hasFixedFormat && !this.autoCorrectParts)) {\n                current = \"\";\n                datePartText = \"\";\n                prefix = \"\";\n                suffix = \"\";\n                replaced = false;\n                for (let i = 0; i < originalFormat.length; i++) {\n                    if (originalFormat[i] === symbol) {\n                        const existing = this.getExisting(symbol);\n                        current += existing ? baseDate[i] || \"\" : '0';\n                        if (formatToTextLengthDiff > 0) {\n                            if (datePartText.length + formatToTextLengthDiff < segmentLength) {\n                                datePartText += rawInputValue[i] || \"\";\n                            }\n                        }\n                        else {\n                            datePartText += rawInputValue[i] || \"\";\n                        }\n                        replaced = true;\n                    }\n                    else if (!replaced) {\n                        prefix += rawInputValue[i] || \"\";\n                    }\n                    else {\n                        suffix += rawInputValue[i - formatToTextLengthDiff] || \"\";\n                    }\n                }\n                if (originalFormat.length < rawInputValue.length) {\n                    datePartText += currentChar;\n                }\n            }\n        }\n        if (!isInCaretMode) {\n            if (this.autoCorrectParts) {\n                current = \"\";\n                datePartText = \"\";\n                prefix = \"\";\n                suffix = \"\";\n                replaced = false;\n                for (let i = 0; i < baseDate.length; i++) {\n                    if (baseFormat[i] === symbol) {\n                        const existing = this.getExisting(symbol);\n                        current += existing ? baseDate[i] : '0';\n                        replaced = true;\n                    }\n                    else if (!replaced) {\n                        prefix += baseDate[i];\n                    }\n                    else {\n                        suffix += baseDate[i];\n                    }\n                }\n            }\n            else {\n                current = resetSegmentValue ? datePartText : current;\n            }\n        }\n        let parsedDate = null;\n        let month = this.matchMonth(currentChar);\n        const dayPeriod = this.matchDayPeriod(currentChar, symbol);\n        const isZeroCurrentChar = currentChar === '0';\n        const leadingZero = this.leadingZero || {};\n        if (isZeroCurrentChar) {\n            if (datePartText === \"0\") {\n                datePartText = current;\n            }\n            let valueNumber = parseToInt(resetSegmentValue ?\n                currentChar :\n                (isInCaretMode ? datePartText : current) + currentChar);\n            if (valueNumber === 0 && !this.isAbbrMonth(dateParts.partMap, symbol)) {\n                this.incrementLeadingZero(symbol);\n            }\n        }\n        else {\n            this.resetLeadingZero();\n        }\n        const partPattern = this.partPattern(dateParts.partMap, symbol);\n        const patternValue = partPattern ? partPattern.pattern : null;\n        const patternLength = this.patternLength(patternValue) || patternValue.length;\n        if (isInCaretMode) {\n            if (isDeleting && !datePartText) {\n                this.setExisting(symbol, false);\n                return extend(parseResult, { value: null, switchToNext: false });\n            }\n        }\n        const currentMaxLength = current.length - 3;\n        let tryParse = true;\n        let middle = isInCaretMode ? datePartText : current;\n        for (let i = Math.max(0, currentMaxLength); i <= current.length; i++) {\n            if (!tryParse) {\n                break;\n            }\n            middle = resetSegmentValue ?\n                currentChar :\n                isInCaretMode ?\n                    datePartText :\n                    (current.substring(i) + currentChar);\n            if (isInCaretMode || !this.autoCorrectParts) {\n                tryParse = false;\n                middle = unpadZero(middle);\n                // middle = padZero(segmentLength - middle.length) + middle;\n                middle = padZero(patternLength - middle.length) + middle;\n            }\n            let middleNumber = parseInt(middle, 10);\n            const candidateDateString = prefix + middle + suffix;\n            parsedDate = this.intl.parseDate(candidateDateString, this.format, this.localeId);\n            let autoCorrectedPrefixAndSuffix = false;\n            if (isInCaretMode && !isValidDate(parsedDate)) {\n                // if part of the date is not available, e.g. \"d\"\n                // but an expanded format like \"F\" is used\n                // the element value can be \"EEEE, February 1, 2022 3:04:05 AM\"\n                // which is not parsable by intl\n                // use the base prefix and suffix, e.g. convert the candidate date string\n                // to \"Thursday, February 1, 2022 3:04:05 AM\"\n                // as \"EEEE, February...\" is not parsable\n                if (this.autoCorrectParts) {\n                    parsedDate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);\n                    autoCorrectedPrefixAndSuffix = true;\n                }\n            }\n            const isCurrentCharParsable = !isNaN(parseInt(currentChar, 10)) || (isInCaretMode && isDeleting && currentChar === \"\");\n            if (!parsedDate && !isNaN(middleNumber) && isCurrentCharParsable && this.autoCorrectParts) {\n                if (symbol === MONTH_SYMBOL && !month) {\n                    // JS months start from 0 (January) instead of 1 (January)\n                    const monthNumber = middleNumber - JS_MONTH_OFFSET;\n                    if (monthNumber > -1 && monthNumber < 12) {\n                        parsedDate = cloneDate(this.value);\n                        parsedDate.setMonth(monthNumber);\n                        if (parsedDate.getMonth() !== monthNumber) {\n                            parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n                        }\n                    }\n                }\n                if (symbol === 'y') {\n                    parsedDate = createDate(parseInt(middle, 10), this.month ? this.value.getMonth() : 0, this.date ? this.value.getDate() : 1, this.hours ? this.value.getHours() : 0, this.minutes ? this.value.getMinutes() : 0, this.seconds ? this.value.getSeconds() : 0, this.milliseconds ? this.value.getMilliseconds() : 0);\n                    if (((isInCaretMode && isValidDate(parsedDate)) ||\n                        (!isInCaretMode && parsedDate)) && this.date && parsedDate.getDate() !== this.value.getDate()) {\n                        parsedDate = lastDayOfMonth(addMonths(parsedDate, -1));\n                    }\n                }\n            }\n            if ((isInCaretMode && isValidDate(parsedDate)) || (!isInCaretMode && parsedDate)) {\n                // move to next segment if the part will overflow with next char\n                // when start from empty date (01, then 010), padded zeros should be trimmed\n                const peekedValue = this.peek(middle, patternValue);\n                const peekedDateString = autoCorrectedPrefixAndSuffix ?\n                    `${basePrefix}${peekedValue}${baseSuffix}` :\n                    `${prefix}${peekedValue}${suffix}`;\n                const peekedDate = this.intl.parseDate(peekedDateString, this.format, this.localeId);\n                const leadingZeroOffset = (this.leadingZero || {})[symbol] || 0;\n                const patternSatisfied = (leadingZeroOffset + unpadZero(middle).length) >= patternLength;\n                let switchToNext = peekedDate === null ||\n                    (leadingZero[symbol] ?\n                        patternValue.length <= middle.length :\n                        patternSatisfied);\n                if (this.shouldNormalizeCentury()) {\n                    parsedDate = this.normalizeCentury(parsedDate);\n                }\n                this._value = parsedDate;\n                this.setExisting(symbol, true);\n                this.resetInvalidDateSymbol(symbol);\n                if (!this.autoCorrectParts) {\n                    if (symbol === \"M\") {\n                        if (this.getExisting(\"M\") && this.getExisting(\"y\")) {\n                            // changing from 28/Feb to 29/Feb to 29/March\n                            this.setExisting(\"d\", true);\n                            this.resetInvalidDateSymbol(\"d\");\n                        }\n                    }\n                    else if (symbol === \"d\") {\n                        if (this.getExisting(\"d\") && this.getExisting(\"y\")) {\n                            // changing from 31/Jan to 31/Feb to 28/Feb\n                            this.setExisting(\"M\", true);\n                            this.resetInvalidDateSymbol(\"M\");\n                        }\n                    }\n                    if (!this.hasInvalidDatePart()) {\n                        this.markDatePartsAsExisting();\n                    }\n                }\n                return extend(parseResult, { value: this.value, switchToNext: switchToNext });\n            }\n        }\n        if (month) {\n            parsedDate = this.intl.parseDate(prefix + month + suffix, this.format, this.localeId);\n            if (parsedDate) {\n                this._value = parsedDate;\n                this.setExisting(symbol, true);\n                return extend(parseResult, { value: this.value, switchToNext: false });\n            }\n        }\n        if (dayPeriod) {\n            parsedDate = this.intl.parseDate(prefix + dayPeriod + suffix, this.format);\n            if (parsedDate) {\n                this._value = parsedDate;\n                return extend(parseResult, { value: this.value, switchToNext: true });\n            }\n        }\n        if (isZeroCurrentChar) {\n            this.setExisting(symbol, false);\n        }\n        if (!this.autoCorrectParts) {\n            let datePartValue;\n            const textToParse = isInCaretMode ? datePartText : middle;\n            const parsedValue = parseToInt(textToParse);\n            if (isNumber(parsedValue)) {\n                if ((symbol === \"d\" && (parsedValue <= 0 || parsedValue > 31)) ||\n                    (symbol === \"M\" && (parsedValue < 0 || parsedValue > 11))) {\n                    return extend(parseResult, { value: null, switchToNext: false });\n                }\n                datePartValue = symbol === \"M\" ?\n                    parsedValue - JS_MONTH_OFFSET :\n                    parsedValue;\n                const isMonth = symbol === \"M\";\n                const isDay = symbol === \"d\";\n                let newValue = cloneDate(this._value);\n                const invalidDateParts = this._partiallyInvalidDate.invalidDateParts || {};\n                let year = invalidDateParts.y.value || newValue.getFullYear();\n                /* tslint:disable:no-shadowed-variable */\n                let month = isMonth ? datePartValue : invalidDateParts.M.value || newValue.getMonth();\n                /* tslint:enable:no-shadowed-variable */\n                let day = isDay ? datePartValue : invalidDateParts.d.value || invalidDateParts.E.value || newValue.getDate();\n                let hour = invalidDateParts.h.value || invalidDateParts.H.value || newValue.getHours();\n                let minutes = invalidDateParts.m.value || newValue.getMinutes();\n                let seconds = invalidDateParts.s.value || newValue.getSeconds();\n                let milliseconds = invalidDateParts.S.value || newValue.getMilliseconds();\n                const dateCandidate = createDate(year, month, day, hour, minutes, seconds, milliseconds);\n                const dateCandidateExists = areDatePartsEqualTo(dateCandidate, year, month, day, hour, minutes, seconds, milliseconds);\n                const newValueCandidate = isMonth || isDay ?\n                    this.modifyDateSymbolWithValue(newValue, symbol, isMonth ? month : day) :\n                    null;\n                let invalidDateFound = false;\n                if (isMonth && newValueCandidate) {\n                    if (newValueCandidate.getMonth() === month) {\n                        if (this.getExisting(\"d\")) {\n                            if (dateCandidateExists) {\n                                newValue = cloneDate(dateCandidate);\n                                this.resetInvalidDateSymbol(symbol);\n                            }\n                            else {\n                                invalidDateFound = true;\n                                this.setInvalidDatePart(symbol, {\n                                    value: month,\n                                    date: cloneDate(newValueCandidate),\n                                    startDate: cloneDate(this.value)\n                                });\n                                this.setExisting(symbol, false);\n                            }\n                        }\n                        else if (dateCandidateExists) {\n                            this.resetInvalidDateSymbol(symbol);\n                            newValue = cloneDate(dateCandidate);\n                            if (this.getExisting(\"M\") && this.getExisting(\"y\")) {\n                                // changing from 28/Feb to 29/Feb to 29/March\n                                this.setExisting(\"d\", true);\n                                this.resetInvalidDateSymbol(\"d\");\n                            }\n                        }\n                        else {\n                            this.resetInvalidDateSymbol(symbol);\n                            newValue = cloneDate(newValueCandidate);\n                        }\n                    }\n                    else {\n                        invalidDateFound = true;\n                        this.setInvalidDatePart(symbol, {\n                            value: month,\n                            date: cloneDate(newValueCandidate),\n                            startDate: cloneDate(this.value)\n                        });\n                        this.setExisting(symbol, false);\n                    }\n                }\n                else if (isDay && newValueCandidate) {\n                    if (newValueCandidate.getDate() === day) {\n                        if (this.getExisting(\"M\")) {\n                            if (dateCandidateExists) {\n                                newValue = cloneDate(dateCandidate);\n                                this.resetInvalidDateSymbol(symbol);\n                            }\n                            else {\n                                invalidDateFound = true;\n                                this.setInvalidDatePart(symbol, {\n                                    value: day,\n                                    date: cloneDate(newValueCandidate),\n                                    startDate: cloneDate(this.value)\n                                });\n                                this.setExisting(symbol, false);\n                            }\n                        }\n                        else if (dateCandidateExists) {\n                            newValue = cloneDate(dateCandidate);\n                            this.resetInvalidDateSymbol(symbol);\n                            if (this.getExisting(\"d\") && this.getExisting(\"y\")) {\n                                // changing from 31/Jan to 31/Feb to 28/Feb\n                                this.setExisting(\"M\", true);\n                                this.resetInvalidDateSymbol(\"M\");\n                            }\n                        }\n                        else {\n                            this.resetInvalidDateSymbol(symbol);\n                            newValue = cloneDate(newValueCandidate);\n                        }\n                    }\n                    else {\n                        invalidDateFound = true;\n                        this.setInvalidDatePart(symbol, {\n                            value: day,\n                            date: cloneDate(this.value),\n                            startDate: cloneDate(this.value)\n                        });\n                        this.setExisting(symbol, false);\n                    }\n                }\n                if (!invalidDateFound) {\n                    this.setExisting(symbol, true);\n                    if (isInCaretMode && !isValidDate(parsedDate)) {\n                        const valueCandidate = this.intl.parseDate(basePrefix + middle + baseSuffix, this.format, this.localeId);\n                        if (isValidDate(valueCandidate)) {\n                            this._value = valueCandidate;\n                        }\n                    }\n                    else {\n                        this._value = newValue;\n                    }\n                    if (this.getValue()) {\n                        this.resetInvalidDate();\n                    }\n                }\n                let switchToNext = false;\n                if (symbol === \"M\") {\n                    if (parsedValue >= 2 || textToParse.length >= 2) {\n                        switchToNext = true;\n                    }\n                    else {\n                        switchToNext = false;\n                    }\n                }\n                else {\n                    switchToNext = hasFixedFormat ?\n                        textToParse.length === segmentLength :\n                        textToParse.length > segmentLength;\n                }\n                return extend(parseResult, {\n                    value: null,\n                    switchToNext: switchToNext,\n                    hasInvalidDatePart: invalidDateFound\n                });\n            }\n        }\n        return extend(parseResult, { value: null, switchToNext: false });\n    }\n    /**\n     * @hidden\n     */\n    symbolMap(symbol) {\n        return this.intl.splitDateFormat(this.format, this.localeId).reduce(dateSymbolMap, {})[symbol];\n    }\n    /**\n     * @hidden\n     */\n    resetLeadingZero() {\n        const hasLeadingZero = this.leadingZero !== null;\n        this.setLeadingZero(null);\n        return hasLeadingZero;\n    }\n    setLeadingZero(leadingZero) {\n        this.leadingZero = leadingZero;\n    }\n    /**\n     * @hidden\n     */\n    getLeadingZero() {\n        return this.leadingZero || {};\n    }\n    /**\n     * @hidden\n     */\n    normalizeCentury(date) {\n        if (!isPresent(date)) {\n            return date;\n        }\n        const twoDigitYear = cropTwoDigitYear(date);\n        const centuryBase = this.getNormalizedCenturyBase(twoDigitYear);\n        const normalizedDate = setYears(date, centuryBase + twoDigitYear);\n        return normalizedDate;\n    }\n    incrementLeadingZero(symbol) {\n        const leadingZero = this.leadingZero || {};\n        leadingZero[symbol] = (leadingZero[symbol] || 0) + 1;\n        this.leadingZero = leadingZero;\n    }\n    /**\n     * @hidden\n     */\n    isAbbrMonth(parts, symbol) {\n        const pattern = this.partPattern(parts, symbol);\n        return pattern.type === 'month' && pattern.names;\n    }\n    /**\n     * @hidden\n     */\n    partPattern(parts, symbol) {\n        return parts.filter((part) => part.pattern.indexOf(symbol) !== -1)[0];\n    }\n    /**\n     * @hidden\n     */\n    peek(value, pattern) {\n        const peekValue = value.replace(/^0*/, '') + '0';\n        return padZero(pattern.length - peekValue.length) + peekValue;\n    }\n    /**\n     * @hidden\n     */\n    matchMonth(typedChar) {\n        this.typedMonthPart += typedChar.toLowerCase();\n        if (this.monthNames.length === 0) {\n            return '';\n        }\n        while (this.typedMonthPart.length > 0) {\n            for (let i = 0; i < this.monthNames.length; i++) {\n                if (this.monthNames[i].toLowerCase().indexOf(this.typedMonthPart) === 0) {\n                    return this.monthNames[i];\n                }\n            }\n            const monthAsNum = parseInt(this.typedMonthPart, 10);\n            /* ensure they exact match */\n            if (monthAsNum >= 1 && monthAsNum <= 12 && monthAsNum.toString() === this.typedMonthPart) {\n                return this.monthNames[monthAsNum - 1];\n            }\n            this.typedMonthPart = this.typedMonthPart.substring(1, this.typedMonthPart.length);\n        }\n        return '';\n    }\n    /**\n     * @hidden\n     */\n    matchDayPeriod(typedChar, symbol) {\n        const lowerChart = typedChar.toLowerCase();\n        if (symbol === 'a' && this.dayPeriods) {\n            if (this.dayPeriods.am.toLowerCase().startsWith(lowerChart)) {\n                return this.dayPeriods.am;\n            }\n            else if (this.dayPeriods.pm.toLowerCase().startsWith(lowerChart)) {\n                return this.dayPeriods.pm;\n            }\n        }\n        return '';\n    }\n    /**\n     * @hidden\n     */\n    allFormattedMonths(locale = \"en\") {\n        const dateFormatParts = this.intl.splitDateFormat(this.format, this.localeId);\n        for (let i = 0; i < dateFormatParts.length; i++) {\n            if (dateFormatParts[i].type === 'month' && dateFormatParts[i].names) {\n                return this.intl.dateFormatNames(locale, dateFormatParts[i].names);\n            }\n        }\n        return [];\n    }\n    /**\n     * @hidden\n     */\n    allDayPeriods(locale = \"en\") {\n        const dateFormatParts = this.intl.splitDateFormat(this.format);\n        for (let i = 0; i < dateFormatParts.length; i++) {\n            if (dateFormatParts[i].type === \"dayperiod\" && dateFormatParts[i].names) {\n                return this.intl.dateFormatNames(locale, dateFormatParts[i].names);\n            }\n        }\n        return null;\n    }\n    /**\n     * @hidden\n     */\n    patternLength(pattern) {\n        if (pattern[0] === 'y') {\n            return 4;\n        }\n        if (SHORT_PATTERN_LENGTH_REGEXP.test(pattern)) {\n            return 2;\n        }\n        return 0;\n    }\n    /**\n     * @hidden\n     */\n    dateFormatString(date, format) {\n        const dateFormatParts = this.intl.splitDateFormat(format, this.localeId);\n        const parts = [];\n        const partMap = [];\n        for (let i = 0; i < dateFormatParts.length; i++) {\n            let partLength = this.intl.formatDate(date, { pattern: dateFormatParts[i].pattern }, this.localeId).length;\n            while (partLength > 0) {\n                parts.push(this.symbols[dateFormatParts[i].pattern[0]] || Constants.formatSeparator);\n                partMap.push(dateFormatParts[i]);\n                partLength--;\n            }\n        }\n        const returnValue = new Mask();\n        returnValue.symbols = parts.join('');\n        returnValue.partMap = partMap;\n        return returnValue;\n    }\n    /**\n     * @hidden\n     */\n    merge(text, mask) {\n        // Important: right to left.\n        let resultText = '';\n        let resultFormat = '';\n        let format = mask.symbols;\n        let processTextSymbolsEnded = false;\n        let ignoreFormatSymbolsCount = 0;\n        const formattedDates = this.getFormattedInvalidDates(format);\n        for (let formatSymbolIndex = format.length - 1; formatSymbolIndex >= 0; formatSymbolIndex--) {\n            const partsForSegment = this.getPartsForSegment(mask, formatSymbolIndex);\n            if (this.knownParts.indexOf(format[formatSymbolIndex]) === -1 || this.getExisting(format[formatSymbolIndex])) {\n                if (this.autoCorrectParts) {\n                    resultText = text[formatSymbolIndex] + resultText;\n                }\n                else {\n                    if (text.length !== format.length) {\n                        if (processTextSymbolsEnded) {\n                            resultText = text[formatSymbolIndex] + resultText;\n                        }\n                        else if (ignoreFormatSymbolsCount > 0) {\n                            resultText = text[formatSymbolIndex] + resultText;\n                            ignoreFormatSymbolsCount--;\n                            if (ignoreFormatSymbolsCount <= 0) {\n                                processTextSymbolsEnded = true;\n                            }\n                        }\n                        else {\n                            resultText = (text[formatSymbolIndex + text.length - format.length] || \"\") + resultText;\n                        }\n                    }\n                    else {\n                        resultText = text[formatSymbolIndex] + resultText;\n                    }\n                }\n                resultFormat = format[formatSymbolIndex] + resultFormat;\n            }\n            else {\n                const symbol = format[formatSymbolIndex];\n                let formatSymbolIndexModifier = 0;\n                if (this.autoCorrectParts || (!this.autoCorrectParts && !this.getInvalidDatePartValue(symbol))) {\n                    while (formatSymbolIndex >= 0 && symbol === format[formatSymbolIndex]) {\n                        formatSymbolIndex--;\n                    }\n                    formatSymbolIndex++;\n                }\n                if (this.leadingZero && this.leadingZero[symbol]) {\n                    resultText = '0' + resultText;\n                }\n                else {\n                    if (!this.autoCorrectParts && this.getInvalidDatePartValue(symbol)) {\n                        let datePartText = this.getInvalidDatePartValue(symbol).toString();\n                        if (symbol === \"M\") {\n                            datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();\n                            if (partsForSegment.length > MONTH_PART_WITH_WORDS_THRESHOLD) {\n                                resultText = formattedDates[symbol][formatSymbolIndex] + resultText;\n                            }\n                            else {\n                                datePartText = (parseToInt(this.getInvalidDatePartValue(symbol)) + JS_MONTH_OFFSET).toString();\n                                const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n                                resultText = formattedDatePart + resultText;\n                                formatSymbolIndexModifier = partsForSegment.length - 1;\n                                ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;\n                            }\n                        }\n                        else {\n                            const formattedDatePart = padZero(partsForSegment.length - datePartText.length) + datePartText;\n                            resultText = formattedDatePart + resultText;\n                            formatSymbolIndexModifier = partsForSegment.length - 1;\n                            ignoreFormatSymbolsCount = datePartText.length - partsForSegment.length;\n                        }\n                    }\n                    else {\n                        resultText = this.dateFieldName(mask.partMap[formatSymbolIndex]) + resultText;\n                    }\n                }\n                while (resultFormat.length < resultText.length) {\n                    resultFormat = format[formatSymbolIndex] + resultFormat;\n                }\n                if (formatSymbolIndexModifier !== 0) {\n                    formatSymbolIndex = (formatSymbolIndex - formatSymbolIndexModifier) + (text.length - format.length);\n                }\n            }\n        }\n        return { text: resultText, format: resultFormat };\n    }\n    /**\n     * @hidden\n     */\n    dateFieldName(part) {\n        const formatPlaceholder = this.formatPlaceholder || 'wide';\n        if (formatPlaceholder[part.type]) {\n            return formatPlaceholder[part.type];\n        }\n        if (formatPlaceholder === 'formatPattern') {\n            return part.pattern;\n        }\n        return this.intl.dateFieldName(Object.assign(part, { nameType: formatPlaceholder }));\n    }\n    /**\n     * @hidden\n     */\n    getNormalizedCenturyBase(twoDigitYear) {\n        return twoDigitYear > this.twoDigitYearMax ?\n            PREVIOUS_CENTURY_BASE :\n            CURRENT_CENTURY_BASE;\n    }\n    /**\n     * @hidden\n     */\n    shouldNormalizeCentury() {\n        return this.intl.splitDateFormat(this.format).some(part => part.pattern === 'yy');\n    }\n    resetInvalidDate() {\n        this._partiallyInvalidDate.startDate = null;\n        Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n            this.resetInvalidDatePart(key);\n        });\n    }\n    resetInvalidDateSymbol(symbol) {\n        this.resetInvalidDatePart(symbol);\n        let shouldResetInvalidDate = true;\n        Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n            if (this._partiallyInvalidDate.invalidDateParts[key] &&\n                isPresent(this._partiallyInvalidDate.invalidDateParts[key].value)) {\n                shouldResetInvalidDate = false;\n            }\n        });\n        if (shouldResetInvalidDate) {\n            this.resetInvalidDate();\n        }\n    }\n    resetInvalidDatePart(symbol) {\n        if (this._partiallyInvalidDate.invalidDateParts[symbol]) {\n            this._partiallyInvalidDate.invalidDateParts[symbol] = {\n                value: null,\n                date: null,\n                startDateOffset: 0\n            };\n        }\n    }\n    /**\n     * @hidden\n     */\n    getInvalidDatePart(symbol) {\n        const invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];\n        return invalidDatePart || {};\n    }\n    /**\n     * @hidden\n     */\n    getInvalidDatePartValue(symbol) {\n        const invalidDatePart = this._partiallyInvalidDate.invalidDateParts[symbol];\n        return (invalidDatePart || {}).value;\n    }\n    setInvalidDatePart(symbol, { value = null, date = null, startDateOffset = 0, startDate = null }) {\n        if (this._partiallyInvalidDate.invalidDateParts[symbol]) {\n            this._partiallyInvalidDate.invalidDateParts[symbol].value = value;\n            this._partiallyInvalidDate.invalidDateParts[symbol].date = date;\n            this._partiallyInvalidDate.invalidDateParts[symbol].startDateOffset = startDateOffset;\n            this._partiallyInvalidDate.startDate = startDate;\n        }\n    }\n    /**\n     * @hidden\n     */\n    hasInvalidDatePart() {\n        let hasInvalidDatePart = false;\n        Object.keys(this._partiallyInvalidDate.invalidDateParts).forEach(key => {\n            if (this._partiallyInvalidDate.invalidDateParts[key] &&\n                isPresent(this._partiallyInvalidDate.invalidDateParts[key].value)) {\n                hasInvalidDatePart = true;\n            }\n        });\n        return hasInvalidDatePart;\n    }\n    /**\n     * @hidden\n     */\n    modifyDateSymbolWithOffset(date, symbol, offset) {\n        let newValue = cloneDate(date);\n        let timeModified = false;\n        switch (symbol) {\n            case 'y':\n                newValue.setFullYear(newValue.getFullYear() + offset);\n                break;\n            case 'M':\n                newValue = addMonths(this.value, offset);\n                break;\n            case 'd':\n            case 'E':\n                newValue.setDate(newValue.getDate() + offset);\n                break;\n            case 'h':\n            case 'H':\n                newValue.setHours(newValue.getHours() + offset);\n                timeModified = true;\n                break;\n            case 'm':\n                newValue.setMinutes(newValue.getMinutes() + offset);\n                timeModified = true;\n                break;\n            case 's':\n                newValue.setSeconds(newValue.getSeconds() + offset);\n                timeModified = true;\n                break;\n            case \"S\":\n                newValue.setMilliseconds(newValue.getMilliseconds() + offset);\n                break;\n            case 'a':\n                newValue.setHours(newValue.getHours() + (12 * offset));\n                timeModified = true;\n                break;\n            default: break;\n        }\n        return {\n            date: newValue,\n            timeModified: timeModified\n        };\n    }\n    /**\n     * @hidden\n     */\n    modifyDateSymbolWithValue(date, symbol, value) {\n        let newValue = cloneDate(date);\n        switch (symbol) {\n            case 'y':\n                newValue.setFullYear(value);\n                break;\n            case 'M':\n                newValue = addMonths(date, value - date.getMonth());\n                break;\n            case 'd':\n            case 'E':\n                newValue.setDate(value);\n                break;\n            case 'h':\n            case 'H':\n                newValue.setHours(value);\n                break;\n            case 'm':\n                newValue.setMinutes(value);\n                break;\n            case 's':\n                newValue.setSeconds(value);\n                break;\n            case \"S\":\n                newValue.setMilliseconds(value);\n                break;\n            case 'a':\n                newValue.setHours(value);\n                break;\n            default: break;\n        }\n        return newValue;\n    }\n    markDatePartsAsExisting() {\n        this.modifyExisting(true);\n    }\n    /**\n     * @hidden\n     */\n    getPartsForSegment(mask, partIndex) {\n        const segmentPart = mask.partMap[partIndex];\n        const partsForSegment = [];\n        for (let maskPartIndex = partIndex; maskPartIndex < mask.partMap.length; maskPartIndex++) {\n            const part = mask.partMap[maskPartIndex];\n            if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {\n                partsForSegment.push(part);\n            }\n            else {\n                break;\n            }\n        }\n        for (let maskPartIndex = partIndex - 1; maskPartIndex >= 0; maskPartIndex--) {\n            const part = mask.partMap[maskPartIndex];\n            if (segmentPart.type === part.type && segmentPart.pattern === part.pattern) {\n                partsForSegment.unshift(part);\n            }\n            else {\n                break;\n            }\n        }\n        return partsForSegment;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}