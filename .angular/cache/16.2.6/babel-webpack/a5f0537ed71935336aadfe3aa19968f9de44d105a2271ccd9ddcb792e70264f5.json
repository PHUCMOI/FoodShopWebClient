{"ast":null,"code":"import PlotAreaBase from './plotarea-base';\nimport AxisGroupRangeTracker from '../axis-group-range-tracker';\nimport PlotAreaEventsMixin from '../mixins/plotarea-events-mixin';\nimport ScatterChart from '../scatter-charts/scatter-chart';\nimport ScatterLineChart from '../scatter-charts/scatter-line-chart';\nimport BubbleChart from '../bubble-chart/bubble-chart';\nimport SeriesBinder from '../series-binder';\nimport trendlineFactory from '../trendlines/trendline-factory';\nimport scatterTrendlineRegistry from '../trendlines/scatter-trendline-registry';\nimport { NumericAxis, LogarithmicAxis, DateValueAxis, Point } from '../../core';\nimport { filterSeriesByType, equalsIgnoreCase, singleItemOrArray } from '../utils';\nimport { SCATTER, SCATTER_LINE, BUBBLE, LOGARITHMIC } from '../constants';\nimport { DATE } from '../../common/constants';\nimport { deepExtend, eventElement, grep, inArray, setDefaultOptions } from '../../common';\nclass XYPlotArea extends PlotAreaBase {\n  initFields() {\n    this.namedXAxes = {};\n    this.namedYAxes = {};\n    this.xAxisRangeTracker = new AxisGroupRangeTracker();\n    this.yAxisRangeTracker = new AxisGroupRangeTracker();\n  }\n  render(panes = this.panes) {\n    this.series = [...this.originalSeries];\n    this.createTrendlineSeries();\n    const seriesByPane = this.groupSeriesByPane();\n    for (let i = 0; i < panes.length; i++) {\n      const pane = panes[i];\n      const paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n      this.addToLegend(paneSeries);\n      const filteredSeries = this.filterVisibleSeries(paneSeries);\n      if (!filteredSeries) {\n        continue;\n      }\n      this.createScatterChart(filterSeriesByType(filteredSeries, SCATTER), pane);\n      this.createScatterLineChart(filterSeriesByType(filteredSeries, SCATTER_LINE), pane);\n      this.createBubbleChart(filterSeriesByType(filteredSeries, BUBBLE), pane);\n    }\n    this.createAxes(panes);\n  }\n  appendChart(chart, pane) {\n    this.xAxisRangeTracker.update(chart.xAxisRanges);\n    this.yAxisRangeTracker.update(chart.yAxisRanges);\n    super.appendChart(chart, pane);\n  }\n  removeAxis(axis) {\n    const axisName = axis.options.name;\n    super.removeAxis(axis);\n    if (axis.options.vertical) {\n      this.yAxisRangeTracker.reset(axisName);\n      delete this.namedYAxes[axisName];\n    } else {\n      this.xAxisRangeTracker.reset(axisName);\n      delete this.namedXAxes[axisName];\n    }\n    if (axis === this.axisX) {\n      delete this.axisX;\n    }\n    if (axis === this.axisY) {\n      delete this.axisY;\n    }\n  }\n\n  // TODO: Refactor, optionally use series.pane option\n  seriesPaneName(series) {\n    const options = this.options;\n    const xAxisName = series.xAxis;\n    const xAxisOptions = [].concat(options.xAxis);\n    const xAxis = grep(xAxisOptions, function (a) {\n      return a.name === xAxisName;\n    })[0];\n    const yAxisName = series.yAxis;\n    const yAxisOptions = [].concat(options.yAxis);\n    const yAxis = grep(yAxisOptions, function (a) {\n      return a.name === yAxisName;\n    })[0];\n    const panes = options.panes || [{}];\n    const defaultPaneName = panes[0].name || \"default\";\n    const paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;\n    return paneName;\n  }\n  createScatterChart(series, pane) {\n    if (series.length > 0) {\n      this.appendChart(new ScatterChart(this, {\n        series: series,\n        clip: pane.options.clip\n      }), pane);\n    }\n  }\n  createScatterLineChart(series, pane) {\n    if (series.length > 0) {\n      this.appendChart(new ScatterLineChart(this, {\n        series: series,\n        clip: pane.options.clip\n      }), pane);\n    }\n  }\n  createBubbleChart(series, pane) {\n    if (series.length > 0) {\n      this.appendChart(new BubbleChart(this, {\n        series: series,\n        clip: pane.options.clip\n      }), pane);\n    }\n  }\n  createXYAxis(options, vertical, axisIndex) {\n    const axisName = options.name;\n    const namedAxes = vertical ? this.namedYAxes : this.namedXAxes;\n    const tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;\n    const axisOptions = deepExtend({\n      reverse: !vertical && this.chartService.rtl\n    }, options, {\n      vertical: vertical\n    });\n    const isLog = equalsIgnoreCase(axisOptions.type, LOGARITHMIC);\n    const defaultRange = tracker.query();\n    const defaultAxisRange = isLog ? {\n      min: 0.1,\n      max: 1\n    } : {\n      min: 0,\n      max: 1\n    };\n    const range = tracker.query(axisName) || defaultRange || defaultAxisRange;\n    const typeSamples = [axisOptions.min, axisOptions.max];\n    const series = this.series;\n    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      const currentSeries = series[seriesIx];\n      const seriesAxisName = currentSeries[vertical ? \"yAxis\" : \"xAxis\"];\n      if (seriesAxisName === axisOptions.name || axisIndex === 0 && !seriesAxisName) {\n        const firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;\n        typeSamples.push(firstPointValue[vertical ? \"y\" : \"x\"]);\n        break;\n      }\n    }\n    if (axisIndex === 0 && defaultRange) {\n      range.min = Math.min(range.min, defaultRange.min);\n      range.max = Math.max(range.max, defaultRange.max);\n    }\n    let inferredDate;\n    for (let i = 0; i < typeSamples.length; i++) {\n      if (typeSamples[i] instanceof Date) {\n        inferredDate = true;\n        break;\n      }\n    }\n    let axisType;\n    if (equalsIgnoreCase(axisOptions.type, DATE) || !axisOptions.type && inferredDate) {\n      axisType = DateValueAxis;\n    } else if (isLog) {\n      axisType = LogarithmicAxis;\n    } else {\n      axisType = NumericAxis;\n    }\n    const axis = new axisType(range.min, range.max, axisOptions, this.chartService);\n    axis.axisIndex = axisIndex;\n    if (axisName) {\n      if (namedAxes[axisName]) {\n        throw new Error(`${vertical ? \"Y\" : \"X\"} axis with name ${axisName} is already defined`);\n      }\n      namedAxes[axisName] = axis;\n    }\n    this.appendAxis(axis);\n    return axis;\n  }\n  createAxes(panes) {\n    const options = this.options;\n    const xAxesOptions = [].concat(options.xAxis);\n    const xAxes = [];\n    const yAxesOptions = [].concat(options.yAxis);\n    const yAxes = [];\n    for (let idx = 0; idx < xAxesOptions.length; idx++) {\n      const axisPane = this.findPane(xAxesOptions[idx].pane);\n      if (inArray(axisPane, panes)) {\n        xAxes.push(this.createXYAxis(xAxesOptions[idx], false, idx));\n      }\n    }\n    for (let idx = 0; idx < yAxesOptions.length; idx++) {\n      const axisPane = this.findPane(yAxesOptions[idx].pane);\n      if (inArray(axisPane, panes)) {\n        yAxes.push(this.createXYAxis(yAxesOptions[idx], true, idx));\n      }\n    }\n    this.axisX = this.axisX || xAxes[0];\n    this.axisY = this.axisY || yAxes[0];\n  }\n  _dispatchEvent(chart, e, eventType) {\n    const coords = chart._eventCoordinates(e);\n    const point = new Point(coords.x, coords.y);\n    const allAxes = this.axes;\n    const length = allAxes.length;\n    const xValues = [];\n    const yValues = [];\n    for (let i = 0; i < length; i++) {\n      const axis = allAxes[i];\n      const values = axis.options.vertical ? yValues : xValues;\n      const currentValue = axis.getValue(point);\n      if (currentValue !== null) {\n        values.push(currentValue);\n      }\n    }\n    if (xValues.length > 0 && yValues.length > 0) {\n      chart.trigger(eventType, {\n        element: eventElement(e),\n        originalEvent: e,\n        x: singleItemOrArray(xValues),\n        y: singleItemOrArray(yValues)\n      });\n    }\n  }\n  updateAxisOptions(axis, options) {\n    const vertical = axis.options.vertical;\n    const axes = this.groupAxes(this.panes);\n    const index = (vertical ? axes.y : axes.x).indexOf(axis);\n    updateAxisOptions(this.options, index, vertical, options);\n    updateAxisOptions(this.originalOptions, index, vertical, options);\n  }\n  trendlineFactory(options, series) {\n    const seriesValues = this.seriesValues.bind(this, series.index);\n    const trendline = trendlineFactory(scatterTrendlineRegistry, options.type, {\n      options,\n      seriesValues\n    });\n    if (trendline) {\n      // Inherit settings\n      trendline.xAxis = series.xAxis;\n      trendline.yAxis = series.yAxis;\n    }\n    return trendline;\n  }\n  seriesValues(seriesIx) {\n    const result = [];\n    const currentSeries = this.series[seriesIx];\n    for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n      const data = this.bindPoint(currentSeries, pointIx);\n      result.push({\n        pointIx,\n        valueFields: data.valueFields\n      });\n    }\n    return result;\n  }\n}\nfunction updateAxisOptions(targetOptions, axisIndex, vertical, options) {\n  const axisOptions = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];\n  deepExtend(axisOptions, options);\n}\nsetDefaultOptions(XYPlotArea, {\n  xAxis: {},\n  yAxis: {}\n});\ndeepExtend(XYPlotArea.prototype, PlotAreaEventsMixin);\nexport default XYPlotArea;","map":{"version":3,"names":["PlotAreaBase","AxisGroupRangeTracker","PlotAreaEventsMixin","ScatterChart","ScatterLineChart","BubbleChart","SeriesBinder","trendlineFactory","scatterTrendlineRegistry","NumericAxis","LogarithmicAxis","DateValueAxis","Point","filterSeriesByType","equalsIgnoreCase","singleItemOrArray","SCATTER","SCATTER_LINE","BUBBLE","LOGARITHMIC","DATE","deepExtend","eventElement","grep","inArray","setDefaultOptions","XYPlotArea","initFields","namedXAxes","namedYAxes","xAxisRangeTracker","yAxisRangeTracker","render","panes","series","originalSeries","createTrendlineSeries","seriesByPane","groupSeriesByPane","i","length","pane","paneSeries","options","name","addToLegend","filteredSeries","filterVisibleSeries","createScatterChart","createScatterLineChart","createBubbleChart","createAxes","appendChart","chart","update","xAxisRanges","yAxisRanges","removeAxis","axis","axisName","vertical","reset","axisX","axisY","seriesPaneName","xAxisName","xAxis","xAxisOptions","concat","a","yAxisName","yAxis","yAxisOptions","defaultPaneName","paneName","clip","createXYAxis","axisIndex","namedAxes","tracker","axisOptions","reverse","chartService","rtl","isLog","type","defaultRange","query","defaultAxisRange","min","max","range","typeSamples","seriesIx","currentSeries","seriesAxisName","firstPointValue","current","bindPoint","valueFields","push","Math","inferredDate","Date","axisType","Error","appendAxis","xAxesOptions","xAxes","yAxesOptions","yAxes","idx","axisPane","findPane","_dispatchEvent","e","eventType","coords","_eventCoordinates","point","x","y","allAxes","axes","xValues","yValues","values","currentValue","getValue","trigger","element","originalEvent","updateAxisOptions","groupAxes","index","indexOf","originalOptions","seriesValues","bind","trendline","result","pointIx","data","targetOptions","prototype"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/chart/plotarea/xy-plotarea.js"],"sourcesContent":["import PlotAreaBase from './plotarea-base';\nimport AxisGroupRangeTracker from '../axis-group-range-tracker';\nimport PlotAreaEventsMixin from '../mixins/plotarea-events-mixin';\nimport ScatterChart from '../scatter-charts/scatter-chart';\nimport ScatterLineChart from '../scatter-charts/scatter-line-chart';\nimport BubbleChart from '../bubble-chart/bubble-chart';\nimport SeriesBinder from '../series-binder';\nimport trendlineFactory from '../trendlines/trendline-factory';\nimport scatterTrendlineRegistry from '../trendlines/scatter-trendline-registry';\n\nimport { NumericAxis, LogarithmicAxis, DateValueAxis, Point } from '../../core';\n\nimport { filterSeriesByType, equalsIgnoreCase, singleItemOrArray } from '../utils';\n\nimport { SCATTER, SCATTER_LINE, BUBBLE, LOGARITHMIC } from '../constants';\n\nimport { DATE } from '../../common/constants';\nimport { deepExtend, eventElement, grep, inArray, setDefaultOptions } from '../../common';\n\nclass XYPlotArea extends PlotAreaBase {\n    initFields() {\n        this.namedXAxes = {};\n        this.namedYAxes = {};\n\n        this.xAxisRangeTracker = new AxisGroupRangeTracker();\n        this.yAxisRangeTracker = new AxisGroupRangeTracker();\n    }\n\n    render(panes = this.panes) {\n        this.series = [...this.originalSeries];\n        this.createTrendlineSeries();\n\n        const seriesByPane = this.groupSeriesByPane();\n        for (let i = 0; i < panes.length; i++) {\n            const pane = panes[i];\n            const paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n            this.addToLegend(paneSeries);\n            const filteredSeries = this.filterVisibleSeries(paneSeries);\n\n            if (!filteredSeries) {\n                continue;\n            }\n\n            this.createScatterChart(\n                filterSeriesByType(filteredSeries, SCATTER),\n                pane\n            );\n\n            this.createScatterLineChart(\n                filterSeriesByType(filteredSeries, SCATTER_LINE),\n                pane\n            );\n\n            this.createBubbleChart(\n                filterSeriesByType(filteredSeries, BUBBLE),\n                pane\n            );\n        }\n\n        this.createAxes(panes);\n    }\n\n    appendChart(chart, pane) {\n        this.xAxisRangeTracker.update(chart.xAxisRanges);\n        this.yAxisRangeTracker.update(chart.yAxisRanges);\n\n        super.appendChart(chart, pane);\n    }\n\n    removeAxis(axis) {\n        const axisName = axis.options.name;\n\n        super.removeAxis(axis);\n\n        if (axis.options.vertical) {\n            this.yAxisRangeTracker.reset(axisName);\n            delete this.namedYAxes[axisName];\n        } else {\n            this.xAxisRangeTracker.reset(axisName);\n            delete this.namedXAxes[axisName];\n        }\n\n        if (axis === this.axisX) {\n            delete this.axisX;\n        }\n\n        if (axis === this.axisY) {\n            delete this.axisY;\n        }\n    }\n\n    // TODO: Refactor, optionally use series.pane option\n    seriesPaneName(series) {\n        const options = this.options;\n        const xAxisName = series.xAxis;\n        const xAxisOptions = [].concat(options.xAxis);\n        const xAxis = grep(xAxisOptions, function(a) { return a.name === xAxisName; })[0];\n        const yAxisName = series.yAxis;\n        const yAxisOptions = [].concat(options.yAxis);\n        const yAxis = grep(yAxisOptions, function(a) { return a.name === yAxisName; })[0];\n        const panes = options.panes || [ {} ];\n        const defaultPaneName = panes[0].name || \"default\";\n        const paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;\n\n        return paneName;\n    }\n\n    createScatterChart(series, pane) {\n        if (series.length > 0) {\n            this.appendChart(\n                new ScatterChart(this, { series: series, clip: pane.options.clip }),\n                pane\n            );\n        }\n    }\n\n    createScatterLineChart(series, pane) {\n        if (series.length > 0) {\n            this.appendChart(\n                new ScatterLineChart(this, { series: series, clip: pane.options.clip }),\n                pane\n            );\n        }\n    }\n\n    createBubbleChart(series, pane) {\n        if (series.length > 0) {\n            this.appendChart(\n                new BubbleChart(this, { series: series, clip: pane.options.clip }),\n                pane\n            );\n        }\n    }\n\n    createXYAxis(options, vertical, axisIndex) {\n        const axisName = options.name;\n        const namedAxes = vertical ? this.namedYAxes : this.namedXAxes;\n        const tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;\n        const axisOptions = deepExtend({ reverse: !vertical && this.chartService.rtl }, options, { vertical: vertical });\n        const isLog = equalsIgnoreCase(axisOptions.type, LOGARITHMIC);\n        const defaultRange = tracker.query();\n        const defaultAxisRange = isLog ? { min: 0.1, max: 1 } : { min: 0, max: 1 };\n        const range = tracker.query(axisName) || defaultRange || defaultAxisRange;\n        const typeSamples = [ axisOptions.min, axisOptions.max ];\n        const series = this.series;\n\n        for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {\n            const currentSeries = series[seriesIx];\n            const seriesAxisName = currentSeries[vertical ? \"yAxis\" : \"xAxis\"];\n            if ((seriesAxisName === axisOptions.name) || (axisIndex === 0 && !seriesAxisName)) {\n                const firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;\n                typeSamples.push(firstPointValue[vertical ? \"y\" : \"x\"]);\n\n                break;\n            }\n        }\n\n        if (axisIndex === 0 && defaultRange) {\n            range.min = Math.min(range.min, defaultRange.min);\n            range.max = Math.max(range.max, defaultRange.max);\n        }\n\n        let inferredDate;\n\n        for (let i = 0; i < typeSamples.length; i++) {\n            if (typeSamples[i] instanceof Date) {\n                inferredDate = true;\n                break;\n            }\n        }\n\n        let axisType;\n        if (equalsIgnoreCase(axisOptions.type, DATE) || (!axisOptions.type && inferredDate)) {\n            axisType = DateValueAxis;\n        } else if (isLog) {\n            axisType = LogarithmicAxis;\n        } else {\n            axisType = NumericAxis;\n        }\n\n        const axis = new axisType(range.min, range.max, axisOptions, this.chartService);\n        axis.axisIndex = axisIndex;\n\n        if (axisName) {\n            if (namedAxes[axisName]) {\n                throw new Error(`${ vertical ? \"Y\" : \"X\" } axis with name ${ axisName } is already defined`);\n            }\n            namedAxes[axisName] = axis;\n        }\n\n        this.appendAxis(axis);\n\n        return axis;\n    }\n\n    createAxes(panes) {\n        const options = this.options;\n        const xAxesOptions = [].concat(options.xAxis);\n        const xAxes = [];\n        const yAxesOptions = [].concat(options.yAxis);\n        const yAxes = [];\n\n        for (let idx = 0; idx < xAxesOptions.length; idx++) {\n            const axisPane = this.findPane(xAxesOptions[idx].pane);\n            if (inArray(axisPane, panes)) {\n                xAxes.push(this.createXYAxis(xAxesOptions[idx], false, idx));\n            }\n        }\n\n        for (let idx = 0; idx < yAxesOptions.length; idx++) {\n            const axisPane = this.findPane(yAxesOptions[idx].pane);\n            if (inArray(axisPane, panes)) {\n                yAxes.push(this.createXYAxis(yAxesOptions[idx], true, idx));\n            }\n        }\n\n        this.axisX = this.axisX || xAxes[0];\n        this.axisY = this.axisY || yAxes[0];\n    }\n\n    _dispatchEvent(chart, e, eventType) {\n        const coords = chart._eventCoordinates(e);\n        const point = new Point(coords.x, coords.y);\n        const allAxes = this.axes;\n        const length = allAxes.length;\n        const xValues = [];\n        const yValues = [];\n\n        for (let i = 0; i < length; i++) {\n            const axis = allAxes[i];\n            const values = axis.options.vertical ? yValues : xValues;\n            const currentValue = axis.getValue(point);\n            if (currentValue !== null) {\n                values.push(currentValue);\n            }\n        }\n\n        if (xValues.length > 0 && yValues.length > 0) {\n            chart.trigger(eventType, {\n                element: eventElement(e),\n                originalEvent: e,\n                x: singleItemOrArray(xValues),\n                y: singleItemOrArray(yValues)\n            });\n        }\n    }\n\n    updateAxisOptions(axis, options) {\n        const vertical = axis.options.vertical;\n        const axes = this.groupAxes(this.panes);\n        const index = (vertical ? axes.y : axes.x).indexOf(axis);\n\n        updateAxisOptions(this.options, index, vertical, options);\n        updateAxisOptions(this.originalOptions, index, vertical, options);\n    }\n\n    trendlineFactory(options, series) {\n        const seriesValues = this.seriesValues.bind(this, series.index);\n\n        const trendline = trendlineFactory(scatterTrendlineRegistry, options.type, {\n            options,\n            seriesValues\n        });\n\n        if (trendline) {\n            // Inherit settings\n            trendline.xAxis = series.xAxis;\n            trendline.yAxis = series.yAxis;\n        }\n\n        return trendline;\n    }\n\n    seriesValues(seriesIx) {\n        const result = [];\n        const currentSeries = this.series[seriesIx];\n\n        for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {\n            const data = this.bindPoint(currentSeries, pointIx);\n            result.push({ pointIx, valueFields: data.valueFields });\n        }\n\n        return result;\n    }\n}\n\nfunction updateAxisOptions(targetOptions, axisIndex, vertical, options) {\n    const axisOptions = ([].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis))[axisIndex];\n    deepExtend(axisOptions, options);\n}\n\nsetDefaultOptions(XYPlotArea, {\n    xAxis: {},\n    yAxis: {}\n});\n\ndeepExtend(XYPlotArea.prototype, PlotAreaEventsMixin);\n\nexport default XYPlotArea;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}