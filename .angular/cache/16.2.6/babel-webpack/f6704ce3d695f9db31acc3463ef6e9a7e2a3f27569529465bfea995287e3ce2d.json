{"ast":null,"code":"import { geometry as geom } from '@progress/kendo-drawing';\nimport { X, Y } from '../common/constants';\nimport { Class, last, round } from '../common';\nconst WEIGHT = 0.333;\nconst EXTREMUM_ALLOWED_DEVIATION = 0.01;\nclass CurveProcessor extends Class {\n  constructor(closed) {\n    super();\n    this.closed = closed;\n  }\n  process(dataPoints) {\n    const points = dataPoints.slice(0);\n    const segments = [];\n    let closed = this.closed;\n    let length = points.length;\n    if (length > 2) {\n      this.removeDuplicates(0, points);\n      length = points.length;\n    }\n    if (length < 2 || length === 2 && points[0].equals(points[1])) {\n      return segments;\n    }\n    let p0 = points[0];\n    let p1 = points[1];\n    let p2 = points[2];\n    segments.push(new geom.Segment(p0));\n    while (p0.equals(points[length - 1])) {\n      closed = true;\n      points.pop();\n      length--;\n    }\n    if (length === 2) {\n      const tangent = this.tangent(p0, p1, X, Y);\n      last(segments).controlOut(this.firstControlPoint(tangent, p0, p1, X, Y));\n      segments.push(new geom.Segment(p1, this.secondControlPoint(tangent, p0, p1, X, Y)));\n      return segments;\n    }\n    let initialControlPoint, lastControlPoint;\n    if (closed) {\n      p0 = points[length - 1];\n      p1 = points[0];\n      p2 = points[1];\n      const controlPoints = this.controlPoints(p0, p1, p2);\n      initialControlPoint = controlPoints[1];\n      lastControlPoint = controlPoints[0];\n    } else {\n      const tangent = this.tangent(p0, p1, X, Y);\n      initialControlPoint = this.firstControlPoint(tangent, p0, p1, X, Y);\n    }\n    let cp0 = initialControlPoint;\n    for (let idx = 0; idx <= length - 3; idx++) {\n      this.removeDuplicates(idx, points);\n      length = points.length;\n      if (idx + 3 <= length) {\n        p0 = points[idx];\n        p1 = points[idx + 1];\n        p2 = points[idx + 2];\n        const controlPoints = this.controlPoints(p0, p1, p2);\n        last(segments).controlOut(cp0);\n        cp0 = controlPoints[1];\n        const cp1 = controlPoints[0];\n        segments.push(new geom.Segment(p1, cp1));\n      }\n    }\n    if (closed) {\n      p0 = points[length - 2];\n      p1 = points[length - 1];\n      p2 = points[0];\n      const controlPoints = this.controlPoints(p0, p1, p2);\n      last(segments).controlOut(cp0);\n      segments.push(new geom.Segment(p1, controlPoints[0]));\n      last(segments).controlOut(controlPoints[1]);\n      segments.push(new geom.Segment(p2, lastControlPoint));\n    } else {\n      const tangent = this.tangent(p1, p2, X, Y);\n      last(segments).controlOut(cp0);\n      segments.push(new geom.Segment(p2, this.secondControlPoint(tangent, p1, p2, X, Y)));\n    }\n    return segments;\n  }\n  removeDuplicates(idx, points) {\n    while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n      points.splice(idx + 1, 1);\n    }\n  }\n  invertAxis(p0, p1, p2) {\n    let invertAxis = false;\n    if (p0.x === p1.x) {\n      invertAxis = true;\n    } else if (p1.x === p2.x) {\n      if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {\n        invertAxis = true;\n      }\n    } else {\n      const fn = this.lineFunction(p0, p1);\n      const y2 = this.calculateFunction(fn, p2.x);\n      if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {\n        invertAxis = true;\n      }\n    }\n    return invertAxis;\n  }\n  isLine(p0, p1, p2) {\n    const fn = this.lineFunction(p0, p1);\n    const y2 = this.calculateFunction(fn, p2.x);\n    return p0.x === p1.x && p1.x === p2.x || round(y2, 1) === round(p2.y, 1);\n  }\n  lineFunction(p1, p2) {\n    const a = (p2.y - p1.y) / (p2.x - p1.x);\n    const b = p1.y - a * p1.x;\n    return [b, a];\n  }\n  controlPoints(p0, p1, p2) {\n    let xField = X;\n    let yField = Y;\n    let restrict = false;\n    let switchOrientation = false;\n    let tangent;\n    if (this.isLine(p0, p1, p2)) {\n      tangent = this.tangent(p0, p1, X, Y);\n    } else {\n      const monotonic = {\n        x: this.isMonotonicByField(p0, p1, p2, X),\n        y: this.isMonotonicByField(p0, p1, p2, Y)\n      };\n      if (monotonic.x && monotonic.y) {\n        tangent = this.tangent(p0, p2, X, Y);\n        restrict = true;\n      } else {\n        if (this.invertAxis(p0, p1, p2)) {\n          xField = Y;\n          yField = X;\n        }\n        if (monotonic[xField]) {\n          tangent = 0;\n        } else {\n          let sign;\n          if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {\n            sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n          } else {\n            sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n          }\n          tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n          switchOrientation = true;\n        }\n      }\n    }\n    const secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\n    if (switchOrientation) {\n      const oldXField = xField;\n      xField = yField;\n      yField = oldXField;\n    }\n    const firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\n    if (restrict) {\n      this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\n      this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\n    }\n    return [secondControlPoint, firstControlPoint];\n  }\n  restrictControlPoint(p1, p2, cp, tangent) {\n    if (p1.y < p2.y) {\n      if (p2.y < cp.y) {\n        cp.x = p1.x + (p2.y - p1.y) / tangent;\n        cp.y = p2.y;\n      } else if (cp.y < p1.y) {\n        cp.x = p2.x - (p2.y - p1.y) / tangent;\n        cp.y = p1.y;\n      }\n    } else {\n      if (cp.y < p2.y) {\n        cp.x = p1.x - (p1.y - p2.y) / tangent;\n        cp.y = p2.y;\n      } else if (p1.y < cp.y) {\n        cp.x = p2.x + (p1.y - p2.y) / tangent;\n        cp.y = p1.y;\n      }\n    }\n  }\n  tangent(p0, p1, xField, yField) {\n    const x = p1[xField] - p0[xField];\n    const y = p1[yField] - p0[yField];\n    let tangent;\n    if (x === 0) {\n      tangent = 0;\n    } else {\n      tangent = y / x;\n    }\n    return tangent;\n  }\n  isMonotonicByField(p0, p1, p2, field) {\n    return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];\n  }\n  firstControlPoint(tangent, p0, p3, xField, yField) {\n    const t1 = p0[xField];\n    const t2 = p3[xField];\n    const distance = (t2 - t1) * WEIGHT;\n    return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n  }\n  secondControlPoint(tangent, p0, p3, xField, yField) {\n    const t1 = p0[xField];\n    const t2 = p3[xField];\n    const distance = (t2 - t1) * WEIGHT;\n    return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n  }\n  point(xValue, yValue, xField, yField) {\n    const controlPoint = new geom.Point();\n    controlPoint[xField] = xValue;\n    controlPoint[yField] = yValue;\n    return controlPoint;\n  }\n  calculateFunction(fn, x) {\n    const length = fn.length;\n    let result = 0;\n    for (let i = 0; i < length; i++) {\n      result += Math.pow(x, i) * fn[i];\n    }\n    return result;\n  }\n}\nfunction numberSign(value) {\n  return value <= 0 ? -1 : 1;\n}\nexport default CurveProcessor;","map":{"version":3,"names":["geometry","geom","X","Y","Class","last","round","WEIGHT","EXTREMUM_ALLOWED_DEVIATION","CurveProcessor","constructor","closed","process","dataPoints","points","slice","segments","length","removeDuplicates","equals","p0","p1","p2","push","Segment","pop","tangent","controlOut","firstControlPoint","secondControlPoint","initialControlPoint","lastControlPoint","controlPoints","cp0","idx","cp1","splice","invertAxis","x","y","fn","lineFunction","y2","calculateFunction","isLine","a","b","xField","yField","restrict","switchOrientation","monotonic","isMonotonicByField","sign","numberSign","oldXField","restrictControlPoint","cp","field","p3","t1","t2","distance","point","xValue","yValue","controlPoint","Point","result","i","Math","pow","value"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-charts/dist/es2015/core/curve-processor.js"],"sourcesContent":["import { geometry as geom } from '@progress/kendo-drawing';\n\nimport { X, Y } from '../common/constants';\nimport { Class, last, round } from '../common';\n\nconst WEIGHT = 0.333;\nconst EXTREMUM_ALLOWED_DEVIATION = 0.01;\n\nclass CurveProcessor extends Class {\n\n    constructor(closed) {\n        super();\n\n        this.closed = closed;\n    }\n\n    process(dataPoints) {\n        const points = dataPoints.slice(0);\n        const segments = [];\n        let closed = this.closed;\n        let length = points.length;\n\n        if (length > 2) {\n            this.removeDuplicates(0, points);\n            length = points.length;\n        }\n\n        if (length < 2 || (length === 2 && points[0].equals(points[1]))) {\n            return segments;\n        }\n\n        let p0 = points[0];\n        let p1 = points[1];\n        let p2 = points[2];\n\n        segments.push(new geom.Segment(p0));\n\n        while (p0.equals(points[length - 1])) {\n            closed = true;\n            points.pop();\n            length--;\n        }\n\n        if (length === 2) {\n            const tangent = this.tangent(p0,p1, X, Y);\n\n            last(segments).controlOut(\n                this.firstControlPoint(tangent, p0, p1, X, Y)\n            );\n\n            segments.push(new geom.Segment(\n                p1,\n                this.secondControlPoint(tangent, p0, p1, X, Y)\n            ));\n\n            return segments;\n        }\n\n        let initialControlPoint, lastControlPoint;\n\n        if (closed) {\n            p0 = points[length - 1]; p1 = points[0]; p2 = points[1];\n            const controlPoints = this.controlPoints(p0, p1, p2);\n            initialControlPoint = controlPoints[1];\n            lastControlPoint = controlPoints[0];\n        } else {\n            const tangent = this.tangent(p0, p1, X,Y);\n            initialControlPoint = this.firstControlPoint(tangent, p0, p1, X, Y);\n        }\n\n        let cp0 = initialControlPoint;\n        for (let idx = 0; idx <= length - 3; idx++) {\n            this.removeDuplicates(idx, points);\n            length = points.length;\n            if (idx + 3 <= length) {\n                p0 = points[idx]; p1 = points[idx + 1]; p2 = points[idx + 2];\n                const controlPoints = this.controlPoints(p0,p1,p2);\n\n                last(segments).controlOut(cp0);\n                cp0 = controlPoints[1];\n\n                const cp1 = controlPoints[0];\n                segments.push(new geom.Segment(p1, cp1));\n            }\n        }\n\n        if (closed) {\n            p0 = points[length - 2]; p1 = points[length - 1]; p2 = points[0];\n            const controlPoints = this.controlPoints(p0, p1, p2);\n\n            last(segments).controlOut(cp0);\n            segments.push(new geom.Segment(\n                p1,\n                controlPoints[0]\n            ));\n\n            last(segments).controlOut(controlPoints[1]);\n            segments.push(new geom.Segment(\n                p2,\n                lastControlPoint\n            ));\n        } else {\n            const tangent = this.tangent(p1, p2, X, Y);\n\n            last(segments).controlOut(cp0);\n            segments.push(new geom.Segment(\n                p2,\n                this.secondControlPoint(tangent, p1, p2, X, Y)\n            ));\n        }\n\n        return segments;\n    }\n\n    removeDuplicates(idx, points) {\n        while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n            points.splice(idx + 1, 1);\n        }\n    }\n\n    invertAxis(p0, p1, p2) {\n        let invertAxis = false;\n\n        if (p0.x === p1.x) {\n            invertAxis = true;\n        } else if (p1.x === p2.x) {\n            if ((p1.y < p2.y && p0.y <= p1.y) || (p2.y < p1.y && p1.y <= p0.y)) {\n                invertAxis = true;\n            }\n        } else {\n            const fn = this.lineFunction(p0,p1);\n            const y2 = this.calculateFunction(fn, p2.x);\n            if (!(p0.y <= p1.y && p2.y <= y2) &&\n                !(p1.y <= p0.y && p2.y >= y2)) {\n                invertAxis = true;\n            }\n        }\n\n        return invertAxis;\n    }\n\n    isLine(p0, p1, p2) {\n        const fn = this.lineFunction(p0, p1);\n        const y2 = this.calculateFunction(fn, p2.x);\n\n        return (p0.x === p1.x && p1.x === p2.x) || round(y2, 1) === round(p2.y, 1);\n    }\n\n    lineFunction(p1, p2) {\n        const a = (p2.y - p1.y) / (p2.x - p1.x);\n        const b = p1.y - a * p1.x;\n\n        return [ b, a ];\n    }\n\n    controlPoints(p0, p1, p2) {\n        let xField = X;\n        let yField = Y;\n        let restrict = false;\n        let switchOrientation = false;\n        let tangent;\n\n        if (this.isLine(p0, p1, p2)) {\n            tangent = this.tangent(p0, p1, X, Y);\n        } else {\n            const monotonic = {\n                x: this.isMonotonicByField(p0, p1, p2, X),\n                y: this.isMonotonicByField(p0, p1, p2, Y)\n            };\n\n            if (monotonic.x && monotonic.y) {\n                tangent = this.tangent(p0, p2, X, Y);\n                restrict = true;\n            } else {\n                if (this.invertAxis(p0, p1, p2)) {\n                    xField = Y;\n                    yField = X;\n                }\n\n                if (monotonic[xField]) {\n                    tangent = 0;\n                } else {\n                    let sign;\n                    if ((p2[yField] < p0[yField] && p0[yField] <= p1[yField]) ||\n                        (p0[yField] < p2[yField] && p1[yField] <= p0[yField])) {\n                        sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n                    } else {\n                        sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n                    }\n\n                    tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n                    switchOrientation = true;\n                }\n            }\n        }\n\n        const secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);\n\n        if (switchOrientation) {\n            const oldXField = xField;\n            xField = yField;\n            yField = oldXField;\n        }\n\n        const firstControlPoint = this.firstControlPoint(tangent, p1, p2, xField, yField);\n\n        if (restrict) {\n            this.restrictControlPoint(p0, p1, secondControlPoint, tangent);\n            this.restrictControlPoint(p1, p2, firstControlPoint, tangent);\n        }\n\n        return [ secondControlPoint, firstControlPoint ];\n    }\n\n    restrictControlPoint(p1, p2, cp, tangent) {\n        if (p1.y < p2.y) {\n            if (p2.y < cp.y) {\n                cp.x = p1.x + (p2.y - p1.y) / tangent;\n                cp.y = p2.y;\n            } else if (cp.y < p1.y) {\n                cp.x = p2.x - (p2.y - p1.y) / tangent;\n                cp.y = p1.y;\n            }\n        } else {\n            if (cp.y < p2.y) {\n                cp.x = p1.x - (p1.y - p2.y) / tangent;\n                cp.y = p2.y;\n            } else if (p1.y < cp.y) {\n                cp.x = p2.x + (p1.y - p2.y) / tangent;\n                cp.y = p1.y;\n            }\n        }\n    }\n\n    tangent(p0, p1, xField, yField) {\n        const x = p1[xField] - p0[xField];\n        const y = p1[yField] - p0[yField];\n        let tangent;\n\n        if (x === 0) {\n            tangent = 0;\n        } else {\n            tangent = y / x;\n        }\n\n        return tangent;\n    }\n\n    isMonotonicByField(p0, p1, p2, field) {\n        return (p2[field] > p1[field] && p1[field] > p0[field]) ||\n                    (p2[field] < p1[field] && p1[field] < p0[field]);\n    }\n\n    firstControlPoint(tangent, p0, p3, xField, yField) {\n        const t1 = p0[xField];\n        const t2 = p3[xField];\n        const distance = (t2 - t1) * WEIGHT;\n\n        return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n    }\n\n    secondControlPoint(tangent, p0, p3, xField, yField) {\n        const t1 = p0[xField];\n        const t2 = p3[xField];\n        const distance = (t2 - t1) * WEIGHT;\n\n        return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n    }\n\n    point(xValue, yValue, xField, yField) {\n        const controlPoint = new geom.Point();\n        controlPoint[xField] = xValue;\n        controlPoint[yField] = yValue;\n\n        return controlPoint;\n    }\n\n    calculateFunction(fn, x) {\n        const length = fn.length;\n        let result = 0;\n\n        for (let i = 0; i < length; i++) {\n            result += Math.pow(x,i) * fn[i];\n        }\n        return result;\n    }\n}\n\nfunction numberSign(value) {\n    return value <= 0 ? -1 : 1;\n}\n\nexport default CurveProcessor;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}