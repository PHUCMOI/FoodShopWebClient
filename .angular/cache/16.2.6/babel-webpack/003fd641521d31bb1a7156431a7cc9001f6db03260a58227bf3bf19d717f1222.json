{"ast":null,"code":"import { isPresent, isNumeric, isDate } from './utils';\nimport { getter } from './accessor';\nconst valueToString = value => {\n  value = isPresent(value) && value.getTime ? value.getTime() : value;\n  return value + \"\";\n};\n/**\n * @hidden\n */\nexport const groupCombinator = field => {\n  const prop = getter(field, true);\n  let position = 0;\n  return (agg, value) => {\n    agg[field] = agg[field] || {};\n    const groupValue = prop(value);\n    const key = valueToString(groupValue);\n    const values = agg[field][key] || {\n      __position: position++,\n      aggregates: {},\n      items: [],\n      value: groupValue\n    };\n    values.items.push(value);\n    agg[field][key] = values;\n    return agg;\n  };\n};\n/**\n * @hidden\n */\nexport const expandAggregates = (result = {}) => {\n  Object.keys(result).forEach(field => {\n    const aggregates = result[field];\n    Object.keys(aggregates).forEach(aggregate => {\n      aggregates[aggregate] = aggregates[aggregate].result();\n    });\n  });\n  return result;\n};\nconst aggregatesFuncs = name => ({\n  average: () => {\n    let value = 0;\n    let count = 0;\n    return {\n      calc: curr => {\n        if (isNumeric(curr)) {\n          value += curr;\n          count++;\n        } else {\n          value = curr;\n        }\n      },\n      result: () => isNumeric(value) ? value / count : value\n    };\n  },\n  count: () => {\n    let state = 0;\n    return {\n      calc: () => state++,\n      result: () => state\n    };\n  },\n  max: () => {\n    let state = Number.NEGATIVE_INFINITY;\n    return {\n      calc: value => {\n        state = isNumeric(state) || isDate(state) ? state : value;\n        if (state < value && (isNumeric(value) || isDate(value))) {\n          state = value;\n        }\n      },\n      result: () => state\n    };\n  },\n  min: () => {\n    let state = Number.POSITIVE_INFINITY;\n    return {\n      calc: value => {\n        state = isNumeric(state) || isDate(state) ? state : value;\n        if (state > value && (isNumeric(value) || isDate(value))) {\n          state = value;\n        }\n      },\n      result: () => state\n    };\n  },\n  sum: () => {\n    let state = 0;\n    return {\n      calc: value => {\n        value = isPresent(value) ? value : 0;\n        state += value;\n      },\n      result: () => state\n    };\n  }\n})[name]();\n/**\n * @hidden\n */\nexport const aggregatesCombinator = descriptors => {\n  const functions = descriptors.map(descriptor => {\n    const fieldAccessor = getter(descriptor.field, true);\n    const aggregateName = (descriptor.aggregate || \"\").toLowerCase();\n    const aggregateAccessor = getter(aggregateName, true);\n    return (state, value) => {\n      const fieldAggregates = state[descriptor.field] || {};\n      const aggregateFunction = aggregateAccessor(fieldAggregates) || aggregatesFuncs(aggregateName);\n      aggregateFunction.calc(fieldAccessor(value));\n      fieldAggregates[descriptor.aggregate] = aggregateFunction;\n      state[descriptor.field] = fieldAggregates;\n      return state;\n    };\n  });\n  return (state, value) => functions.reduce((agg, calc) => calc(agg, value), state);\n};\n/**\n * @hidden\n * Adds the value to the `arr` and produces a new array.\n *\n * > The original array will be modified.\n */\nexport const concat = (arr, value) => {\n  arr.push(value);\n  return arr;\n};\n/**\n * @hidden\n * Returns a reducer that will apply the specified transformation to the value.\n */\nexport const map = transform => reduce => (acc, curr, index) => reduce(acc, transform(curr, index));\n/**\n * @hidden\n * Returns a reducer that will filter out items which do not match the `Predicate`.\n */\nexport const filter = predicate => reduce => (acc, curr) => predicate(curr) ? reduce(acc, curr) : acc;\n/**\n * @hidden\n */\nexport const isTransformerResult = source => {\n  return isPresent(source.__value);\n};\nconst reduced = x => {\n  if (isTransformerResult(x)) {\n    return x;\n  }\n  return {\n    __value: x,\n    reduced: true\n  };\n};\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport const take = count => reduce => (acc, curr) => count-- > 0 ? reduce(acc, curr) : reduced(acc);\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport const takeWhile = predicate => reduce => (acc, curr) => predicate(curr) ? reduce(acc, curr) : reduced(acc);\n/**\n * @hidden\n * Returns a reducer that will skip the specified number of items.\n */\nexport const skip = count => reduce => (acc, curr) => count-- <= 0 ? reduce(acc, curr) : acc;\n/**\n * @hidden\n * Transforms the data by applying the supplied transformer.\n */\nexport const exec = (transform, initialValue, data) => {\n  let result = initialValue;\n  for (let idx = 0, length = data.length; idx < length; idx++) {\n    result = transform(result, data[idx], idx);\n    if (isTransformerResult(result)) {\n      result = result.__value;\n      break;\n    }\n  }\n  return result;\n};","map":{"version":3,"names":["isPresent","isNumeric","isDate","getter","valueToString","value","getTime","groupCombinator","field","prop","position","agg","groupValue","key","values","__position","aggregates","items","push","expandAggregates","result","Object","keys","forEach","aggregate","aggregatesFuncs","name","average","count","calc","curr","state","max","Number","NEGATIVE_INFINITY","min","POSITIVE_INFINITY","sum","aggregatesCombinator","descriptors","functions","map","descriptor","fieldAccessor","aggregateName","toLowerCase","aggregateAccessor","fieldAggregates","aggregateFunction","reduce","concat","arr","transform","acc","index","filter","predicate","isTransformerResult","source","__value","reduced","x","take","takeWhile","skip","exec","initialValue","data","idx","length"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-data-query/dist/es2015/transducers.js"],"sourcesContent":["import { isPresent, isNumeric, isDate } from './utils';\nimport { getter } from './accessor';\nconst valueToString = (value) => {\n    value = isPresent(value) && value.getTime ? value.getTime() : value;\n    return value + \"\";\n};\n/**\n * @hidden\n */\nexport const groupCombinator = (field) => {\n    const prop = getter(field, true);\n    let position = 0;\n    return (agg, value) => {\n        agg[field] = agg[field] || {};\n        const groupValue = prop(value);\n        const key = valueToString(groupValue);\n        const values = agg[field][key] || { __position: position++, aggregates: {}, items: [], value: groupValue };\n        values.items.push(value);\n        agg[field][key] = values;\n        return agg;\n    };\n};\n/**\n * @hidden\n */\nexport const expandAggregates = (result = {}) => {\n    Object.keys(result).forEach(field => {\n        const aggregates = result[field];\n        Object.keys(aggregates).forEach(aggregate => {\n            aggregates[aggregate] = aggregates[aggregate].result();\n        });\n    });\n    return result;\n};\nconst aggregatesFuncs = (name) => ({\n    average: () => {\n        let value = 0;\n        let count = 0;\n        return {\n            calc: (curr) => {\n                if (isNumeric(curr)) {\n                    value += curr;\n                    count++;\n                }\n                else {\n                    value = curr;\n                }\n            },\n            result: () => isNumeric(value) ? value / count : value\n        };\n    },\n    count: () => {\n        let state = 0;\n        return {\n            calc: () => state++,\n            result: () => state\n        };\n    },\n    max: () => {\n        let state = Number.NEGATIVE_INFINITY;\n        return {\n            calc: (value) => {\n                state = isNumeric(state) || isDate(state) ? state : value;\n                if (state < value && (isNumeric(value) || isDate(value))) {\n                    state = value;\n                }\n            },\n            result: () => state\n        };\n    },\n    min: () => {\n        let state = Number.POSITIVE_INFINITY;\n        return {\n            calc: (value) => {\n                state = isNumeric(state) || isDate(state) ? state : value;\n                if (state > value && (isNumeric(value) || isDate(value))) {\n                    state = value;\n                }\n            },\n            result: () => state\n        };\n    },\n    sum: () => {\n        let state = 0;\n        return {\n            calc: (value) => {\n                value = isPresent(value) ? value : 0;\n                state += value;\n            },\n            result: () => state\n        };\n    }\n}[name]());\n/**\n * @hidden\n */\nexport const aggregatesCombinator = (descriptors) => {\n    const functions = descriptors.map(descriptor => {\n        const fieldAccessor = getter(descriptor.field, true);\n        const aggregateName = (descriptor.aggregate || \"\").toLowerCase();\n        const aggregateAccessor = getter(aggregateName, true);\n        return (state, value) => {\n            const fieldAggregates = state[descriptor.field] || {};\n            const aggregateFunction = aggregateAccessor(fieldAggregates)\n                || aggregatesFuncs(aggregateName);\n            aggregateFunction.calc(fieldAccessor(value));\n            fieldAggregates[descriptor.aggregate] = aggregateFunction;\n            state[descriptor.field] = fieldAggregates;\n            return state;\n        };\n    });\n    return (state, value) => functions.reduce((agg, calc) => calc(agg, value), state);\n};\n/**\n * @hidden\n * Adds the value to the `arr` and produces a new array.\n *\n * > The original array will be modified.\n */\nexport const concat = (arr, value) => {\n    arr.push(value);\n    return arr;\n};\n/**\n * @hidden\n * Returns a reducer that will apply the specified transformation to the value.\n */\nexport const map = (transform) => ((reduce) => ((acc, curr, index) => reduce(acc, transform(curr, index))));\n/**\n * @hidden\n * Returns a reducer that will filter out items which do not match the `Predicate`.\n */\nexport const filter = (predicate) => ((reduce) => ((acc, curr) => predicate(curr) ? reduce(acc, curr) : acc));\n/**\n * @hidden\n */\nexport const isTransformerResult = (source) => {\n    return isPresent(source.__value);\n};\nconst reduced = (x) => {\n    if (isTransformerResult(x)) {\n        return x;\n    }\n    return {\n        __value: x,\n        reduced: true\n    };\n};\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport const take = (count) => ((reduce) => ((acc, curr) => count-- > 0 ? reduce(acc, curr) : reduced(acc)));\n/**\n * @hidden\n * Returns a reducer that will take the specified number of items.\n */\nexport const takeWhile = (predicate) => ((reduce) => ((acc, curr) => predicate(curr) ? reduce(acc, curr) : reduced(acc)));\n/**\n * @hidden\n * Returns a reducer that will skip the specified number of items.\n */\nexport const skip = (count) => ((reduce) => ((acc, curr) => count-- <= 0 ? reduce(acc, curr) : acc));\n/**\n * @hidden\n * Transforms the data by applying the supplied transformer.\n */\nexport const exec = (transform, initialValue, data) => {\n    let result = initialValue;\n    for (let idx = 0, length = data.length; idx < length; idx++) {\n        result = transform(result, data[idx], idx);\n        if (isTransformerResult(result)) {\n            result = result.__value;\n            break;\n        }\n    }\n    return result;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}