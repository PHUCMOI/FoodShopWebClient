{"ast":null,"code":"import LinearGradient from '../gradients/linear-gradient';\nimport RadialGradient from '../gradients/radial-gradient';\nimport LinearGradientNode from './linear-gradient-node';\nimport RadialGradientNode from './radial-gradient-node';\nimport Node from './node';\nimport ClipNode from './clip-node';\nclass DefinitionNode extends Node {\n  constructor() {\n    super();\n    this.definitionMap = {};\n  }\n  attachTo(domElement) {\n    this.element = domElement;\n  }\n  template() {\n    return `<defs>${this.renderChildren()}</defs>`;\n  }\n  definitionChange(e) {\n    const {\n      definitions,\n      action\n    } = e;\n    if (action === \"add\") {\n      this.addDefinitions(definitions);\n    } else if (action === \"remove\") {\n      this.removeDefinitions(definitions);\n    }\n  }\n  createDefinition(type, item) {\n    let nodeType;\n    if (type === \"clip\") {\n      nodeType = ClipNode;\n    } else if (type === \"fill\") {\n      if (item instanceof LinearGradient) {\n        nodeType = LinearGradientNode;\n      } else if (item instanceof RadialGradient) {\n        nodeType = RadialGradientNode;\n      }\n    }\n    return new nodeType(item);\n  }\n  addDefinitions(definitions) {\n    for (let field in definitions) {\n      this.addDefinition(field, definitions[field]);\n    }\n  }\n  addDefinition(type, srcElement) {\n    const {\n      element,\n      definitionMap\n    } = this;\n    const id = srcElement.id;\n    const mapItem = definitionMap[id];\n    if (!mapItem) {\n      const node = this.createDefinition(type, srcElement);\n      definitionMap[id] = {\n        element: node,\n        count: 1\n      };\n      this.append(node);\n      if (element) {\n        node.attachTo(this.element);\n      }\n    } else {\n      mapItem.count++;\n    }\n  }\n  removeDefinitions(definitions) {\n    for (let field in definitions) {\n      this.removeDefinition(definitions[field]);\n    }\n  }\n  removeDefinition(srcElement) {\n    const definitionMap = this.definitionMap;\n    const id = srcElement.id;\n    const mapItem = definitionMap[id];\n    if (mapItem) {\n      mapItem.count--;\n      if (mapItem.count === 0) {\n        this.remove(this.childNodes.indexOf(mapItem.element), 1);\n        delete definitionMap[id];\n      }\n    }\n  }\n}\nexport default DefinitionNode;","map":{"version":3,"names":["LinearGradient","RadialGradient","LinearGradientNode","RadialGradientNode","Node","ClipNode","DefinitionNode","constructor","definitionMap","attachTo","domElement","element","template","renderChildren","definitionChange","e","definitions","action","addDefinitions","removeDefinitions","createDefinition","type","item","nodeType","field","addDefinition","srcElement","id","mapItem","node","count","append","removeDefinition","remove","childNodes","indexOf"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-drawing/dist/es2015/svg/definition-node.js"],"sourcesContent":["import LinearGradient from '../gradients/linear-gradient';\nimport RadialGradient from '../gradients/radial-gradient';\nimport LinearGradientNode from './linear-gradient-node';\nimport RadialGradientNode from './radial-gradient-node';\nimport Node from './node';\nimport ClipNode from './clip-node';\n\nclass DefinitionNode extends Node {\n    constructor() {\n        super();\n        this.definitionMap = {};\n    }\n\n    attachTo(domElement) {\n        this.element = domElement;\n    }\n\n    template() {\n        return `<defs>${ this.renderChildren() }</defs>`;\n    }\n\n    definitionChange(e) {\n        const { definitions, action } = e;\n\n        if (action === \"add\") {\n            this.addDefinitions(definitions);\n        } else if (action === \"remove\") {\n            this.removeDefinitions(definitions);\n        }\n    }\n\n    createDefinition(type, item) {\n        let nodeType;\n        if (type === \"clip\") {\n            nodeType = ClipNode;\n        } else if (type === \"fill\") {\n            if (item instanceof LinearGradient) {\n                nodeType = LinearGradientNode;\n            } else if (item instanceof RadialGradient) {\n                nodeType = RadialGradientNode;\n            }\n        }\n        return new nodeType(item);\n    }\n\n    addDefinitions(definitions) {\n        for (let field in definitions) {\n            this.addDefinition(field, definitions[field]);\n        }\n    }\n\n    addDefinition(type, srcElement) {\n        const { element, definitionMap } = this;\n        const id = srcElement.id;\n        const mapItem = definitionMap[id];\n        if (!mapItem) {\n            const node = this.createDefinition(type, srcElement);\n            definitionMap[id] = {\n                element: node,\n                count: 1\n            };\n            this.append(node);\n            if (element) {\n                node.attachTo(this.element);\n            }\n        } else {\n            mapItem.count++;\n        }\n    }\n\n    removeDefinitions(definitions) {\n        for (let field in definitions) {\n            this.removeDefinition(definitions[field]);\n        }\n    }\n\n    removeDefinition(srcElement) {\n        const definitionMap = this.definitionMap;\n        const id = srcElement.id;\n        const mapItem = definitionMap[id];\n\n        if (mapItem) {\n            mapItem.count--;\n            if (mapItem.count === 0) {\n                this.remove(this.childNodes.indexOf(mapItem.element), 1);\n                delete definitionMap[id];\n            }\n        }\n    }\n}\n\nexport default DefinitionNode;"],"mappings":"AAAA,OAAOA,cAAc,MAAM,8BAA8B;AACzD,OAAOC,cAAc,MAAM,8BAA8B;AACzD,OAAOC,kBAAkB,MAAM,wBAAwB;AACvD,OAAOC,kBAAkB,MAAM,wBAAwB;AACvD,OAAOC,IAAI,MAAM,QAAQ;AACzB,OAAOC,QAAQ,MAAM,aAAa;AAElC,MAAMC,cAAc,SAASF,IAAI,CAAC;EAC9BG,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,aAAa,GAAG,CAAC,CAAC;EAC3B;EAEAC,QAAQA,CAACC,UAAU,EAAE;IACjB,IAAI,CAACC,OAAO,GAAGD,UAAU;EAC7B;EAEAE,QAAQA,CAAA,EAAG;IACP,OAAQ,SAAS,IAAI,CAACC,cAAc,CAAC,CAAG,SAAQ;EACpD;EAEAC,gBAAgBA,CAACC,CAAC,EAAE;IAChB,MAAM;MAAEC,WAAW;MAAEC;IAAO,CAAC,GAAGF,CAAC;IAEjC,IAAIE,MAAM,KAAK,KAAK,EAAE;MAClB,IAAI,CAACC,cAAc,CAACF,WAAW,CAAC;IACpC,CAAC,MAAM,IAAIC,MAAM,KAAK,QAAQ,EAAE;MAC5B,IAAI,CAACE,iBAAiB,CAACH,WAAW,CAAC;IACvC;EACJ;EAEAI,gBAAgBA,CAACC,IAAI,EAAEC,IAAI,EAAE;IACzB,IAAIC,QAAQ;IACZ,IAAIF,IAAI,KAAK,MAAM,EAAE;MACjBE,QAAQ,GAAGlB,QAAQ;IACvB,CAAC,MAAM,IAAIgB,IAAI,KAAK,MAAM,EAAE;MACxB,IAAIC,IAAI,YAAYtB,cAAc,EAAE;QAChCuB,QAAQ,GAAGrB,kBAAkB;MACjC,CAAC,MAAM,IAAIoB,IAAI,YAAYrB,cAAc,EAAE;QACvCsB,QAAQ,GAAGpB,kBAAkB;MACjC;IACJ;IACA,OAAO,IAAIoB,QAAQ,CAACD,IAAI,CAAC;EAC7B;EAEAJ,cAAcA,CAACF,WAAW,EAAE;IACxB,KAAK,IAAIQ,KAAK,IAAIR,WAAW,EAAE;MAC3B,IAAI,CAACS,aAAa,CAACD,KAAK,EAAER,WAAW,CAACQ,KAAK,CAAC,CAAC;IACjD;EACJ;EAEAC,aAAaA,CAACJ,IAAI,EAAEK,UAAU,EAAE;IAC5B,MAAM;MAAEf,OAAO;MAAEH;IAAc,CAAC,GAAG,IAAI;IACvC,MAAMmB,EAAE,GAAGD,UAAU,CAACC,EAAE;IACxB,MAAMC,OAAO,GAAGpB,aAAa,CAACmB,EAAE,CAAC;IACjC,IAAI,CAACC,OAAO,EAAE;MACV,MAAMC,IAAI,GAAG,IAAI,CAACT,gBAAgB,CAACC,IAAI,EAAEK,UAAU,CAAC;MACpDlB,aAAa,CAACmB,EAAE,CAAC,GAAG;QAChBhB,OAAO,EAAEkB,IAAI;QACbC,KAAK,EAAE;MACX,CAAC;MACD,IAAI,CAACC,MAAM,CAACF,IAAI,CAAC;MACjB,IAAIlB,OAAO,EAAE;QACTkB,IAAI,CAACpB,QAAQ,CAAC,IAAI,CAACE,OAAO,CAAC;MAC/B;IACJ,CAAC,MAAM;MACHiB,OAAO,CAACE,KAAK,EAAE;IACnB;EACJ;EAEAX,iBAAiBA,CAACH,WAAW,EAAE;IAC3B,KAAK,IAAIQ,KAAK,IAAIR,WAAW,EAAE;MAC3B,IAAI,CAACgB,gBAAgB,CAAChB,WAAW,CAACQ,KAAK,CAAC,CAAC;IAC7C;EACJ;EAEAQ,gBAAgBA,CAACN,UAAU,EAAE;IACzB,MAAMlB,aAAa,GAAG,IAAI,CAACA,aAAa;IACxC,MAAMmB,EAAE,GAAGD,UAAU,CAACC,EAAE;IACxB,MAAMC,OAAO,GAAGpB,aAAa,CAACmB,EAAE,CAAC;IAEjC,IAAIC,OAAO,EAAE;MACTA,OAAO,CAACE,KAAK,EAAE;MACf,IAAIF,OAAO,CAACE,KAAK,KAAK,CAAC,EAAE;QACrB,IAAI,CAACG,MAAM,CAAC,IAAI,CAACC,UAAU,CAACC,OAAO,CAACP,OAAO,CAACjB,OAAO,CAAC,EAAE,CAAC,CAAC;QACxD,OAAOH,aAAa,CAACmB,EAAE,CAAC;MAC5B;IACJ;EACJ;AACJ;AAEA,eAAerB,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}