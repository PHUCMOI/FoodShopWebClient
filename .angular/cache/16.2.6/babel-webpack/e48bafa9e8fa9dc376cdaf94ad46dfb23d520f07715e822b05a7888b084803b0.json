{"ast":null,"code":"import { isCompositeFilterDescriptor } from './filtering/filter-descriptor.interface';\nimport { compose, ifElse } from './funcs';\nimport { normalizeField, quote, toLower, isDateValue, isStringValue, serializeFilters, encodeValue, toUTC } from './filter-serialization.common';\nimport { normalizeFilters } from './filtering/filter.operators';\nconst formatDate = ({\n  utcDates\n}) => ({\n  field,\n  value,\n  ignoreCase,\n  operator\n}) => ({\n  value: (!utcDates ? toUTC(value) : value).toISOString(),\n  field,\n  ignoreCase,\n  operator\n});\nconst fnFormatter = ({\n  operator\n}) => ({\n  field,\n  value\n}) => `${operator}(${field},${value})`;\nconst singleOperatorFormatter = ({\n  operator\n}) => ({\n  field,\n  value\n}) => `${field} ${operator} ${value}`;\nconst stringFormat = formatter => compose(formatter, encodeValue, quote, toLower, normalizeField);\nconst stringFnOperator = settings => stringFormat(fnFormatter(settings));\nconst stringOperator = settings => stringFormat(singleOperatorFormatter(settings));\nconst numericOperator = settings => compose(singleOperatorFormatter(settings), normalizeField);\nconst dateOperator = settings => compose(singleOperatorFormatter(settings), normalizeField, formatDate(settings));\nconst ifDate = settings => ifElse(isDateValue, dateOperator(settings), numericOperator(settings));\nconst typedOperator = settings => ifElse(isStringValue, stringOperator(settings), ifDate(settings));\nconst appendEqual = str => `${str} eq -1`;\nconst nonValueExpression = formatter => compose(formatter, normalizeField);\nconst filterOperators = (operator, settings) => ({\n  contains: stringFnOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"contains\"\n  })),\n  doesnotcontain: compose(appendEqual, stringFnOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"indexof\"\n  }))),\n  endswith: stringFnOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"endswith\"\n  })),\n  eq: typedOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"eq\"\n  })),\n  gt: typedOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"gt\"\n  })),\n  gte: typedOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"ge\"\n  })),\n  isempty: nonValueExpression(({\n    field\n  }) => `${field} eq ''`),\n  isnotempty: nonValueExpression(({\n    field\n  }) => `${field} ne ''`),\n  isnotnull: nonValueExpression(({\n    field\n  }) => `${field} ne null`),\n  isnull: nonValueExpression(({\n    field\n  }) => `${field} eq null`),\n  lt: typedOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"lt\"\n  })),\n  lte: typedOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"le\"\n  })),\n  neq: typedOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"ne\"\n  })),\n  startswith: stringFnOperator(Object.assign(Object.assign({}, settings), {\n    operator: \"startswith\"\n  }))\n})[operator];\nconst join = x => ` ${x.logic} `;\nconst serialize = settings => x => filterOperators(x.operator, settings)(x);\nconst serializeAll = settings => serializeFilters(filter => ifElse(isCompositeFilterDescriptor, serializeAll(settings), serialize(settings))(filter), join);\n/**\n * @hidden\n */\nexport const serializeFilter = (filter, settings = {}) => {\n  if (filter.filters && filter.filters.length) {\n    return \"$filter=\" + serializeAll(settings)(normalizeFilters(filter));\n  }\n  return \"\";\n};","map":{"version":3,"names":["isCompositeFilterDescriptor","compose","ifElse","normalizeField","quote","toLower","isDateValue","isStringValue","serializeFilters","encodeValue","toUTC","normalizeFilters","formatDate","utcDates","field","value","ignoreCase","operator","toISOString","fnFormatter","singleOperatorFormatter","stringFormat","formatter","stringFnOperator","settings","stringOperator","numericOperator","dateOperator","ifDate","typedOperator","appendEqual","str","nonValueExpression","filterOperators","contains","Object","assign","doesnotcontain","endswith","eq","gt","gte","isempty","isnotempty","isnotnull","isnull","lt","lte","neq","startswith","join","x","logic","serialize","serializeAll","filter","serializeFilter","filters","length"],"sources":["C:/Internship/FoodShopUI/node_modules/@progress/kendo-data-query/dist/es2015/odata-filtering.operators.js"],"sourcesContent":["import { isCompositeFilterDescriptor } from './filtering/filter-descriptor.interface';\nimport { compose, ifElse } from './funcs';\nimport { normalizeField, quote, toLower, isDateValue, isStringValue, serializeFilters, encodeValue, toUTC } from './filter-serialization.common';\nimport { normalizeFilters } from './filtering/filter.operators';\nconst formatDate = ({ utcDates }) => ({ field, value, ignoreCase, operator }) => ({\n    value: (!utcDates ? toUTC(value) : value).toISOString(),\n    field,\n    ignoreCase,\n    operator\n});\nconst fnFormatter = ({ operator }) => ({ field, value }) => `${operator}(${field},${value})`;\nconst singleOperatorFormatter = ({ operator }) => ({ field, value }) => `${field} ${operator} ${value}`;\nconst stringFormat = formatter => compose(formatter, encodeValue, quote, toLower, normalizeField);\nconst stringFnOperator = settings => stringFormat(fnFormatter(settings));\nconst stringOperator = settings => stringFormat(singleOperatorFormatter(settings));\nconst numericOperator = settings => compose(singleOperatorFormatter(settings), normalizeField);\nconst dateOperator = settings => compose(singleOperatorFormatter(settings), normalizeField, formatDate(settings));\nconst ifDate = settings => ifElse(isDateValue, dateOperator(settings), numericOperator(settings));\nconst typedOperator = settings => ifElse(isStringValue, stringOperator(settings), ifDate(settings));\nconst appendEqual = str => `${str} eq -1`;\nconst nonValueExpression = formatter => compose(formatter, normalizeField);\nconst filterOperators = (operator, settings) => ({\n    contains: stringFnOperator(Object.assign(Object.assign({}, settings), { operator: \"contains\" })),\n    doesnotcontain: compose(appendEqual, stringFnOperator(Object.assign(Object.assign({}, settings), { operator: \"indexof\" }))),\n    endswith: stringFnOperator(Object.assign(Object.assign({}, settings), { operator: \"endswith\" })),\n    eq: typedOperator(Object.assign(Object.assign({}, settings), { operator: \"eq\" })),\n    gt: typedOperator(Object.assign(Object.assign({}, settings), { operator: \"gt\" })),\n    gte: typedOperator(Object.assign(Object.assign({}, settings), { operator: \"ge\" })),\n    isempty: nonValueExpression(({ field }) => `${field} eq ''`),\n    isnotempty: nonValueExpression(({ field }) => `${field} ne ''`),\n    isnotnull: nonValueExpression(({ field }) => `${field} ne null`),\n    isnull: nonValueExpression(({ field }) => `${field} eq null`),\n    lt: typedOperator(Object.assign(Object.assign({}, settings), { operator: \"lt\" })),\n    lte: typedOperator(Object.assign(Object.assign({}, settings), { operator: \"le\" })),\n    neq: typedOperator(Object.assign(Object.assign({}, settings), { operator: \"ne\" })),\n    startswith: stringFnOperator(Object.assign(Object.assign({}, settings), { operator: \"startswith\" }))\n}[operator]);\nconst join = x => ` ${x.logic} `;\nconst serialize = settings => x => filterOperators(x.operator, settings)(x);\nconst serializeAll = settings => serializeFilters(filter => ifElse(isCompositeFilterDescriptor, serializeAll(settings), serialize(settings))(filter), join);\n/**\n * @hidden\n */\nexport const serializeFilter = (filter, settings = {}) => {\n    if (filter.filters && filter.filters.length) {\n        return \"$filter=\" + serializeAll(settings)(normalizeFilters(filter));\n    }\n    return \"\";\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}